// Generated by js_of_ocaml 4.0.0
(function(Object)
   {typeof globalThis
    !==
    "object"
    &&
    (this
      ?get()
      :(Object.defineProperty
         (Object.prototype,"_T_",{configurable:true,get:get}),
        _T_));
    function get()
     {var global=this || self;
      global.globalThis = global;
      delete Object.prototype._T_}}
  (Object));
(function(globalThis)
   {!
    function(t,i)
      {"object" == typeof exports && "undefined" != typeof module
        ?i(exports)
        :"function" == typeof define && define.amd
          ?define(["exports"],i)
          :i(t.L = {})}
     (this,
      function(t)
       {"use strict";
        function h(t)
         {for(var i,e,n=1,o=arguments.length;n < o;n++)
           for(i in e = arguments[n])t[i] = e[i];
          return t}
        var s=Object.create || function(t){return i.prototype = t,new i()};
        function i(){}
        function p(t,i)
         {var e=Array.prototype.slice;
          if(t.bind)return t.bind.apply(t,e.call(arguments,1));
          var n=e.call(arguments,2);
          return function()
           {return t.apply(i,n.length?n.concat(e.call(arguments)):arguments)}}
        var e=0;
        function m(t)
         {return t._leaflet_id = t._leaflet_id || ++e,t._leaflet_id}
        function n(t,i,e)
         {var n,o;
          function s(){n = ! 1,o && (r.apply(e,o),o = ! 1)}
          function r()
           {n?o = arguments:(t.apply(e,arguments),setTimeout(s,i),n = ! 0)}
          return r}
        function o(t,i,e)
         {var n=i[1],o=i[0],s=n - o;
          return t === n && e?t:((t - o) % s + s) % s + o}
        function a(){return ! 1}
        function r(t,i)
         {var e=Math.pow(10,void 0 === i?6:i);return Math.round(t * e) / e}
        function u(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}
        function l(t){return u(t).split(/\s+/)}
        function c(t,i)
         {for
           (var e
            in
            
            Object.prototype.hasOwnProperty.call(t,"options")
            ||
            (t.options = t.options?s(t.options):{}),
            i)
           t.options[e] = i[e];
          return t.options}
        function _(t,i,e)
         {var n=[];
          for(var o in t)
           n.push
            (encodeURIComponent(e?o.toUpperCase():o)
             +
             "="
             +
             encodeURIComponent(t[o]));
          return (i && - 1 !== i.indexOf("?")?"&":"?") + n.join("&")}
        var d=/\{ *([\w_-]+) *\}/g;
        function f(t,n)
         {return t.replace
                  (d,
                   function(t,i)
                    {var e=n[i];
                     if(void 0 === e)
                      throw new Error("No value provided for variable " + t);
                     return "function" == typeof e && (e = e(n)),e})}
        var
         g=
          Array.isArray
          ||
          function(t)
           {return "[object Array]" === Object.prototype.toString.call(t)};
        function v(t,i)
         {for(var e=0;e < t.length;e++)if(t[e] === i)return e;return - 1}
        var y="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
        function x(t)
         {return window["webkit" + t] || window["moz" + t] || window["ms" + t]}
        var w=0;
        function P(t)
         {var i=+ new Date(),e=Math.max(0,16 - (i - w));
          return w = i + e,window.setTimeout(t,e)}
        var
         b=window.requestAnimationFrame || x("RequestAnimationFrame") || P,
         T=
          window.cancelAnimationFrame
          ||
          x("CancelAnimationFrame")
          ||
          x("CancelRequestAnimationFrame")
          ||
          function(t){window.clearTimeout(t)};
        function M(t,i,e)
         {if(! e || b !== P)return b.call(window,p(t,i));t.call(i)}
        function z(t){t && T.call(window,t)}
        var
         C=
          {extend:h,
           create:s,
           bind:p,
           lastId:e,
           stamp:m,
           throttle:n,
           wrapNum:o,
           falseFn:a,
           formatNum:r,
           trim:u,
           splitWords:l,
           setOptions:c,
           getParamString:_,
           template:f,
           isArray:g,
           indexOf:v,
           emptyImageUrl:y,
           requestFn:b,
           cancelFn:T,
           requestAnimFrame:M,
           cancelAnimFrame:z};
        function S(){}
        S.extend
        =
        function(t)
         {function i()
           {this.initialize
            &&
            this.initialize.apply(this,arguments),
            this.callInitHooks()}
          var e=i.__super__ = this.prototype,n=s(e);
          for(var o in (n.constructor = i).prototype = n,this)
           Object.prototype.hasOwnProperty.call(this,o)
           &&
           "prototype"
           !==
           o
           &&
           "__super__"
           !==
           o
           &&
           (i[o] = this[o]);
          return t.statics
                 &&
                 (h(i,t.statics),delete t.statics),
                 t.includes
                 &&
                 (function(t)
                    {if("undefined" == typeof L || ! L || ! L.Mixin)return;
                     t = g(t)?t:[t];
                     for(var i=0;i < t.length;i++)
                      t[i]
                      ===
                      L.Mixin.Events
                      &&
                      console.warn
                       ("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",
                        new Error().stack)}
                   (t.includes),
                  h.apply(null,[n].concat(t.includes)),
                  delete t.includes),
                 n.options
                 &&
                 (t.options = h(s(n.options),t.options)),
                 h(n,t),
                 n._initHooks
                 =
                 [],
                 n.callInitHooks
                 =
                 function()
                  {if(! this._initHooksCalled)
                    {e.callInitHooks
                     &&
                     e.callInitHooks.call(this),
                     this._initHooksCalled
                     =
                     !
                     0;
                     for(var t=0,i=n._initHooks.length;t < i;t++)
                      n._initHooks[t].call(this)}},
                 i},
        S.include
        =
        function(t){return h(this.prototype,t),this},
        S.mergeOptions
        =
        function(t){return h(this.prototype.options,t),this},
        S.addInitHook
        =
        function(t)
         {var
           i=Array.prototype.slice.call(arguments,1),
           e="function" == typeof t?t:function(){this[t].apply(this,i)};
          return this.prototype._initHooks
                 =
                 this.prototype._initHooks
                 ||
                 [],
                 this.prototype._initHooks.push(e),
                 this};
        var
         Z=
          {on:
           function(t,i,e)
            {if("object" == typeof t)
              for(var n in t)this._on(n,t[n],i);
             else
              for(var o=0,s=(t = l(t)).length;o < s;o++)this._on(t[o],i,e);
             return this},
           off:
           function(t,i,e)
            {if(t)
              if("object" == typeof t)
               for(var n in t)this._off(n,t[n],i);
              else
               for(var o=0,s=(t = l(t)).length;o < s;o++)this._off(t[o],i,e);
             else
              delete this._events;
             return this},
           _on:
           function(t,i,e)
            {this._events = this._events || {};
             var n=this._events[t];
             n || (n = [],this._events[t] = n),e === this && (e = void 0);
             for(var o={fn:i,ctx:e},s=n,r=0,a=s.length;r < a;r++)
              if(s[r].fn === i && s[r].ctx === e)return;
             s.push(o)},
           _off:
           function(t,i,e)
            {var n,o,s;
             if(this._events && (n = this._events[t]))
              if(i)
               {if(e === this && (e = void 0),n)
                 for(o = 0,s = n.length;o < s;o++)
                  {var r=n[o];
                   if(r.ctx === e && r.fn === i)
                    return r.fn
                           =
                           a,
                           this._firingCount
                           &&
                           (this._events[t] = n = n.slice()),
                           void n.splice(o,1)}}
              else
               {for(o = 0,s = n.length;o < s;o++)n[o].fn = a;
                delete this._events[t]}},
           fire:
           function(t,i,e)
            {if(! this.listens(t,e))return this;
             var
              n=
               h
                ({},
                 i,
                 {type:t,target:this,sourceTarget:i && i.sourceTarget || this});
             if(this._events)
              {var o=this._events[t];
               if(o)
                {this._firingCount = this._firingCount + 1 || 1;
                 for(var s=0,r=o.length;s < r;s++)
                  {var a=o[s];a.fn.call(a.ctx || this,n)}
                 this._firingCount--}}
             return e && this._propagateEvent(n),this},
           listens:
           function(t,i)
            {var e=this._events && this._events[t];
             if(e && e.length)return ! 0;
             if(i)
              for(var n in this._eventParents)
               if(this._eventParents[n].listens(t,i))return ! 0;
             return ! 1},
           once:
           function(t,i,e)
            {if("object" == typeof t)
              {for(var n in t)this.once(n,t[n],i);return this}
             var o=p(function(){this.off(t,i,e).off(t,o,e)},this);
             return this.on(t,i,e).on(t,o,e)},
           addEventParent:
           function(t)
            {return this._eventParents
                    =
                    this._eventParents
                    ||
                    {},
                    this._eventParents[m(t)]
                    =
                    t,
                    this},
           removeEventParent:
           function(t)
            {return this._eventParents && delete this._eventParents[m(t)],this},
           _propagateEvent:
           function(t)
            {for(var i in this._eventParents)
              this._eventParents[i].fire
               (t.type,h({layer:t.target,propagatedFrom:t.target},t),! 0)}};
        Z.addEventListener
        =
        Z.on,
        Z.removeEventListener
        =
        Z.clearAllEventListeners
        =
        Z.off,
        Z.addOneTimeEventListener
        =
        Z.once,
        Z.fireEvent
        =
        Z.fire,
        Z.hasEventListeners
        =
        Z.listens;
        var E=S.extend(Z);
        function k(t,i,e)
         {this.x = e?Math.round(t):t,this.y = e?Math.round(i):i}
        var
         B=
          Math.trunc || function(t){return 0 < t?Math.floor(t):Math.ceil(t)};
        function A(t,i,e)
         {return t instanceof k
                  ?t
                  :g(t)
                    ?new k(t[0],t[1])
                    :null == t
                      ?t
                      :"object" == typeof t && "x" in t && "y" in t
                        ?new k(t.x,t.y)
                        :new k(t,i,e)}
        function I(t,i)
         {if(t)for(var e=i?[t,i]:t,n=0,o=e.length;n < o;n++)this.extend(e[n])}
        function O(t,i){return ! t || t instanceof I?t:new I(t,i)}
        function R(t,i)
         {if(t)for(var e=i?[t,i]:t,n=0,o=e.length;n < o;n++)this.extend(e[n])}
        function N(t,i){return t instanceof R?t:new R(t,i)}
        function D(t,i,e)
         {if(isNaN(t) || isNaN(i))
           throw new Error("Invalid LatLng object: (" + t + ", " + i + ")");
          this.lat = + t,this.lng = + i,void 0 !== e && (this.alt = + e)}
        function j(t,i,e)
         {return t instanceof D
                  ?t
                  :g(t) && "object" != typeof t[0]
                    ?3 === t.length
                      ?new D(t[0],t[1],t[2])
                      :2 === t.length?new D(t[0],t[1]):null
                    :null == t
                      ?t
                      :"object" == typeof t && "lat" in t
                        ?new D(t.lat,"lng" in t?t.lng:t.lon,t.alt)
                        :void 0 === i?null:new D(t,i,e)}
        k.prototype
        =
        {clone:function(){return new k(this.x,this.y)},
         add:function(t){return this.clone()._add(A(t))},
         _add:function(t){return this.x += t.x,this.y += t.y,this},
         subtract:function(t){return this.clone()._subtract(A(t))},
         _subtract:function(t){return this.x -= t.x,this.y -= t.y,this},
         divideBy:function(t){return this.clone()._divideBy(t)},
         _divideBy:function(t){return this.x /= t,this.y /= t,this},
         multiplyBy:function(t){return this.clone()._multiplyBy(t)},
         _multiplyBy:function(t){return this.x *= t,this.y *= t,this},
         scaleBy:function(t){return new k(this.x * t.x,this.y * t.y)},
         unscaleBy:function(t){return new k(this.x / t.x,this.y / t.y)},
         round:function(){return this.clone()._round()},
         _round:
         function()
          {return this.x = Math.round(this.x),this.y = Math.round(this.y),this},
         floor:function(){return this.clone()._floor()},
         _floor:
         function()
          {return this.x = Math.floor(this.x),this.y = Math.floor(this.y),this},
         ceil:function(){return this.clone()._ceil()},
         _ceil:
         function()
          {return this.x = Math.ceil(this.x),this.y = Math.ceil(this.y),this},
         trunc:function(){return this.clone()._trunc()},
         _trunc:function(){return this.x = B(this.x),this.y = B(this.y),this},
         distanceTo:
         function(t)
          {var i=(t = A(t)).x - this.x,e=t.y - this.y;
           return Math.sqrt(i * i + e * e)},
         equals:function(t){return (t = A(t)).x === this.x && t.y === this.y},
         contains:
         function(t)
          {return t
                  =
                  A(t),
                  Math.abs(t.x)
                  <=
                  Math.abs(this.x)
                  &&
                  Math.abs(t.y)
                  <=
                  Math.abs(this.y)},
         toString:
         function(){return "Point(" + r(this.x) + ", " + r(this.y) + ")"}},
        I.prototype
        =
        {extend:
         function(t)
          {return t
                  =
                  A(t),
                  this.min || this.max
                   ?(this.min.x
                     =
                     Math.min(t.x,this.min.x),
                     this.max.x
                     =
                     Math.max(t.x,this.max.x),
                     this.min.y
                     =
                     Math.min(t.y,this.min.y),
                     this.max.y
                     =
                     Math.max(t.y,this.max.y))
                   :(this.min = t.clone(),this.max = t.clone()),
                  this},
         getCenter:
         function(t)
          {return new
                   k
                   ((this.min.x + this.max.x) / 2,
                    (this.min.y + this.max.y) / 2,
                    t)},
         getBottomLeft:function(){return new k(this.min.x,this.max.y)},
         getTopRight:function(){return new k(this.max.x,this.min.y)},
         getTopLeft:function(){return this.min},
         getBottomRight:function(){return this.max},
         getSize:function(){return this.max.subtract(this.min)},
         contains:
         function(t)
          {var i,e;
           return (t = ("number" == typeof t[0] || t instanceof k?A:O)(t))
                   instanceof
                   I
                   ?(i = t.min,e = t.max)
                   :i = e = t,
                  i.x
                  >=
                  this.min.x
                  &&
                  e.x
                  <=
                  this.max.x
                  &&
                  i.y
                  >=
                  this.min.y
                  &&
                  e.y
                  <=
                  this.max.y},
         intersects:
         function(t)
          {t = O(t);
           var
            i=this.min,
            e=this.max,
            n=t.min,
            o=t.max,
            s=o.x >= i.x && n.x <= e.x,
            r=o.y >= i.y && n.y <= e.y;
           return s && r},
         overlaps:
         function(t)
          {t = O(t);
           var
            i=this.min,
            e=this.max,
            n=t.min,
            o=t.max,
            s=o.x > i.x && n.x < e.x,
            r=o.y > i.y && n.y < e.y;
           return s && r},
         isValid:function(){return ! (! this.min || ! this.max)}},
        R.prototype
        =
        {extend:
         function(t)
          {var i,e,n=this._southWest,o=this._northEast;
           if(t instanceof D)
            e = i = t;
           else
            {if(! (t instanceof R))return t?this.extend(j(t) || N(t)):this;
             if(i = t._southWest,e = t._northEast,! i || ! e)return this}
           return n || o
                   ?(n.lat
                     =
                     Math.min(i.lat,n.lat),
                     n.lng
                     =
                     Math.min(i.lng,n.lng),
                     o.lat
                     =
                     Math.max(e.lat,o.lat),
                     o.lng
                     =
                     Math.max(e.lng,o.lng))
                   :(this._southWest
                     =
                     new D(i.lat,i.lng),
                     this._northEast
                     =
                     new D(e.lat,e.lng)),
                  this},
         pad:
         function(t)
          {var
            i=this._southWest,
            e=this._northEast,
            n=Math.abs(i.lat - e.lat) * t,
            o=Math.abs(i.lng - e.lng) * t;
           return new R(new D(i.lat - n,i.lng - o),new D(e.lat + n,e.lng + o))},
         getCenter:
         function()
          {return new
                   D
                   ((this._southWest.lat + this._northEast.lat) / 2,
                    (this._southWest.lng + this._northEast.lng) / 2)},
         getSouthWest:function(){return this._southWest},
         getNorthEast:function(){return this._northEast},
         getNorthWest:function(){return new D(this.getNorth(),this.getWest())},
         getSouthEast:function(){return new D(this.getSouth(),this.getEast())},
         getWest:function(){return this._southWest.lng},
         getSouth:function(){return this._southWest.lat},
         getEast:function(){return this._northEast.lng},
         getNorth:function(){return this._northEast.lat},
         contains:
         function(t)
          {t
           =
           ("number" == typeof t[0] || t instanceof D || "lat" in t?j:N)(t);
           var i,e,n=this._southWest,o=this._northEast;
           return t instanceof R
                   ?(i = t.getSouthWest(),e = t.getNorthEast())
                   :i = e = t,
                  i.lat
                  >=
                  n.lat
                  &&
                  e.lat
                  <=
                  o.lat
                  &&
                  i.lng
                  >=
                  n.lng
                  &&
                  e.lng
                  <=
                  o.lng},
         intersects:
         function(t)
          {t = N(t);
           var
            i=this._southWest,
            e=this._northEast,
            n=t.getSouthWest(),
            o=t.getNorthEast(),
            s=o.lat >= i.lat && n.lat <= e.lat,
            r=o.lng >= i.lng && n.lng <= e.lng;
           return s && r},
         overlaps:
         function(t)
          {t = N(t);
           var
            i=this._southWest,
            e=this._northEast,
            n=t.getSouthWest(),
            o=t.getNorthEast(),
            s=o.lat > i.lat && n.lat < e.lat,
            r=o.lng > i.lng && n.lng < e.lng;
           return s && r},
         toBBoxString:
         function()
          {return [this.getWest(),
                    this.getSouth(),
                    this.getEast(),
                    this.getNorth()].join
                   (",")},
         equals:
         function(t,i)
          {return !
                  !
                  t
                  &&
                  (t
                   =
                   N(t),
                   this._southWest.equals(t.getSouthWest(),i)
                   &&
                   this._northEast.equals(t.getNorthEast(),i))},
         isValid:function(){return ! (! this._southWest || ! this._northEast)}};
        var
         W,
         H=
          {latLngToPoint:
           function(t,i)
            {var e=this.projection.project(t),n=this.scale(i);
             return this.transformation._transform(e,n)},
           pointToLatLng:
           function(t,i)
            {var e=this.scale(i),n=this.transformation.untransform(t,e);
             return this.projection.unproject(n)},
           project:function(t){return this.projection.project(t)},
           unproject:function(t){return this.projection.unproject(t)},
           scale:function(t){return 256 * Math.pow(2,t)},
           zoom:function(t){return Math.log(t / 256) / Math.LN2},
           getProjectedBounds:
           function(t)
            {if(this.infinite)return null;
             var i=this.projection.bounds,e=this.scale(t);
             return new
                     I
                     (this.transformation.transform(i.min,e),
                      this.transformation.transform(i.max,e))},
           infinite:
           !
           (D.prototype
            =
            {equals:
             function(t,i)
              {return !
                      !
                      t
                      &&
                      (t
                       =
                       j(t),
                       Math.max
                        (Math.abs(this.lat - t.lat),Math.abs(this.lng - t.lng))
                       <=
                       (void 0 === i?1e-9:i))},
             toString:
             function(t)
              {return "LatLng(" + r(this.lat,t) + ", " + r(this.lng,t) + ")"},
             distanceTo:function(t){return F.distance(this,j(t))},
             wrap:function(){return F.wrapLatLng(this)},
             toBounds:
             function(t)
              {var
                i=180 * t / 40075017,
                e=i / Math.cos(Math.PI / 180 * this.lat);
               return N
                       ([this.lat - i,this.lng - e],[this.lat + i,this.lng + e])},
             clone:function(){return new D(this.lat,this.lng,this.alt)}}),
           wrapLatLng:
           function(t)
            {var i=this.wrapLng?o(t.lng,this.wrapLng,! 0):t.lng;
             return new
                     D
                     (this.wrapLat?o(t.lat,this.wrapLat,! 0):t.lat,i,t.alt)},
           wrapLatLngBounds:
           function(t)
            {var
              i=t.getCenter(),
              e=this.wrapLatLng(i),
              n=i.lat - e.lat,
              o=i.lng - e.lng;
             if(0 == n && 0 == o)return t;
             var s=t.getSouthWest(),r=t.getNorthEast();
             return new
                     R
                     (new D(s.lat - n,s.lng - o),new D(r.lat - n,r.lng - o))}},
         F=
          h
           ({},
            H,
            {wrapLng:[- 180,180],
             R:6371e3,
             distance:
             function(t,i)
              {var
                e=Math.PI / 180,
                n=t.lat * e,
                o=i.lat * e,
                s=Math.sin((i.lat - t.lat) * e / 2),
                r=Math.sin((i.lng - t.lng) * e / 2),
                a=s * s + Math.cos(n) * Math.cos(o) * r * r,
                h=2 * Math.atan2(Math.sqrt(a),Math.sqrt(1 - a));
               return this.R * h}}),
         U=6378137,
         V=
          {R:U,
           MAX_LATITUDE:85.0511287798,
           project:
           function(t)
            {var
              i=Math.PI / 180,
              e=this.MAX_LATITUDE,
              n=Math.max(Math.min(e,t.lat),- e),
              o=Math.sin(n * i);
             return new
                     k
                     (this.R * t.lng * i,
                      this.R * Math.log((1 + o) / (1 - o)) / 2)},
           unproject:
           function(t)
            {var i=180 / Math.PI;
             return new
                     D
                     ((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * i,
                      t.x * i / this.R)},
           bounds:new I([- (W = U * Math.PI),- W],[W,W])};
        function q(t,i,e,n)
         {if(g(t))
           return this._a
                  =
                  t[0],
                  this._b
                  =
                  t[1],
                  this._c
                  =
                  t[2],
                  void (this._d = t[3]);
          this._a = t,this._b = i,this._c = e,this._d = n}
        function G(t,i,e,n){return new q(t,i,e,n)}
        q.prototype
        =
        {transform:function(t,i){return this._transform(t.clone(),i)},
         _transform:
         function(t,i)
          {return i
                  =
                  i
                  ||
                  1,
                  t.x
                  =
                  i
                  *
                  (this._a * t.x + this._b),
                  t.y
                  =
                  i
                  *
                  (this._c * t.y + this._d),
                  t},
         untransform:
         function(t,i)
          {return i
                  =
                  i
                  ||
                  1,
                  new
                   k
                   ((t.x / i - this._b) / this._a,
                    (t.y / i - this._d) / this._c)}};
        var
         K,
         Y=
          h
           ({},
            F,
            {code:"EPSG:3857",
             projection:V,
             transformation:G(K = .5 / (Math.PI * V.R),.5,- K,.5)}),
         X=h({},Y,{code:"EPSG:900913"});
        function J(t)
         {return document.createElementNS("http://www.w3.org/2000/svg",t)}
        function $(t,i)
         {for(var e,n,o,s,r="",a=0,h=t.length;a < h;a++)
           {for(e = 0,n = (o = t[a]).length;e < n;e++)
             r += (e?"L":"M") + (s = o[e]).x + " " + s.y;
            r += i?Zt?"z":"x":""}
          return r || "M0 0"}
        var
         Q=document.documentElement.style,
         tt="ActiveXObject" in window,
         it=tt && ! document.addEventListener,
         et="msLaunchUri" in navigator && ! ("documentMode" in document),
         nt=kt("webkit"),
         ot=kt("android"),
         st=kt("android 2") || kt("android 3"),
         rt=parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),
         at=ot && kt("Google") && rt < 537 && ! ("AudioNode" in window),
         ht=! ! window.opera,
         ut=! et && kt("chrome"),
         lt=kt("gecko") && ! nt && ! ht && ! tt,
         ct=! ut && kt("safari"),
         _t=kt("phantom"),
         dt="OTransition" in Q,
         pt=0 === navigator.platform.indexOf("Win"),
         mt=tt && "transition" in Q,
         ft=
          "WebKitCSSMatrix" in window
          &&
          "m11" in new (window.WebKitCSSMatrix)()
          &&
          !
          st,
         gt="MozPerspective" in Q,
         vt=! window.L_DISABLE_3D && (mt || ft || gt) && ! dt && ! _t,
         yt="undefined" != typeof orientation || kt("mobile"),
         xt=yt && nt,
         wt=yt && ft,
         Pt=! window.PointerEvent && window.MSPointerEvent,
         Lt=! (! window.PointerEvent && ! Pt),
         bt=
          !
          window.L_NO_TOUCH
          &&
          (Lt
           ||
           "ontouchstart" in window
           ||
           window.DocumentTouch
           &&
           document instanceof window.DocumentTouch),
         Tt=yt && ht,
         Mt=yt && lt,
         zt=
          1
          <
          (window.devicePixelRatio
           ||
           window.screen.deviceXDPI
           /
           window.screen.logicalXDPI),
         Ct=
          function()
            {var t=! 1;
             try
              {var
                i=
                 Object.defineProperty({},"passive",{get:function(){t = ! 0}});
               window.addEventListener("testPassiveEventSupport",a,i),
               window.removeEventListener("testPassiveEventSupport",a,i)}
             catch(t){}
             return t}
           (),
         St=! ! document.createElement("canvas").getContext,
         Zt=! (! document.createElementNS || ! J("svg").createSVGRect),
         Et=
          !
          Zt
          &&
          function()
            {try
              {var t=document.createElement("div");
               t.innerHTML = '<v:shape adj="1"/>';
               var i=t.firstChild;
               return i.style.behavior
                      =
                      "url(#default#VML)",
                      i
                      &&
                      "object"
                      ==
                      typeof i.adj}
             catch(t){return ! 1}}
           ();
        function kt(t)
         {return 0 <= navigator.userAgent.toLowerCase().indexOf(t)}
        var
         Bt=
          {ie:tt,
           ielt9:it,
           edge:et,
           webkit:nt,
           android:ot,
           android23:st,
           androidStock:at,
           opera:ht,
           chrome:ut,
           gecko:lt,
           safari:ct,
           phantom:_t,
           opera12:dt,
           win:pt,
           ie3d:mt,
           webkit3d:ft,
           gecko3d:gt,
           any3d:vt,
           mobile:yt,
           mobileWebkit:xt,
           mobileWebkit3d:wt,
           msPointer:Pt,
           pointer:Lt,
           touch:bt,
           mobileOpera:Tt,
           mobileGecko:Mt,
           retina:zt,
           passiveEvents:Ct,
           canvas:St,
           svg:Zt,
           vml:Et},
         At=Pt?"MSPointerDown":"pointerdown",
         It=Pt?"MSPointerMove":"pointermove",
         Ot=Pt?"MSPointerUp":"pointerup",
         Rt=Pt?"MSPointerCancel":"pointercancel",
         Nt={},
         Dt=! 1;
        function jt(t,i,e,n)
         {function o(t){Ut(t,r)}
          var s,r,a,h,u,l,c,_;
          function d(t)
           {t.pointerType
            ===
            (t.MSPOINTER_TYPE_MOUSE || "mouse")
            &&
            0
            ===
            t.buttons
            ||
            Ut(t,h)}
          return "touchstart" === i
                  ?(u
                    =
                    t,
                    l
                    =
                    e,
                    c
                    =
                    n,
                    _
                    =
                    p
                     (function(t)
                       {t.MSPOINTER_TYPE_TOUCH
                        &&
                        t.pointerType
                        ===
                        t.MSPOINTER_TYPE_TOUCH
                        &&
                        Ri(t),
                        Ut(t,l)}),
                    u["_leaflet_touchstart" + c]
                    =
                    _,
                    u.addEventListener(At,_,! 1),
                    Dt
                    ||
                    (document.addEventListener(At,Wt,! 0),
                     document.addEventListener(It,Ht,! 0),
                     document.addEventListener(Ot,Ft,! 0),
                     document.addEventListener(Rt,Ft,! 0),
                     Dt
                     =
                     !
                     0))
                  :"touchmove" === i
                    ?(h
                      =
                      e,
                      (a = t)["_leaflet_touchmove" + n]
                      =
                      d,
                      a.addEventListener(It,d,! 1))
                    :"touchend"
                     ===
                     i
                     &&
                     (r
                      =
                      e,
                      (s = t)["_leaflet_touchend" + n]
                      =
                      o,
                      s.addEventListener(Ot,o,! 1),
                      s.addEventListener(Rt,o,! 1)),
                 this}
        function Wt(t){Nt[t.pointerId] = t}
        function Ht(t){Nt[t.pointerId] && (Nt[t.pointerId] = t)}
        function Ft(t){delete Nt[t.pointerId]}
        function Ut(t,i)
         {for(var e in t.touches = [],Nt)t.touches.push(Nt[e]);
          t.changedTouches = [t],i(t)}
        var
         Vt=Pt?"MSPointerDown":Lt?"pointerdown":"touchstart",
         qt=Pt?"MSPointerUp":Lt?"pointerup":"touchend",
         Gt="_leaflet_",
         Kt,
         Yt,
         Xt,
         Jt,
         $t,
         Qt,
         ti=
          fi
           (["transform",
             "webkitTransform",
             "OTransform",
             "MozTransform",
             "msTransform"]),
         ii=
          fi
           (["webkitTransition",
             "transition",
             "OTransition",
             "MozTransition",
             "msTransition"]),
         ei=
          "webkitTransition" === ii || "OTransition" === ii
           ?ii + "End"
           :"transitionend";
        function ni(t)
         {return "string" == typeof t?document.getElementById(t):t}
        function oi(t,i)
         {var e,n=t.style[i] || t.currentStyle && t.currentStyle[i];
          return n
                 &&
                 "auto"
                 !==
                 n
                 ||
                 !
                 document.defaultView
                 ||
                 (n
                  =
                  (e = document.defaultView.getComputedStyle(t,null))
                   ?e[i]
                   :null),
                 "auto" === n?null:n}
        function si(t,i,e)
         {var n=document.createElement(t);
          return n.className = i || "",e && e.appendChild(n),n}
        function ri(t){var i=t.parentNode;i && i.removeChild(t)}
        function ai(t){for(;t.firstChild;)t.removeChild(t.firstChild)}
        function hi(t)
         {var i=t.parentNode;i && i.lastChild !== t && i.appendChild(t)}
        function ui(t)
         {var i=t.parentNode;
          i && i.firstChild !== t && i.insertBefore(t,i.firstChild)}
        function li(t,i)
         {if(void 0 !== t.classList)return t.classList.contains(i);
          var e=pi(t);
          return 0 < e.length && new RegExp("(^|\\s)" + i + "(\\s|$)").test(e)}
        function ci(t,i)
         {var e;
          if(void 0 !== t.classList)
           for(var n=l(i),o=0,s=n.length;o < s;o++)t.classList.add(n[o]);
          else
           li(t,i) || di(t,((e = pi(t))?e + " ":"") + i)}
        function _i(t,i)
         {void 0 !== t.classList
           ?t.classList.remove(i)
           :di(t,u((" " + pi(t) + " ").replace(" " + i + " "," ")))}
        function di(t,i)
         {void 0 === t.className.baseVal
           ?t.className = i
           :t.className.baseVal = i}
        function pi(t)
         {return t.correspondingElement
                 &&
                 (t = t.correspondingElement),
                 void 0 === t.className.baseVal
                  ?t.className
                  :t.className.baseVal}
        function mi(t,i)
         {"opacity" in t.style
           ?t.style.opacity = i
           :"filter" in t.style
            &&
            function(t,i)
              {var e=! 1,n="DXImageTransform.Microsoft.Alpha";
               try {e = t.filters.item(n)}catch(t){if(1 === i)return}
               i
               =
               Math.round(100 * i),
               e
                ?(e.Enabled = 100 !== i,e.Opacity = i)
                :t.style.filter += " progid:" + n + "(opacity=" + i + ")"}
             (t,i)}
        function fi(t)
         {for(var i=document.documentElement.style,e=0;e < t.length;e++)
           if(t[e] in i)return t[e];
          return ! 1}
        function gi(t,i,e)
         {var n=i || new k(0,0);
          t.style[ti]
          =
          (mt
            ?"translate(" + n.x + "px," + n.y + "px)"
            :"translate3d(" + n.x + "px," + n.y + "px,0)")
          +
          (e?" scale(" + e + ")":"")}
        function vi(t,i)
         {t._leaflet_pos
          =
          i,
          vt?gi(t,i):(t.style.left = i.x + "px",t.style.top = i.y + "px")}
        function yi(t){return t._leaflet_pos || new k(0,0)}
        function xi(){zi(window,"dragstart",Ri)}
        function wi(){Si(window,"dragstart",Ri)}
        function Pi(t)
         {for(;- 1 === t.tabIndex;)t = t.parentNode;
          t.style
          &&
          (Li(),
           Qt
           =
           ($t = t).style.outline,
           t.style.outline
           =
           "none",
           zi(window,"keydown",Li))}
        function Li()
         {$t
          &&
          ($t.style.outline = Qt,Qt = $t = void 0,Si(window,"keydown",Li))}
        function bi(t)
         {for
           (;
            !
            ((t = t.parentNode).offsetWidth
             &&
             t.offsetHeight
             ||
             t
             ===
             document.body);
            )
           ;
          return t}
        function Ti(t)
         {var i=t.getBoundingClientRect();
          return {x:i.width / t.offsetWidth || 1,
                  y:i.height / t.offsetHeight || 1,
                  boundingClientRect:i}}
        Jt
        =
        "onselectstart" in document
         ?(Xt
           =
           function(){zi(window,"selectstart",Ri)},
           function(){Si(window,"selectstart",Ri)})
         :(Yt
           =
           fi
            (["userSelect",
              "WebkitUserSelect",
              "OUserSelect",
              "MozUserSelect",
              "msUserSelect"]),
           Xt
           =
           function()
            {var t;
             Yt
             &&
             (t = document.documentElement.style,Kt = t[Yt],t[Yt] = "none")},
           function()
            {Yt && (document.documentElement.style[Yt] = Kt,Kt = void 0)});
        var
         Mi=
          {TRANSFORM:ti,
           TRANSITION:ii,
           TRANSITION_END:ei,
           get:ni,
           getStyle:oi,
           create:si,
           remove:ri,
           empty:ai,
           toFront:hi,
           toBack:ui,
           hasClass:li,
           addClass:ci,
           removeClass:_i,
           setClass:di,
           getClass:pi,
           setOpacity:mi,
           testProp:fi,
           setTransform:gi,
           setPosition:vi,
           getPosition:yi,
           disableTextSelection:Xt,
           enableTextSelection:Jt,
           disableImageDrag:xi,
           enableImageDrag:wi,
           preventOutline:Pi,
           restoreOutline:Li,
           getSizedParentNode:bi,
           getScale:Ti};
        function zi(t,i,e,n)
         {if("object" == typeof i)
           for(var o in i)ki(t,o,i[o],e);
          else
           for(var s=0,r=(i = l(i)).length;s < r;s++)ki(t,i[s],e,n);
          return this}
        var Ci="_leaflet_events";
        function Si(t,i,e,n)
         {if("object" == typeof i)
           for(var o in i)Bi(t,o,i[o],e);
          else
           if(i)
            for(var s=0,r=(i = l(i)).length;s < r;s++)Bi(t,i[s],e,n);
           else
            {for(var a in t[Ci])Bi(t,a,t[Ci][a]);delete t[Ci]}
          return this}
        function Zi(){return Lt && ! et && ! ct}
        var
         Ei=
          {mouseenter:"mouseover",
           mouseleave:"mouseout",
           wheel:! ("onwheel" in window) && "mousewheel"};
        function ki(i,t,e,n)
         {var o=t + m(e) + (n?"_" + m(n):"");
          if(i[Ci] && i[Ci][o])return this;
          var s,r,a,h,u,l;
          function c(t){return e.call(n || i,t || window.event)}
          var _=c;
          function d(t)
           {if(Lt)
             {if(! t.isPrimary)return;if("mouse" === t.pointerType)return}
            else
             if(1 < t.touches.length)return;
            var i=Date.now(),e=i - (h || i);
            u = t.touches?t.touches[0]:t,l = 0 < e && e <= 250,h = i}
          function p(t)
           {if(l && ! u.cancelBubble)
             {if(Lt)
               {if("mouse" === t.pointerType)return;
                var i,e,n={};
                for(e in u)i = u[e],n[e] = i && i.bind?i.bind(u):i;
                u = n}
              u.type = "dblclick",u.button = 0,r(u),h = null}}
          Lt && 0 === t.indexOf("touch")
           ?jt(i,t,c,o)
           :bt && "dblclick" === t && ! Zi()
             ?(r
               =
               c,
               l
               =
               !
               1,
               (s = i)[Gt + Vt + (a = o)]
               =
               d,
               s[Gt + qt + a]
               =
               p,
               s[Gt + "dblclick" + a]
               =
               r,
               s.addEventListener(Vt,d,! ! Ct && {passive:! 1}),
               s.addEventListener(qt,p,! ! Ct && {passive:! 1}),
               s.addEventListener("dblclick",r,! 1))
             :"addEventListener" in i
               ?"touchstart"
                 ===
                 t
                 ||
                 "touchmove"
                 ===
                 t
                 ||
                 "wheel"
                 ===
                 t
                 ||
                 "mousewheel"
                 ===
                 t
                 ?i.addEventListener(Ei[t] || t,c,! ! Ct && {passive:! 1})
                 :"mouseenter" === t || "mouseleave" === t
                   ?(c
                     =
                     function(t){t = t || window.event,Vi(i,t) && _(t)},
                     i.addEventListener(Ei[t],c,! 1))
                   :i.addEventListener(t,_,! 1)
               :"attachEvent" in i && i.attachEvent("on" + t,c),
          i[Ci]
          =
          i[Ci]
          ||
          {},
          i[Ci][o]
          =
          c}
        function Bi(t,i,e,n)
         {var
           o,
           s,
           r,
           a,
           h,
           u,
           l,
           c,
           _=i + m(e) + (n?"_" + m(n):""),
           d=t[Ci] && t[Ci][_];
          if(! d)return this;
          Lt && 0 === i.indexOf("touch")
           ?(c
             =
             (u = t)["_leaflet_" + (l = i) + _],
             "touchstart" === l
              ?u.removeEventListener(At,c,! 1)
              :"touchmove" === l
                ?u.removeEventListener(It,c,! 1)
                :"touchend"
                 ===
                 l
                 &&
                 (u.removeEventListener(Ot,c,! 1),
                  u.removeEventListener(Rt,c,! 1)))
           :bt && "dblclick" === i && ! Zi()
             ?(r
               =
               (o = t)[Gt + Vt + (s = _)],
               a
               =
               o[Gt + qt + s],
               h
               =
               o[Gt + "dblclick" + s],
               o.removeEventListener(Vt,r,! ! Ct && {passive:! 1}),
               o.removeEventListener(qt,a,! ! Ct && {passive:! 1}),
               o.removeEventListener("dblclick",h,! 1))
             :"removeEventListener" in t
               ?t.removeEventListener(Ei[i] || i,d,! 1)
               :"detachEvent" in t && t.detachEvent("on" + i,d),
          t[Ci][_]
          =
          null}
        function Ai(t)
         {return t.stopPropagation
                  ?t.stopPropagation()
                  :t.originalEvent
                    ?t.originalEvent._stopped = ! 0
                    :t.cancelBubble = ! 0,
                 Ui(t),
                 this}
        function Ii(t){return ki(t,"wheel",Ai),this}
        function Oi(t)
         {return zi(t,"mousedown touchstart dblclick",Ai),
                 ki(t,"click",Fi),
                 this}
        function Ri(t)
         {return t.preventDefault?t.preventDefault():t.returnValue = ! 1,this}
        function Ni(t){return Ri(t),Ai(t),this}
        function Di(t,i)
         {if(! i)return new k(t.clientX,t.clientY);
          var e=Ti(i),n=e.boundingClientRect;
          return new
                  k
                  ((t.clientX - n.left) / e.x - i.clientLeft,
                   (t.clientY - n.top) / e.y - i.clientTop)}
        var
         ji=
          pt && ut?2 * window.devicePixelRatio:lt?window.devicePixelRatio:1;
        function Wi(t)
         {return et
                  ?t.wheelDeltaY / 2
                  :t.deltaY && 0 === t.deltaMode
                    ?- (t.deltaY / ji)
                    :t.deltaY && 1 === t.deltaMode
                      ?20 * - t.deltaY
                      :t.deltaY && 2 === t.deltaMode
                        ?60 * - t.deltaY
                        :t.deltaX || t.deltaZ
                          ?0
                          :t.wheelDelta
                            ?(t.wheelDeltaY || t.wheelDelta) / 2
                            :t.detail && Math.abs(t.detail) < 32765
                              ?20 * - t.detail
                              :t.detail?t.detail / - (32765 * 60):0}
        var Hi={};
        function Fi(t){Hi[t.type] = ! 0}
        function Ui(t){var i=Hi[t.type];return Hi[t.type] = ! 1,i}
        function Vi(t,i)
         {var e=i.relatedTarget;
          if(! e)return ! 0;
          try {for(;e && e !== t;)e = e.parentNode}catch(t){return ! 1}
          return e !== t}
        var
         qi=
          {on:zi,
           off:Si,
           stopPropagation:Ai,
           disableScrollPropagation:Ii,
           disableClickPropagation:Oi,
           preventDefault:Ri,
           stop:Ni,
           getMousePosition:Di,
           getWheelDelta:Wi,
           fakeStop:Fi,
           skipped:Ui,
           isExternalTarget:Vi,
           addListener:zi,
           removeListener:Si},
         Gi=
          E.extend
           ({run:
             function(t,i,e,n)
              {this.stop(),
               this._el
               =
               t,
               this._inProgress
               =
               !
               0,
               this._duration
               =
               e
               ||
               .25,
               this._easeOutPower
               =
               1
               /
               Math.max(n || .5,.2),
               this._startPos
               =
               yi(t),
               this._offset
               =
               i.subtract(this._startPos),
               this._startTime
               =
               +
               new Date(),
               this.fire("start"),
               this._animate()},
             stop:
             function()
              {this._inProgress && (this._step(! 0),this._complete())},
             _animate:
             function(){this._animId = M(this._animate,this),this._step()},
             _step:
             function(t)
              {var i=new Date() - this._startTime,e=1e3 * this._duration;
               i < e
                ?this._runFrame(this._easeOut(i / e),t)
                :(this._runFrame(1),this._complete())},
             _runFrame:
             function(t,i)
              {var e=this._startPos.add(this._offset.multiplyBy(t));
               i && e._round(),vi(this._el,e),this.fire("step")},
             _complete:
             function()
              {z(this._animId),this._inProgress = ! 1,this.fire("end")},
             _easeOut:
             function(t){return 1 - Math.pow(1 - t,this._easeOutPower)}}),
         Ki=
          E.extend
           ({options:
             {crs:Y,
              center:void 0,
              zoom:void 0,
              minZoom:void 0,
              maxZoom:void 0,
              layers:[],
              maxBounds:void 0,
              renderer:void 0,
              zoomAnimation:! 0,
              zoomAnimationThreshold:4,
              fadeAnimation:! 0,
              markerZoomAnimation:! 0,
              transform3DLimit:8388608,
              zoomSnap:1,
              zoomDelta:1,
              trackResize:! 0},
             initialize:
             function(t,i)
              {i
               =
               c(this,i),
               this._handlers
               =
               [],
               this._layers
               =
               {},
               this._zoomBoundLayers
               =
               {},
               this._sizeChanged
               =
               !
               0,
               this._initContainer(t),
               this._initLayout(),
               this._onResize
               =
               p(this._onResize,this),
               this._initEvents(),
               i.maxBounds
               &&
               this.setMaxBounds(i.maxBounds),
               void 0
               !==
               i.zoom
               &&
               (this._zoom = this._limitZoom(i.zoom)),
               i.center
               &&
               void 0
               !==
               i.zoom
               &&
               this.setView(j(i.center),i.zoom,{reset:! 0}),
               this.callInitHooks(),
               this._zoomAnimated
               =
               ii
               &&
               vt
               &&
               !
               Tt
               &&
               this.options.zoomAnimation,
               this._zoomAnimated
               &&
               (this._createAnimProxy(),
                zi(this._proxy,ei,this._catchTransitionEnd,this)),
               this._addLayers(this.options.layers)},
             setView:
             function(t,i,e)
              {if
                ((i
                  =
                  void 0 === i?this._zoom:this._limitZoom(i),
                  t
                  =
                  this._limitCenter(j(t),i,this.options.maxBounds),
                  e
                  =
                  e
                  ||
                  {},
                  this._stop(),
                  this._loaded
                  &&
                  !
                  e.reset
                  &&
                  !
                  0
                  !==
                  e)
                 &&
                 (void 0
                  !==
                  e.animate
                  &&
                  (e.zoom
                   =
                   h({animate:e.animate},e.zoom),
                   e.pan
                   =
                   h({animate:e.animate,duration:e.duration},e.pan)),
                  this._zoom !== i
                   ?this._tryAnimatedZoom && this._tryAnimatedZoom(t,i,e.zoom)
                   :this._tryAnimatedPan(t,e.pan)))
                return clearTimeout(this._sizeTimer),this;
               return this._resetView(t,i),this},
             setZoom:
             function(t,i)
              {return this._loaded
                       ?this.setView(this.getCenter(),t,{zoom:i})
                       :(this._zoom = t,this)},
             zoomIn:
             function(t,i)
              {return t
                      =
                      t
                      ||
                      (vt?this.options.zoomDelta:1),
                      this.setZoom(this._zoom + t,i)},
             zoomOut:
             function(t,i)
              {return t
                      =
                      t
                      ||
                      (vt?this.options.zoomDelta:1),
                      this.setZoom(this._zoom - t,i)},
             setZoomAround:
             function(t,i,e)
              {var
                n=this.getZoomScale(i),
                o=this.getSize().divideBy(2),
                s=
                 (t instanceof k?t:this.latLngToContainerPoint(t)).subtract(o).multiplyBy
                  (1 - 1 / n),
                r=this.containerPointToLatLng(o.add(s));
               return this.setView(r,i,{zoom:e})},
             _getBoundsCenterZoom:
             function(t,i)
              {i = i || {},t = t.getBounds?t.getBounds():N(t);
               var
                e=A(i.paddingTopLeft || i.padding || [0,0]),
                n=A(i.paddingBottomRight || i.padding || [0,0]),
                o=this.getBoundsZoom(t,! 1,e.add(n));
               if
                ((o = "number" == typeof i.maxZoom?Math.min(i.maxZoom,o):o)
                 ===
                 1
                 /
                 0)
                return {center:t.getCenter(),zoom:o};
               var
                s=n.subtract(e).divideBy(2),
                r=this.project(t.getSouthWest(),o),
                a=this.project(t.getNorthEast(),o);
               return {center:this.unproject(r.add(a).divideBy(2).add(s),o),
                       zoom:o}},
             fitBounds:
             function(t,i)
              {if(! (t = N(t)).isValid())
                throw new Error("Bounds are not valid.");
               var e=this._getBoundsCenterZoom(t,i);
               return this.setView(e.center,e.zoom,i)},
             fitWorld:
             function(t){return this.fitBounds([[- 90,- 180],[90,180]],t)},
             panTo:function(t,i){return this.setView(t,this._zoom,{pan:i})},
             panBy:
             function(t,i)
              {return i
                      =
                      i
                      ||
                      {},
                      (t = A(t).round()).x || t.y
                       ?(! 0 === i.animate || this.getSize().contains(t)
                          ?(this._panAnim
                            ||
                            (this._panAnim
                             =
                             new Gi(),
                             this._panAnim.on
                              ({step:this._onPanTransitionStep,
                                end:this._onPanTransitionEnd},
                               this)),
                            i.noMoveStart
                            ||
                            this.fire("movestart"),
                            ! 1 !== i.animate
                             ?(ci(this._mapPane,"leaflet-pan-anim"),
                               e
                               =
                               this._getMapPanePos().subtract(t).round(),
                               this._panAnim.run
                                (this._mapPane,e,i.duration || .25,i.easeLinearity))
                             :(this._rawPanBy(t),this.fire("move").fire("moveend")))
                          :this._resetView
                            (this.unproject(this.project(this.getCenter()).add(t)),
                             this.getZoom()),
                         this)
                       :this.fire("moveend");
               var e},
             flyTo:
             function(s,r,t)
              {if(! 1 === (t = t || {}).animate || ! vt)
                return this.setView(s,r,t);
               this._stop();
               var
                a=this.project(this.getCenter()),
                h=this.project(s),
                i=this.getSize(),
                u=this._zoom;
               s = j(s),r = void 0 === r?u:r;
               var
                l=Math.max(i.x,i.y),
                n=l * this.getZoomScale(u,r),
                c=h.distanceTo(a) || 1,
                _=1.42,
                o=_ * _;
               function e(t)
                {var
                  i=
                   (n * n - l * l + (t?- 1:1) * o * o * c * c)
                   /
                   (2 * (t?n:l) * o * c),
                  e=Math.sqrt(i * i + 1) - i;
                 return e < 1e-9?- 18:Math.log(e)}
               function d(t){return (Math.exp(t) - Math.exp(- t)) / 2}
               function p(t){return (Math.exp(t) + Math.exp(- t)) / 2}
               var m=e(0);
               function f(t)
                {return l * (p(m) * (d(i = m + _ * t) / p(i)) - d(m)) / o;
                 var i}
               var
                g=Date.now(),
                v=(e(1) - m) / _,
                y=t.duration?1e3 * t.duration:1e3 * v * .8;
               return this._moveStart(! 0,t.noMoveStart),
                      function t()
                        {var
                          i,
                          e,
                          n=(Date.now() - g) / y,
                          o=(i = n,(1 - Math.pow(1 - i,1.5)) * v);
                         n <= 1
                          ?(this._flyToFrame
                            =
                            M(t,this),
                            this._move
                             (this.unproject(a.add(h.subtract(a).multiplyBy(f(o) / c)),u),
                              this.getScaleZoom(l / (e = o,l * (p(m) / p(m + _ * e))),u),
                              {flyTo:! 0}))
                          :this._move(s,r)._moveEnd(! 0)}.call
                       (this),
                      this},
             flyToBounds:
             function(t,i)
              {var e=this._getBoundsCenterZoom(t,i);
               return this.flyTo(e.center,e.zoom,i)},
             setMaxBounds:
             function(t)
              {return (t = N(t)).isValid()
                       ?(this.options.maxBounds
                         &&
                         this.off("moveend",this._panInsideMaxBounds),
                         this.options.maxBounds
                         =
                         t,
                         this._loaded
                         &&
                         this._panInsideMaxBounds(),
                         this.on("moveend",this._panInsideMaxBounds))
                       :(this.options.maxBounds
                         =
                         null,
                         this.off("moveend",this._panInsideMaxBounds))},
             setMinZoom:
             function(t)
              {var i=this.options.minZoom;
               return this.options.minZoom
                      =
                      t,
                      this._loaded
                       &&
                       i
                       !==
                       t
                       &&
                       (this.fire("zoomlevelschange"),
                        this.getZoom()
                        <
                        this.options.minZoom)
                       ?this.setZoom(t)
                       :this},
             setMaxZoom:
             function(t)
              {var i=this.options.maxZoom;
               return this.options.maxZoom
                      =
                      t,
                      this._loaded
                       &&
                       i
                       !==
                       t
                       &&
                       (this.fire("zoomlevelschange"),
                        this.getZoom()
                        >
                        this.options.maxZoom)
                       ?this.setZoom(t)
                       :this},
             panInsideBounds:
             function(t,i)
              {this._enforcingBounds = ! 0;
               var e=this.getCenter(),n=this._limitCenter(e,this._zoom,N(t));
               return e.equals(n)
                      ||
                      this.panTo(n,i),
                      this._enforcingBounds
                      =
                      !
                      1,
                      this},
             panInside:
             function(t,i)
              {var
                e,
                n,
                o=A((i = i || {}).paddingTopLeft || i.padding || [0,0]),
                s=A(i.paddingBottomRight || i.padding || [0,0]),
                r=this.getCenter(),
                a=this.project(r),
                h=this.project(t),
                u=this.getPixelBounds(),
                l=u.getSize().divideBy(2),
                c=O([u.min.add(o),u.max.subtract(s)]);
               return c.contains(h)
                      ||
                      (this._enforcingBounds
                       =
                       !
                       0,
                       e
                       =
                       a.subtract(h),
                       n
                       =
                       A(h.x + e.x,h.y + e.y),
                       (h.x < c.min.x || h.x > c.max.x)
                       &&
                       (n.x = a.x - e.x,0 < e.x?n.x += l.x - o.x:n.x -= l.x - s.x),
                       (h.y < c.min.y || h.y > c.max.y)
                       &&
                       (n.y = a.y - e.y,0 < e.y?n.y += l.y - o.y:n.y -= l.y - s.y),
                       this.panTo(this.unproject(n),i),
                       this._enforcingBounds
                       =
                       !
                       1),
                      this},
             invalidateSize:
             function(t)
              {if(! this._loaded)return this;
               t = h({animate:! 1,pan:! 0},! 0 === t?{animate:! 0}:t);
               var i=this.getSize();
               this._sizeChanged = ! 0,this._lastCenter = null;
               var
                e=this.getSize(),
                n=i.divideBy(2).round(),
                o=e.divideBy(2).round(),
                s=n.subtract(o);
               return s.x || s.y
                       ?(t.animate && t.pan
                          ?this.panBy(s)
                          :(t.pan
                            &&
                            this._rawPanBy(s),
                            this.fire("move"),
                            t.debounceMoveend
                             ?(clearTimeout(this._sizeTimer),
                               this._sizeTimer
                               =
                               setTimeout(p(this.fire,this,"moveend"),200))
                             :this.fire("moveend")),
                         this.fire("resize",{oldSize:i,newSize:e}))
                       :this},
             stop:
             function()
              {return this.setZoom(this._limitZoom(this._zoom)),
                      this.options.zoomSnap
                      ||
                      this.fire("viewreset"),
                      this._stop()},
             locate:
             function(t)
              {if
                (t
                 =
                 this._locateOptions
                 =
                 h({timeout:1e4,watch:! 1},t),
                 !
                 ("geolocation" in navigator))
                return this._handleGeolocationError
                        ({code:0,message:"Geolocation not supported."}),
                       this;
               var
                i=p(this._handleGeolocationResponse,this),
                e=p(this._handleGeolocationError,this);
               return t.watch
                       ?this._locationWatchId
                        =
                        navigator.geolocation.watchPosition(i,e,t)
                       :navigator.geolocation.getCurrentPosition(i,e,t),
                      this},
             stopLocate:
             function()
              {return navigator.geolocation
                      &&
                      navigator.geolocation.clearWatch
                      &&
                      navigator.geolocation.clearWatch(this._locationWatchId),
                      this._locateOptions
                      &&
                      (this._locateOptions.setView = ! 1),
                      this},
             _handleGeolocationError:
             function(t)
              {var
                i=t.code,
                e=
                 t.message
                 ||
                 (1 === i
                   ?"permission denied"
                   :2 === i?"position unavailable":"timeout");
               this._locateOptions.setView
               &&
               !
               this._loaded
               &&
               this.fitWorld(),
               this.fire
                ("locationerror",
                 {code:i,message:"Geolocation error: " + e + "."})},
             _handleGeolocationResponse:
             function(t)
              {var
                i,
                e=new D(t.coords.latitude,t.coords.longitude),
                n=e.toBounds(2 * t.coords.accuracy),
                o=this._locateOptions;
               o.setView
               &&
               (i
                =
                this.getBoundsZoom(n),
                this.setView(e,o.maxZoom?Math.min(i,o.maxZoom):i));
               var s={latlng:e,bounds:n,timestamp:t.timestamp};
               for(var r in t.coords)
                "number" == typeof t.coords[r] && (s[r] = t.coords[r]);
               this.fire("locationfound",s)},
             addHandler:
             function(t,i)
              {if(! i)return this;
               var e=this[t] = new i(this);
               return this._handlers.push(e),
                      this.options[t]
                      &&
                      e.enable(),
                      this},
             remove:
             function()
              {if
                (this._initEvents(! 0),
                 this.off("moveend",this._panInsideMaxBounds),
                 this._containerId
                 !==
                 this._container._leaflet_id)
                throw new
                       Error
                       ("Map container is being reused by another instance");
               try
                {delete this._container._leaflet_id,delete this._containerId}
               catch(t)
                {this._container._leaflet_id
                 =
                 void 0,
                 this._containerId
                 =
                 void 0}
               var t;
               for
                (t
                 in
                 
                 void 0
                 !==
                 this._locationWatchId
                 &&
                 this.stopLocate(),
                 this._stop(),
                 ri(this._mapPane),
                 this._clearControlPos
                 &&
                 this._clearControlPos(),
                 this._resizeRequest
                 &&
                 (z(this._resizeRequest),this._resizeRequest = null),
                 this._clearHandlers(),
                 this._loaded
                 &&
                 this.fire("unload"),
                 this._layers)
                this._layers[t].remove();
               for(t in this._panes)ri(this._panes[t]);
               return this._layers
                      =
                      [],
                      this._panes
                      =
                      [],
                      delete this._mapPane,
                      delete this._renderer,
                      this},
             createPane:
             function(t,i)
              {var
                e=
                 si
                  ("div",
                   "leaflet-pane"
                   +
                   (t?" leaflet-" + t.replace("Pane","") + "-pane":""),
                   i || this._mapPane);
               return t && (this._panes[t] = e),e},
             getCenter:
             function()
              {return this._checkIfLoaded(),
                      this._lastCenter && ! this._moved()
                       ?this._lastCenter
                       :this.layerPointToLatLng(this._getCenterLayerPoint())},
             getZoom:function(){return this._zoom},
             getBounds:
             function()
              {var t=this.getPixelBounds();
               return new
                       R
                       (this.unproject(t.getBottomLeft()),
                        this.unproject(t.getTopRight()))},
             getMinZoom:
             function()
              {return void 0 === this.options.minZoom
                       ?this._layersMinZoom || 0
                       :this.options.minZoom},
             getMaxZoom:
             function()
              {return void 0 === this.options.maxZoom
                       ?void 0 === this._layersMaxZoom?1 / 0:this._layersMaxZoom
                       :this.options.maxZoom},
             getBoundsZoom:
             function(t,i,e)
              {t = N(t),e = A(e || [0,0]);
               var
                n=this.getZoom() || 0,
                o=this.getMinZoom(),
                s=this.getMaxZoom(),
                r=t.getNorthWest(),
                a=t.getSouthEast(),
                h=this.getSize().subtract(e),
                u=O(this.project(a,n),this.project(r,n)).getSize(),
                l=vt?this.options.zoomSnap:1,
                c=h.x / u.x,
                _=h.y / u.y,
                d=i?Math.max(c,_):Math.min(c,_),
                n=this.getScaleZoom(d,n);
               return l
                      &&
                      (n
                       =
                       Math.round(n / (l / 100))
                       *
                       (l / 100),
                       n
                       =
                       i?Math.ceil(n / l) * l:Math.floor(n / l) * l),
                      Math.max(o,Math.min(s,n))},
             getSize:
             function()
              {return this._size
                      &&
                      !
                      this._sizeChanged
                      ||
                      (this._size
                       =
                       new
                        k
                        (this._container.clientWidth || 0,
                         this._container.clientHeight || 0),
                       this._sizeChanged
                       =
                       !
                       1),
                      this._size.clone()},
             getPixelBounds:
             function(t,i)
              {var e=this._getTopLeftPoint(t,i);
               return new I(e,e.add(this.getSize()))},
             getPixelOrigin:
             function(){return this._checkIfLoaded(),this._pixelOrigin},
             getPixelWorldBounds:
             function(t)
              {return this.options.crs.getProjectedBounds
                       (void 0 === t?this.getZoom():t)},
             getPane:function(t){return "string" == typeof t?this._panes[t]:t},
             getPanes:function(){return this._panes},
             getContainer:function(){return this._container},
             getZoomScale:
             function(t,i)
              {var e=this.options.crs;
               return i = void 0 === i?this._zoom:i,e.scale(t) / e.scale(i)},
             getScaleZoom:
             function(t,i)
              {var e=this.options.crs;
               i = void 0 === i?this._zoom:i;
               var n=e.zoom(t * e.scale(i));
               return isNaN(n)?1 / 0:n},
             project:
             function(t,i)
              {return i
                      =
                      void 0 === i?this._zoom:i,
                      this.options.crs.latLngToPoint(j(t),i)},
             unproject:
             function(t,i)
              {return i
                      =
                      void 0 === i?this._zoom:i,
                      this.options.crs.pointToLatLng(A(t),i)},
             layerPointToLatLng:
             function(t)
              {var i=A(t).add(this.getPixelOrigin());return this.unproject(i)},
             latLngToLayerPoint:
             function(t)
              {return this.project(j(t))._round()._subtract
                       (this.getPixelOrigin())},
             wrapLatLng:function(t){return this.options.crs.wrapLatLng(j(t))},
             wrapLatLngBounds:
             function(t){return this.options.crs.wrapLatLngBounds(N(t))},
             distance:
             function(t,i){return this.options.crs.distance(j(t),j(i))},
             containerPointToLayerPoint:
             function(t){return A(t).subtract(this._getMapPanePos())},
             layerPointToContainerPoint:
             function(t){return A(t).add(this._getMapPanePos())},
             containerPointToLatLng:
             function(t)
              {var i=this.containerPointToLayerPoint(A(t));
               return this.layerPointToLatLng(i)},
             latLngToContainerPoint:
             function(t)
              {return this.layerPointToContainerPoint
                       (this.latLngToLayerPoint(j(t)))},
             mouseEventToContainerPoint:
             function(t){return Di(t,this._container)},
             mouseEventToLayerPoint:
             function(t)
              {return this.containerPointToLayerPoint
                       (this.mouseEventToContainerPoint(t))},
             mouseEventToLatLng:
             function(t)
              {return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},
             _initContainer:
             function(t)
              {var i=this._container = ni(t);
               if(! i)throw new Error("Map container not found.");
               if(i._leaflet_id)
                throw new Error("Map container is already initialized.");
               zi(i,"scroll",this._onScroll,this),this._containerId = m(i)},
             _initLayout:
             function()
              {var t=this._container;
               this._fadeAnimated
               =
               this.options.fadeAnimation
               &&
               vt,
               ci
                (t,
                 "leaflet-container"
                 +
                 (bt?" leaflet-touch":"")
                 +
                 (zt?" leaflet-retina":"")
                 +
                 (it?" leaflet-oldie":"")
                 +
                 (ct?" leaflet-safari":"")
                 +
                 (this._fadeAnimated?" leaflet-fade-anim":""));
               var i=oi(t,"position");
               "absolute"
               !==
               i
               &&
               "relative"
               !==
               i
               &&
               "fixed"
               !==
               i
               &&
               (t.style.position = "relative"),
               this._initPanes(),
               this._initControlPos
               &&
               this._initControlPos()},
             _initPanes:
             function()
              {var t=this._panes = {};
               this._paneRenderers
               =
               {},
               this._mapPane
               =
               this.createPane("mapPane",this._container),
               vi(this._mapPane,new k(0,0)),
               this.createPane("tilePane"),
               this.createPane("shadowPane"),
               this.createPane("overlayPane"),
               this.createPane("markerPane"),
               this.createPane("tooltipPane"),
               this.createPane("popupPane"),
               this.options.markerZoomAnimation
               ||
               (ci(t.markerPane,"leaflet-zoom-hide"),
                ci(t.shadowPane,"leaflet-zoom-hide"))},
             _resetView:
             function(t,i)
              {vi(this._mapPane,new k(0,0));
               var e=! this._loaded;
               this._loaded
               =
               !
               0,
               i
               =
               this._limitZoom(i),
               this.fire("viewprereset");
               var n=this._zoom !== i;
               this._moveStart(n,! 1)._move(t,i)._moveEnd(n),
               this.fire("viewreset"),
               e
               &&
               this.fire("load")},
             _moveStart:
             function(t,i)
              {return t
                      &&
                      this.fire("zoomstart"),
                      i
                      ||
                      this.fire("movestart"),
                      this},
             _move:
             function(t,i,e)
              {void 0 === i && (i = this._zoom);
               var n=this._zoom !== i;
               return this._zoom
                      =
                      i,
                      this._lastCenter
                      =
                      t,
                      this._pixelOrigin
                      =
                      this._getNewPixelOrigin(t),
                      (n || e && e.pinch)
                      &&
                      this.fire("zoom",e),
                      this.fire("move",e)},
             _moveEnd:
             function(t)
              {return t && this.fire("zoomend"),this.fire("moveend")},
             _stop:
             function()
              {return z(this._flyToFrame),
                      this._panAnim
                      &&
                      this._panAnim.stop(),
                      this},
             _rawPanBy:
             function(t){vi(this._mapPane,this._getMapPanePos().subtract(t))},
             _getZoomSpan:
             function(){return this.getMaxZoom() - this.getMinZoom()},
             _panInsideMaxBounds:
             function()
              {this._enforcingBounds
               ||
               this.panInsideBounds(this.options.maxBounds)},
             _checkIfLoaded:
             function()
              {if(! this._loaded)
                throw new Error("Set map center and zoom first.")},
             _initEvents:
             function(t)
              {this._targets = {};
               var i=t?Si:zi;
               i
                ((this._targets[m(this._container)] = this)._container,
                 "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup",
                 this._handleDOMEvent,
                 this),
               this.options.trackResize
               &&
               i(window,"resize",this._onResize,this),
               vt
               &&
               this.options.transform3DLimit
               &&
               (t?this.off:this.on).call(this,"moveend",this._onMoveEnd)},
             _onResize:
             function()
              {z(this._resizeRequest),
               this._resizeRequest
               =
               M(function(){this.invalidateSize({debounceMoveend:! 0})},this)},
             _onScroll:
             function()
              {this._container.scrollTop = 0,this._container.scrollLeft = 0},
             _onMoveEnd:
             function()
              {var t=this._getMapPanePos();
               Math.max(Math.abs(t.x),Math.abs(t.y))
               >=
               this.options.transform3DLimit
               &&
               this._resetView(this.getCenter(),this.getZoom())},
             _findEventTargets:
             function(t,i)
              {for
                (var
                  e,
                  n=[],
                  o="mouseout" === i || "mouseover" === i,
                  s=t.target || t.srcElement,
                  r=! 1;
                 s;
                 )
                {if
                  ((e = this._targets[m(s)])
                   &&
                   ("click" === i || "preclick" === i)
                   &&
                   !
                   t._simulated
                   &&
                   this._draggableMoved(e))
                  {r = ! 0;break}
                 if(e && e.listens(i,! 0))
                  {if(o && ! Vi(s,t))break;if(n.push(e),o)break}
                 if(s === this._container)break;
                 s = s.parentNode}
               return n.length || r || o || ! Vi(s,t) || (n = [this]),n},
             _handleDOMEvent:
             function(t)
              {var i;
               this._loaded
               &&
               !
               Ui(t)
               &&
               ("mousedown"
                !==
                (i = t.type)
                &&
                "keypress"
                !==
                i
                &&
                "keyup"
                !==
                i
                &&
                "keydown"
                !==
                i
                ||
                Pi(t.target || t.srcElement),
                this._fireDOMEvent(t,i))},
             _mouseEvents:
             ["click","dblclick","mouseover","mouseout","contextmenu"],
             _fireDOMEvent:
             function(t,i,e)
              {var n;
               if
                ("click"
                 ===
                 t.type
                 &&
                 ((n = h({},t)).type
                  =
                  "preclick",
                  this._fireDOMEvent(n,n.type,e)),
                 !
                 t._stopped
                 &&
                 (e = (e || []).concat(this._findEventTargets(t,i))).length)
                {var o=e[0];
                 "contextmenu" === i && o.listens(i,! 0) && Ri(t);
                 var s,r={originalEvent:t};
                 "keypress"
                 !==
                 t.type
                 &&
                 "keydown"
                 !==
                 t.type
                 &&
                 "keyup"
                 !==
                 t.type
                 &&
                 (s
                  =
                  o.getLatLng
                  &&
                  (! o._radius || o._radius <= 10),
                  r.containerPoint
                  =
                  s
                   ?this.latLngToContainerPoint(o.getLatLng())
                   :this.mouseEventToContainerPoint(t),
                  r.layerPoint
                  =
                  this.containerPointToLayerPoint(r.containerPoint),
                  r.latlng
                  =
                  s?o.getLatLng():this.layerPointToLatLng(r.layerPoint));
                 for(var a=0;a < e.length;a++)
                  if
                   (e[a].fire(i,r,! 0),
                    r.originalEvent._stopped
                    ||
                    !
                    1
                    ===
                    e[a].options.bubblingMouseEvents
                    &&
                    -
                    1
                    !==
                    v(this._mouseEvents,i))
                   return}},
             _draggableMoved:
             function(t)
              {return (t = t.dragging && t.dragging.enabled()?t:this).dragging
                      &&
                      t.dragging.moved()
                      ||
                      this.boxZoom
                      &&
                      this.boxZoom.moved()},
             _clearHandlers:
             function()
              {for(var t=0,i=this._handlers.length;t < i;t++)
                this._handlers[t].disable()},
             whenReady:
             function(t,i)
              {return this._loaded
                       ?t.call(i || this,{target:this})
                       :this.on("load",t,i),
                      this},
             _getMapPanePos:function(){return yi(this._mapPane) || new k(0,0)},
             _moved:
             function()
              {var t=this._getMapPanePos();return t && ! t.equals([0,0])},
             _getTopLeftPoint:
             function(t,i)
              {return (t && void 0 !== i
                         ?this._getNewPixelOrigin(t,i)
                         :this.getPixelOrigin()).subtract
                       (this._getMapPanePos())},
             _getNewPixelOrigin:
             function(t,i)
              {var e=this.getSize()._divideBy(2);
               return this.project(t,i)._subtract(e)._add
                        (this._getMapPanePos())._round
                       ()},
             _latLngToNewLayerPoint:
             function(t,i,e)
              {var n=this._getNewPixelOrigin(e,i);
               return this.project(t,i)._subtract(n)},
             _latLngBoundsToNewLayerBounds:
             function(t,i,e)
              {var n=this._getNewPixelOrigin(e,i);
               return O
                       ([this.project(t.getSouthWest(),i)._subtract(n),
                         this.project(t.getNorthWest(),i)._subtract(n),
                         this.project(t.getSouthEast(),i)._subtract(n),
                         this.project(t.getNorthEast(),i)._subtract(n)])},
             _getCenterLayerPoint:
             function()
              {return this.containerPointToLayerPoint
                       (this.getSize()._divideBy(2))},
             _getCenterOffset:
             function(t)
              {return this.latLngToLayerPoint(t).subtract
                       (this._getCenterLayerPoint())},
             _limitCenter:
             function(t,i,e)
              {if(! e)return t;
               var
                n=this.project(t,i),
                o=this.getSize().divideBy(2),
                s=new I(n.subtract(o),n.add(o)),
                r=this._getBoundsOffset(s,e,i);
               return r.round().equals([0,0])?t:this.unproject(n.add(r),i)},
             _limitOffset:
             function(t,i)
              {if(! i)return t;
               var e=this.getPixelBounds(),n=new I(e.min.add(t),e.max.add(t));
               return t.add(this._getBoundsOffset(n,i))},
             _getBoundsOffset:
             function(t,i,e)
              {var
                n=
                 O
                  (this.project(i.getNorthEast(),e),
                   this.project(i.getSouthWest(),e)),
                o=n.min.subtract(t.min),
                s=n.max.subtract(t.max);
               return new k(this._rebound(o.x,- s.x),this._rebound(o.y,- s.y))},
             _rebound:
             function(t,i)
              {return 0 < t + i
                       ?Math.round(t - i) / 2
                       :Math.max(0,Math.ceil(t)) - Math.max(0,Math.floor(i))},
             _limitZoom:
             function(t)
              {var
                i=this.getMinZoom(),
                e=this.getMaxZoom(),
                n=vt?this.options.zoomSnap:1;
               return n
                      &&
                      (t = Math.round(t / n) * n),
                      Math.max(i,Math.min(e,t))},
             _onPanTransitionStep:function(){this.fire("move")},
             _onPanTransitionEnd:
             function()
              {_i(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},
             _tryAnimatedPan:
             function(t,i)
              {var e=this._getCenterOffset(t)._trunc();
               return !
                      (! 0 !== (i && i.animate) && ! this.getSize().contains(e))
                      &&
                      (this.panBy(e,i),! 0)},
             _createAnimProxy:
             function()
              {var
                t=
                 this._proxy
                 =
                 si("div","leaflet-proxy leaflet-zoom-animated");
               this._panes.mapPane.appendChild(t),
               this.on
                ("zoomanim",
                 function(t)
                  {var i=ti,e=this._proxy.style[i];
                   gi
                    (this._proxy,
                     this.project(t.center,t.zoom),
                     this.getZoomScale(t.zoom,1)),
                   e
                   ===
                   this._proxy.style[i]
                   &&
                   this._animatingZoom
                   &&
                   this._onZoomTransitionEnd()},
                 this),
               this.on("load moveend",this._animMoveEnd,this),
               this._on("unload",this._destroyAnimProxy,this)},
             _destroyAnimProxy:
             function()
              {ri(this._proxy),
               this.off("load moveend",this._animMoveEnd,this),
               delete this._proxy},
             _animMoveEnd:
             function()
              {var t=this.getCenter(),i=this.getZoom();
               gi(this._proxy,this.project(t,i),this.getZoomScale(i,1))},
             _catchTransitionEnd:
             function(t)
              {this._animatingZoom
               &&
               0
               <=
               t.propertyName.indexOf("transform")
               &&
               this._onZoomTransitionEnd()},
             _nothingToAnimate:
             function()
              {return !
                      this._container.getElementsByClassName
                       ("leaflet-zoom-animated").length},
             _tryAnimatedZoom:
             function(t,i,e)
              {if(this._animatingZoom)return ! 0;
               if
                (e
                 =
                 e
                 ||
                 {},
                 !
                 this._zoomAnimated
                 ||
                 !
                 1
                 ===
                 e.animate
                 ||
                 this._nothingToAnimate()
                 ||
                 Math.abs(i - this._zoom)
                 >
                 this.options.zoomAnimationThreshold)
                return ! 1;
               var
                n=this.getZoomScale(i),
                o=this._getCenterOffset(t)._divideBy(1 - 1 / n);
               return !
                      (! 0 !== e.animate && ! this.getSize().contains(o))
                      &&
                      (M
                        (function(){this._moveStart(! 0,! 1)._animateZoom(t,i,! 0)},
                         this),
                       !
                       0)},
             _animateZoom:
             function(t,i,e,n)
              {this._mapPane
               &&
               (e
                &&
                (this._animatingZoom
                 =
                 !
                 0,
                 this._animateToCenter
                 =
                 t,
                 this._animateToZoom
                 =
                 i,
                 ci(this._mapPane,"leaflet-zoom-anim")),
                this.fire("zoomanim",{center:t,zoom:i,noUpdate:n}),
                setTimeout(p(this._onZoomTransitionEnd,this),250))},
             _onZoomTransitionEnd:
             function()
              {this._animatingZoom
               &&
               (this._mapPane
                &&
                _i(this._mapPane,"leaflet-zoom-anim"),
                this._animatingZoom
                =
                !
                1,
                this._move(this._animateToCenter,this._animateToZoom),
                M(function(){this._moveEnd(! 0)},this))}});
        function Yi(t){return new Xi(t)}
        var
         Xi=
          S.extend
           ({options:{position:"topright"},
             initialize:function(t){c(this,t)},
             getPosition:function(){return this.options.position},
             setPosition:
             function(t)
              {var i=this._map;
               return i
                      &&
                      i.removeControl(this),
                      this.options.position
                      =
                      t,
                      i
                      &&
                      i.addControl(this),
                      this},
             getContainer:function(){return this._container},
             addTo:
             function(t)
              {this.remove(),this._map = t;
               var
                i=this._container = this.onAdd(t),
                e=this.getPosition(),
                n=t._controlCorners[e];
               return ci(i,"leaflet-control"),
                      - 1 !== e.indexOf("bottom")
                       ?n.insertBefore(i,n.firstChild)
                       :n.appendChild(i),
                      this._map.on("unload",this.remove,this),
                      this},
             remove:
             function()
              {return this._map
                      &&
                      (ri(this._container),
                       this.onRemove
                       &&
                       this.onRemove(this._map),
                       this._map.off("unload",this.remove,this),
                       this._map
                       =
                       null),
                      this},
             _refocusOnMap:
             function(t)
              {this._map
               &&
               t
               &&
               0
               <
               t.screenX
               &&
               0
               <
               t.screenY
               &&
               this._map.getContainer().focus()}});
        Ki.include
         ({addControl:function(t){return t.addTo(this),this},
           removeControl:function(t){return t.remove(),this},
           _initControlPos:
           function()
            {var
              n=this._controlCorners = {},
              o="leaflet-",
              s=
               this._controlContainer
               =
               si("div",o + "control-container",this._container);
             function t(t,i)
              {var e=o + t + " " + o + i;n[t + i] = si("div",e,s)}
             t("top","left"),
             t("top","right"),
             t("bottom","left"),
             t("bottom","right")},
           _clearControlPos:
           function()
            {for(var t in this._controlCorners)ri(this._controlCorners[t]);
             ri(this._controlContainer),
             delete this._controlCorners,
             delete this._controlContainer}});
        var
         Ji=
          Xi.extend
           ({options:
             {collapsed:! 0,
              position:"topright",
              autoZIndex:! 0,
              hideSingleBase:! 1,
              sortLayers:! 1,
              sortFunction:function(t,i,e,n){return e < n?- 1:n < e?1:0}},
             initialize:
             function(t,i,e)
              {for
                (var n
                 in
                 
                 c(this,e),
                 this._layerControlInputs
                 =
                 [],
                 this._layers
                 =
                 [],
                 this._lastZIndex
                 =
                 0,
                 this._handlingClick
                 =
                 !
                 1,
                 t)
                this._addLayer(t[n],n);
               for(n in i)this._addLayer(i[n],n,! 0)},
             onAdd:
             function(t)
              {this._initLayout(),
               this._update(),
               (this._map = t).on("zoomend",this._checkDisabledLayers,this);
               for(var i=0;i < this._layers.length;i++)
                this._layers[i].layer.on
                 ("add remove",this._onLayerChange,this);
               return this._container},
             addTo:
             function(t)
              {return Xi.prototype.addTo.call(this,t),
                      this._expandIfNotCollapsed()},
             onRemove:
             function()
              {this._map.off("zoomend",this._checkDisabledLayers,this);
               for(var t=0;t < this._layers.length;t++)
                this._layers[t].layer.off
                 ("add remove",this._onLayerChange,this)},
             addBaseLayer:
             function(t,i)
              {return this._addLayer(t,i),this._map?this._update():this},
             addOverlay:
             function(t,i)
              {return this._addLayer(t,i,! 0),this._map?this._update():this},
             removeLayer:
             function(t)
              {t.off("add remove",this._onLayerChange,this);
               var i=this._getLayer(m(t));
               return i
                      &&
                      this._layers.splice(this._layers.indexOf(i),1),
                      this._map?this._update():this},
             expand:
             function()
              {ci(this._container,"leaflet-control-layers-expanded"),
               this._section.style.height
               =
               null;
               var t=this._map.getSize().y - (this._container.offsetTop + 50);
               return t < this._section.clientHeight
                       ?(ci(this._section,"leaflet-control-layers-scrollbar"),
                         this._section.style.height
                         =
                         t
                         +
                         "px")
                       :_i(this._section,"leaflet-control-layers-scrollbar"),
                      this._checkDisabledLayers(),
                      this},
             collapse:
             function()
              {return _i(this._container,"leaflet-control-layers-expanded"),
                      this},
             _initLayout:
             function()
              {var
                t="leaflet-control-layers",
                i=this._container = si("div",t),
                e=this.options.collapsed;
               i.setAttribute("aria-haspopup",! 0),Oi(i),Ii(i);
               var n=this._section = si("section",t + "-list");
               e
               &&
               (this._map.on("click",this.collapse,this),
                ot
                ||
                zi(i,{mouseenter:this.expand,mouseleave:this.collapse},this));
               var o=this._layersLink = si("a",t + "-toggle",i);
               o.href
               =
               "#",
               o.title
               =
               "Layers",
               bt
                ?(zi(o,"click",Ni),zi(o,"click",this.expand,this))
                :zi(o,"focus",this.expand,this),
               e
               ||
               this.expand(),
               this._baseLayersList
               =
               si("div",t + "-base",n),
               this._separator
               =
               si("div",t + "-separator",n),
               this._overlaysList
               =
               si("div",t + "-overlays",n),
               i.appendChild(n)},
             _getLayer:
             function(t)
              {for(var i=0;i < this._layers.length;i++)
                if(this._layers[i] && m(this._layers[i].layer) === t)
                 return this._layers[i]},
             _addLayer:
             function(t,i,e)
              {this._map
               &&
               t.on("add remove",this._onLayerChange,this),
               this._layers.push({layer:t,name:i,overlay:e}),
               this.options.sortLayers
               &&
               this._layers.sort
                (p
                  (function(t,i)
                    {return this.options.sortFunction
                             (t.layer,i.layer,t.name,i.name)},
                   this)),
               this.options.autoZIndex
               &&
               t.setZIndex
               &&
               (this._lastZIndex++,t.setZIndex(this._lastZIndex)),
               this._expandIfNotCollapsed()},
             _update:
             function()
              {if(! this._container)return this;
               ai(this._baseLayersList),
               ai(this._overlaysList),
               this._layerControlInputs
               =
               [];
               for(var t,i,e,n=0,o=0;o < this._layers.length;o++)
                e
                =
                this._layers[o],
                this._addItem(e),
                i
                =
                i
                ||
                e.overlay,
                t
                =
                t
                ||
                !
                e.overlay,
                n
                +=
                e.overlay?0:1;
               return this.options.hideSingleBase
                      &&
                      (t
                       =
                       t
                       &&
                       1
                       <
                       n,
                       this._baseLayersList.style.display
                       =
                       t?"":"none"),
                      this._separator.style.display
                      =
                      i && t?"":"none",
                      this},
             _onLayerChange:
             function(t)
              {this._handlingClick || this._update();
               var
                i=this._getLayer(m(t.target)),
                e=
                 i.overlay
                  ?"add" === t.type?"overlayadd":"overlayremove"
                  :"add" === t.type?"baselayerchange":null;
               e && this._map.fire(e,i)},
             _createRadioElement:
             function(t,i)
              {var
                e=
                 '<input type="radio" class="leaflet-control-layers-selector" name="'
                 +
                 t
                 +
                 '"'
                 +
                 (i?' checked="checked"':"")
                 +
                 "/>",
                n=document.createElement("div");
               return n.innerHTML = e,n.firstChild},
             _addItem:
             function(t)
              {var
                i,
                e=document.createElement("label"),
                n=this._map.hasLayer(t.layer);
               t.overlay
                ?((i = document.createElement("input")).type
                  =
                  "checkbox",
                  i.className
                  =
                  "leaflet-control-layers-selector",
                  i.defaultChecked
                  =
                  n)
                :i
                 =
                 this._createRadioElement("leaflet-base-layers_" + m(this),n),
               this._layerControlInputs.push(i),
               i.layerId
               =
               m(t.layer),
               zi(i,"click",this._onInputClick,this);
               var o=document.createElement("span");
               o.innerHTML = " " + t.name;
               var s=document.createElement("div");
               return e.appendChild(s),
                      s.appendChild(i),
                      s.appendChild(o),
                      (t.overlay?this._overlaysList:this._baseLayersList).appendChild
                       (e),
                      this._checkDisabledLayers(),
                      e},
             _onInputClick:
             function()
              {var t,i,e=this._layerControlInputs,n=[],o=[];
               this._handlingClick = ! 0;
               for(var s=e.length - 1;0 <= s;s--)
                t
                =
                e[s],
                i
                =
                this._getLayer(t.layerId).layer,
                t.checked?n.push(i):t.checked || o.push(i);
               for(s = 0;s < o.length;s++)
                this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]);
               for(s = 0;s < n.length;s++)
                this._map.hasLayer(n[s]) || this._map.addLayer(n[s]);
               this._handlingClick = ! 1,this._refocusOnMap()},
             _checkDisabledLayers:
             function()
              {for
                (var
                  t,
                  i,
                  e=this._layerControlInputs,
                  n=this._map.getZoom(),
                  o=e.length - 1;
                 0
                 <=
                 o;
                 o--)
                t
                =
                e[o],
                i
                =
                this._getLayer(t.layerId).layer,
                t.disabled
                =
                void 0
                !==
                i.options.minZoom
                &&
                n
                <
                i.options.minZoom
                ||
                void 0
                !==
                i.options.maxZoom
                &&
                n
                >
                i.options.maxZoom},
             _expandIfNotCollapsed:
             function()
              {return this._map
                      &&
                      !
                      this.options.collapsed
                      &&
                      this.expand(),
                      this},
             _expand:function(){return this.expand()},
             _collapse:function(){return this.collapse()}}),
         $i=
          Xi.extend
           ({options:
             {position:"topleft",
              zoomInText:"+",
              zoomInTitle:"Zoom in",
              zoomOutText:"&#x2212;",
              zoomOutTitle:"Zoom out"},
             onAdd:
             function(t)
              {var
                i="leaflet-control-zoom",
                e=si("div",i + " leaflet-bar"),
                n=this.options;
               return this._zoomInButton
                      =
                      this._createButton
                       (n.zoomInText,n.zoomInTitle,i + "-in",e,this._zoomIn),
                      this._zoomOutButton
                      =
                      this._createButton
                       (n.zoomOutText,n.zoomOutTitle,i + "-out",e,this._zoomOut),
                      this._updateDisabled(),
                      t.on("zoomend zoomlevelschange",this._updateDisabled,this),
                      e},
             onRemove:
             function(t)
              {t.off("zoomend zoomlevelschange",this._updateDisabled,this)},
             disable:
             function()
              {return this._disabled = ! 0,this._updateDisabled(),this},
             enable:
             function()
              {return this._disabled = ! 1,this._updateDisabled(),this},
             _zoomIn:
             function(t)
              {!
               this._disabled
               &&
               this._map._zoom
               <
               this._map.getMaxZoom()
               &&
               this._map.zoomIn
                (this._map.options.zoomDelta * (t.shiftKey?3:1))},
             _zoomOut:
             function(t)
              {!
               this._disabled
               &&
               this._map._zoom
               >
               this._map.getMinZoom()
               &&
               this._map.zoomOut
                (this._map.options.zoomDelta * (t.shiftKey?3:1))},
             _createButton:
             function(t,i,e,n,o)
              {var s=si("a",e,n);
               return s.innerHTML
                      =
                      t,
                      s.href
                      =
                      "#",
                      s.title
                      =
                      i,
                      s.setAttribute("role","button"),
                      s.setAttribute("aria-label",i),
                      Oi(s),
                      zi(s,"click",Ni),
                      zi(s,"click",o,this),
                      zi(s,"click",this._refocusOnMap,this),
                      s},
             _updateDisabled:
             function()
              {var t=this._map,i="leaflet-disabled";
               _i(this._zoomInButton,i),
               _i(this._zoomOutButton,i),
               !
               this._disabled
               &&
               t._zoom
               !==
               t.getMinZoom()
               ||
               ci(this._zoomOutButton,i),
               !
               this._disabled
               &&
               t._zoom
               !==
               t.getMaxZoom()
               ||
               ci(this._zoomInButton,i)}});
        Ki.mergeOptions({zoomControl:! 0}),
        Ki.addInitHook
         (function()
           {this.options.zoomControl
            &&
            (this.zoomControl = new $i(),this.addControl(this.zoomControl))});
        var
         Qi=
          Xi.extend
           ({options:
             {position:"bottomleft",maxWidth:100,metric:! 0,imperial:! 0},
             onAdd:
             function(t)
              {var i="leaflet-control-scale",e=si("div",i),n=this.options;
               return this._addScales(n,i + "-line",e),
                      t.on(n.updateWhenIdle?"moveend":"move",this._update,this),
                      t.whenReady(this._update,this),
                      e},
             onRemove:
             function(t)
              {t.off
                (this.options.updateWhenIdle?"moveend":"move",
                 this._update,
                 this)},
             _addScales:
             function(t,i,e)
              {t.metric
               &&
               (this._mScale = si("div",i,e)),
               t.imperial
               &&
               (this._iScale = si("div",i,e))},
             _update:
             function()
              {var
                t=this._map,
                i=t.getSize().y / 2,
                e=
                 t.distance
                  (t.containerPointToLatLng([0,i]),
                   t.containerPointToLatLng([this.options.maxWidth,i]));
               this._updateScales(e)},
             _updateScales:
             function(t)
              {this.options.metric
               &&
               t
               &&
               this._updateMetric(t),
               this.options.imperial
               &&
               t
               &&
               this._updateImperial(t)},
             _updateMetric:
             function(t)
              {var i=this._getRoundNum(t),e=i < 1e3?i + " m":i / 1e3 + " km";
               this._updateScale(this._mScale,e,i / t)},
             _updateImperial:
             function(t)
              {var i,e,n,o=3.2808399 * t;
               5280 < o
                ?(i
                  =
                  o
                  /
                  5280,
                  e
                  =
                  this._getRoundNum(i),
                  this._updateScale(this._iScale,e + " mi",e / i))
                :(n
                  =
                  this._getRoundNum(o),
                  this._updateScale(this._iScale,n + " ft",n / o))},
             _updateScale:
             function(t,i,e)
              {t.style.width
               =
               Math.round(this.options.maxWidth * e)
               +
               "px",
               t.innerHTML
               =
               i},
             _getRoundNum:
             function(t)
              {var i=Math.pow(10,(Math.floor(t) + "").length - 1),e=t / i;
               return i * (e = 10 <= e?10:5 <= e?5:3 <= e?3:2 <= e?2:1)}}),
         te=
          Xi.extend
           ({options:
             {position:"bottomright",
              prefix:
              '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet<\/a>'},
             initialize:function(t){c(this,t),this._attributions = {}},
             onAdd:
             function(t)
              {for
                (var i
                 in
                 
                 (t.attributionControl = this)._container
                 =
                 si("div","leaflet-control-attribution"),
                 Oi(this._container),
                 t._layers)
                t._layers[i].getAttribution
                &&
                this.addAttribution(t._layers[i].getAttribution());
               return this._update(),this._container},
             setPrefix:
             function(t){return this.options.prefix = t,this._update(),this},
             addAttribution:
             function(t)
              {return t
                      &&
                      (this._attributions[t]
                       ||
                       (this._attributions[t] = 0),
                       this._attributions[t]++,
                       this._update()),
                      this},
             removeAttribution:
             function(t)
              {return t
                      &&
                      this._attributions[t]
                      &&
                      (this._attributions[t]--,this._update()),
                      this},
             _update:
             function()
              {if(this._map)
                {var t=[];
                 for(var i in this._attributions)
                  this._attributions[i] && t.push(i);
                 var e=[];
                 this.options.prefix
                 &&
                 e.push(this.options.prefix),
                 t.length
                 &&
                 e.push(t.join(", ")),
                 this._container.innerHTML
                 =
                 e.join(" | ")}}});
        Ki.mergeOptions({attributionControl:! 0}),
        Ki.addInitHook
         (function(){this.options.attributionControl && new te().addTo(this)});
        Xi.Layers
        =
        Ji,
        Xi.Zoom
        =
        $i,
        Xi.Scale
        =
        Qi,
        Xi.Attribution
        =
        te,
        Yi.layers
        =
        function(t,i,e){return new Ji(t,i,e)},
        Yi.zoom
        =
        function(t){return new $i(t)},
        Yi.scale
        =
        function(t){return new Qi(t)},
        Yi.attribution
        =
        function(t){return new te(t)};
        var
         ie=
          S.extend
           ({initialize:function(t){this._map = t},
             enable:
             function()
              {return this._enabled
                      ||
                      (this._enabled = ! 0,this.addHooks()),
                      this},
             disable:
             function()
              {return this._enabled
                      &&
                      (this._enabled = ! 1,this.removeHooks()),
                      this},
             enabled:function(){return ! ! this._enabled}});
        ie.addTo = function(t,i){return t.addHandler(i,this),this};
        var
         ee,
         ne={Events:Z},
         oe=bt?"touchstart mousedown":"mousedown",
         se=
          {mousedown:"mouseup",
           touchstart:"touchend",
           pointerdown:"touchend",
           MSPointerDown:"touchend"},
         re=
          {mousedown:"mousemove",
           touchstart:"touchmove",
           pointerdown:"touchmove",
           MSPointerDown:"touchmove"},
         ae=
          E.extend
           ({options:{clickTolerance:3},
             initialize:
             function(t,i,e,n)
              {c(this,n),
               this._element
               =
               t,
               this._dragStartTarget
               =
               i
               ||
               t,
               this._preventOutline
               =
               e},
             enable:
             function()
              {this._enabled
               ||
               (zi(this._dragStartTarget,oe,this._onDown,this),
                this._enabled
                =
                !
                0)},
             disable:
             function()
              {this._enabled
               &&
               (ae._dragging
                ===
                this
                &&
                this.finishDrag(),
                Si(this._dragStartTarget,oe,this._onDown,this),
                this._enabled
                =
                !
                1,
                this._moved
                =
                !
                1)},
             _onDown:
             function(t)
              {var i,e;
               !
               t._simulated
               &&
               this._enabled
               &&
               (this._moved
                =
                !
                1,
                li(this._element,"leaflet-zoom-anim")
                ||
                ae._dragging
                ||
                t.shiftKey
                ||
                1
                !==
                t.which
                &&
                1
                !==
                t.button
                &&
                !
                t.touches
                ||
                ((ae._dragging = this)._preventOutline
                 &&
                 Pi(this._element),
                 xi(),
                 Xt(),
                 this._moving
                 ||
                 (this.fire("down"),
                  i
                  =
                  t.touches?t.touches[0]:t,
                  e
                  =
                  bi(this._element),
                  this._startPoint
                  =
                  new k(i.clientX,i.clientY),
                  this._parentScale
                  =
                  Ti(e),
                  zi(document,re[t.type],this._onMove,this),
                  zi(document,se[t.type],this._onUp,this))))},
             _onMove:
             function(t)
              {var i,e;
               !
               t._simulated
               &&
               this._enabled
               &&
               (t.touches && 1 < t.touches.length
                 ?this._moved = ! 0
                 :((e
                    =
                    new
                      k
                      ((i = t.touches && 1 === t.touches.length?t.touches[0]:t).clientX,
                       i.clientY)._subtract
                     (this._startPoint)).x
                   ||
                   e.y)
                  &&
                  (Math.abs(e.x)
                   +
                   Math.abs(e.y)
                   <
                   this.options.clickTolerance
                   ||
                   (e.x
                    /=
                    this._parentScale.x,
                    e.y
                    /=
                    this._parentScale.y,
                    Ri(t),
                    this._moved
                    ||
                    (this.fire("dragstart"),
                     this._moved
                     =
                     !
                     0,
                     this._startPos
                     =
                     yi(this._element).subtract(e),
                     ci(document.body,"leaflet-dragging"),
                     this._lastTarget
                     =
                     t.target
                     ||
                     t.srcElement,
                     window.SVGElementInstance
                     &&
                     this._lastTarget instanceof window.SVGElementInstance
                     &&
                     (this._lastTarget
                      =
                      this._lastTarget.correspondingUseElement),
                     ci(this._lastTarget,"leaflet-drag-target")),
                    this._newPos
                    =
                    this._startPos.add(e),
                    this._moving
                    =
                    !
                    0,
                    z(this._animRequest),
                    this._lastEvent
                    =
                    t,
                    this._animRequest
                    =
                    M(this._updatePosition,this,! 0))))},
             _updatePosition:
             function()
              {var t={originalEvent:this._lastEvent};
               this.fire("predrag",t),
               vi(this._element,this._newPos),
               this.fire("drag",t)},
             _onUp:
             function(t){! t._simulated && this._enabled && this.finishDrag()},
             finishDrag:
             function()
              {for
                (var t
                 in
                 
                 _i(document.body,"leaflet-dragging"),
                 this._lastTarget
                 &&
                 (_i(this._lastTarget,"leaflet-drag-target"),
                  this._lastTarget
                  =
                  null),
                 re)
                Si(document,re[t],this._onMove,this),
                Si(document,se[t],this._onUp,this);
               wi(),
               Jt(),
               this._moved
               &&
               this._moving
               &&
               (z(this._animRequest),
                this.fire
                 ("dragend",
                  {distance:this._newPos.distanceTo(this._startPos)})),
               this._moving
               =
               !
               1,
               ae._dragging
               =
               !
               1}});
        function he(t,i)
         {if(! i || ! t.length)return t.slice();
          var e=i * i;
          return t
                 =
                 function(t,i)
                   {var
                     e=t.length,
                     n=new (typeof Uint8Array != void 0 + ""?Uint8Array:Array)(e);
                    n[0]
                    =
                    n[e - 1]
                    =
                    1,
                    function t(i,e,n,o,s)
                      {var r,a,h,u=0;
                       for(a = o + 1;a <= s - 1;a++)
                        h = de(i[a],i[o],i[s],! 0),u < h && (r = a,u = h);
                       n < u && (e[r] = 1,t(i,e,n,o,r),t(i,e,n,r,s))}
                     (t,n,i,0,e - 1);
                    var o,s=[];
                    for(o = 0;o < e;o++)n[o] && s.push(t[o]);
                    return s}
                  (t
                   =
                   function(t,i)
                     {for(var e=[t[0]],n=1,o=0,s=t.length;n < s;n++)
                       (function(t,i)
                          {var e=i.x - t.x,n=i.y - t.y;return e * e + n * n}
                         (t[n],t[o])
                        >
                        i
                        &&
                        (e.push(t[n]),o = n));
                      o < s - 1 && e.push(t[s - 1]);
                      return e}
                    (t,e),
                   e)}
        function ue(t,i,e){return Math.sqrt(de(t,i,e,! 0))}
        function le(t,i,e,n,o)
         {var s,r,a,h=n?ee:_e(t,e),u=_e(i,e);
          for(ee = u;;)
           {if(! (h | u))return [t,i];
            if(h & u)return ! 1;
            a
            =
            _e(r = ce(t,i,s = h || u,e,o),e),
            s === h?(t = r,h = a):(i = r,u = a)}}
        function ce(t,i,e,n,o)
         {var s,r,a=i.x - t.x,h=i.y - t.y,u=n.min,l=n.max;
          return 8 & e
                  ?(s = t.x + a * (l.y - t.y) / h,r = l.y)
                  :4 & e
                    ?(s = t.x + a * (u.y - t.y) / h,r = u.y)
                    :2 & e
                      ?(s = l.x,r = t.y + h * (l.x - t.x) / a)
                      :1 & e && (s = u.x,r = t.y + h * (u.x - t.x) / a),
                 new k(s,r,o)}
        function _e(t,i)
         {var e=0;
          return t.x < i.min.x?e |= 1:t.x > i.max.x && (e |= 2),
                 t.y < i.min.y?e |= 4:t.y > i.max.y && (e |= 8),
                 e}
        function de(t,i,e,n)
         {var o,s=i.x,r=i.y,a=e.x - s,h=e.y - r,u=a * a + h * h;
          return 0
                 <
                 u
                 &&
                 (1 < (o = ((t.x - s) * a + (t.y - r) * h) / u)
                   ?(s = e.x,r = e.y)
                   :0 < o && (s += a * o,r += h * o)),
                 a
                 =
                 t.x
                 -
                 s,
                 h
                 =
                 t.y
                 -
                 r,
                 n?a * a + h * h:new k(s,r)}
        function pe(t)
         {return ! g(t[0]) || "object" != typeof t[0][0] && void 0 !== t[0][0]}
        function me(t)
         {return console.warn
                  ("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),
                 pe(t)}
        var
         fe=
          {simplify:he,
           pointToSegmentDistance:ue,
           closestPointOnSegment:function(t,i,e){return de(t,i,e)},
           clipSegment:le,
           _getEdgeIntersection:ce,
           _getBitCode:_e,
           _sqClosestPointOnSegment:de,
           isFlat:pe,
           _flat:me};
        function ge(t,i,e)
         {for(var n,o,s,r,a,h,u,l=[1,4,2,8],c=0,_=t.length;c < _;c++)
           t[c]._code = _e(t[c],i);
          for(s = 0;s < 4;s++)
           {for(h = l[s],n = [],c = 0,o = (_ = t.length) - 1;c < _;o = c++)
             r
             =
             t[c],
             a
             =
             t[o],
             r._code & h
              ?a._code & h || ((u = ce(a,r,h,i,e))._code = _e(u,i),n.push(u))
              :(a._code
                &
                h
                &&
                ((u = ce(a,r,h,i,e))._code = _e(u,i),n.push(u)),
                n.push(r));
            t = n}
          return t}
        var
         ve,
         ye={clipPolygon:ge},
         xe=
          {project:function(t){return new k(t.lng,t.lat)},
           unproject:function(t){return new D(t.y,t.x)},
           bounds:new I([- 180,- 90],[180,90])},
         we=
          {R:6378137,
           R_MINOR:6356752.314245179,
           bounds:
           new
            I
            ([- 20037508.34279,- 15496570.73972],
             [20037508.34279,18764656.23138]),
           project:
           function(t)
            {var
              i=Math.PI / 180,
              e=this.R,
              n=t.lat * i,
              o=this.R_MINOR / e,
              s=Math.sqrt(1 - o * o),
              r=s * Math.sin(n),
              a=
               Math.tan(Math.PI / 4 - n / 2)
               /
               Math.pow((1 - r) / (1 + r),s / 2),
              n=- (e * Math.log(Math.max(a,1e-10)));
             return new k(t.lng * i * e,n)},
           unproject:
           function(t)
            {for
              (var
                i,
                e=180 / Math.PI,
                n=this.R,
                o=this.R_MINOR / n,
                s=Math.sqrt(1 - o * o),
                r=Math.exp(- (t.y / n)),
                a=Math.PI / 2 - 2 * Math.atan(r),
                h=0,
                u=.1;
               h
               <
               15
               &&
               1e-7
               <
               Math.abs(u);
               h++)
              i
              =
              s
              *
              Math.sin(a),
              i
              =
              Math.pow((1 - i) / (1 + i),s / 2),
              a
              +=
              u
              =
              Math.PI
              /
              2
              -
              2
              *
              Math.atan(r * i)
              -
              a;
             return new D(a * e,t.x * e / n)}},
         Pe={LonLat:xe,Mercator:we,SphericalMercator:V},
         Le=
          h
           ({},
            F,
            {code:"EPSG:3395",
             projection:we,
             transformation:G(ve = .5 / (Math.PI * we.R),.5,- ve,.5)}),
         be=
          h
           ({},
            F,
            {code:"EPSG:4326",
             projection:xe,
             transformation:G(1 / 180,1,- (1 / 180),.5)}),
         Te=
          h
           ({},
            H,
            {projection:xe,
             transformation:G(1,0,- 1,0),
             scale:function(t){return Math.pow(2,t)},
             zoom:function(t){return Math.log(t) / Math.LN2},
             distance:
             function(t,i)
              {var e=i.lng - t.lng,n=i.lat - t.lat;
               return Math.sqrt(e * e + n * n)},
             infinite:! 0});
        H.Earth
        =
        F,
        H.EPSG3395
        =
        Le,
        H.EPSG3857
        =
        Y,
        H.EPSG900913
        =
        X,
        H.EPSG4326
        =
        be,
        H.Simple
        =
        Te;
        var
         Me=
          E.extend
           ({options:
             {pane:"overlayPane",attribution:null,bubblingMouseEvents:! 0},
             addTo:function(t){return t.addLayer(this),this},
             remove:
             function(){return this.removeFrom(this._map || this._mapToAdd)},
             removeFrom:function(t){return t && t.removeLayer(this),this},
             getPane:
             function(t)
              {return this._map.getPane
                       (t?this.options[t] || t:this.options.pane)},
             addInteractiveTarget:
             function(t){return this._map._targets[m(t)] = this},
             removeInteractiveTarget:
             function(t){return delete this._map._targets[m(t)],this},
             getAttribution:function(){return this.options.attribution},
             _layerAdd:
             function(t)
              {var i,e=t.target;
               e.hasLayer(this)
               &&
               (this._map
                =
                e,
                this._zoomAnimated
                =
                e._zoomAnimated,
                this.getEvents
                &&
                (i
                 =
                 this.getEvents(),
                 e.on(i,this),
                 this.once("remove",function(){e.off(i,this)},this)),
                this.onAdd(e),
                this.getAttribution
                &&
                e.attributionControl
                &&
                e.attributionControl.addAttribution(this.getAttribution()),
                this.fire("add"),
                e.fire("layeradd",{layer:this}))}});
        Ki.include
         ({addLayer:
           function(t)
            {if(! t._layerAdd)
              throw new Error("The provided object is not a Layer.");
             var i=m(t);
             return this._layers[i]
                    ||
                    ((this._layers[i] = t)._mapToAdd
                     =
                     this,
                     t.beforeAdd
                     &&
                     t.beforeAdd(this),
                     this.whenReady(t._layerAdd,t)),
                    this},
           removeLayer:
           function(t)
            {var i=m(t);
             return this._layers[i]
                    &&
                    (this._loaded
                     &&
                     t.onRemove(this),
                     t.getAttribution
                     &&
                     this.attributionControl
                     &&
                     this.attributionControl.removeAttribution
                      (t.getAttribution()),
                     delete this._layers[i],
                     this._loaded
                     &&
                     (this.fire("layerremove",{layer:t}),t.fire("remove")),
                     t._map
                     =
                     t._mapToAdd
                     =
                     null),
                    this},
           hasLayer:function(t){return ! ! t && m(t) in this._layers},
           eachLayer:
           function(t,i)
            {for(var e in this._layers)t.call(i,this._layers[e]);return this},
           _addLayers:
           function(t)
            {for(var i=0,e=(t = t?g(t)?t:[t]:[]).length;i < e;i++)
              this.addLayer(t[i])},
           _addZoomLimit:
           function(t)
            {!
             isNaN(t.options.maxZoom)
             &&
             isNaN(t.options.minZoom)
             ||
             (this._zoomBoundLayers[m(t)] = t,this._updateZoomLevels())},
           _removeZoomLimit:
           function(t)
            {var i=m(t);
             this._zoomBoundLayers[i]
             &&
             (delete this._zoomBoundLayers[i],this._updateZoomLevels())},
           _updateZoomLevels:
           function()
            {var t=1 / 0,i=- (1 / 0),e=this._getZoomSpan();
             for(var n in this._zoomBoundLayers)
              var
               o=this._zoomBoundLayers[n].options,
               t=void 0 === o.minZoom?t:Math.min(t,o.minZoom),
               i=void 0 === o.maxZoom?i:Math.max(i,o.maxZoom);
             this._layersMaxZoom
             =
             i === - (1 / 0)?void 0:i,
             this._layersMinZoom
             =
             t === 1 / 0?void 0:t,
             e
             !==
             this._getZoomSpan()
             &&
             this.fire("zoomlevelschange"),
             void 0
             ===
             this.options.maxZoom
             &&
             this._layersMaxZoom
             &&
             this.getZoom()
             >
             this._layersMaxZoom
             &&
             this.setZoom(this._layersMaxZoom),
             void 0
             ===
             this.options.minZoom
             &&
             this._layersMinZoom
             &&
             this.getZoom()
             <
             this._layersMinZoom
             &&
             this.setZoom(this._layersMinZoom)}});
        var
         ze=
          Me.extend
           ({initialize:
             function(t,i)
              {var e,n;
               if(c(this,i),this._layers = {},t)
                for(e = 0,n = t.length;e < n;e++)this.addLayer(t[e])},
             addLayer:
             function(t)
              {var i=this.getLayerId(t);
               return this._layers[i]
                      =
                      t,
                      this._map
                      &&
                      this._map.addLayer(t),
                      this},
             removeLayer:
             function(t)
              {var i=t in this._layers?t:this.getLayerId(t);
               return this._map
                      &&
                      this._layers[i]
                      &&
                      this._map.removeLayer(this._layers[i]),
                      delete this._layers[i],
                      this},
             hasLayer:
             function(t)
              {return !
                      !
                      t
                      &&
                      ("number" == typeof t?t:this.getLayerId(t)) in this._layers},
             clearLayers:
             function(){return this.eachLayer(this.removeLayer,this)},
             invoke:
             function(t)
              {var i,e,n=Array.prototype.slice.call(arguments,1);
               for(i in this._layers)
                (e = this._layers[i])[t] && e[t].apply(e,n);
               return this},
             onAdd:function(t){this.eachLayer(t.addLayer,t)},
             onRemove:function(t){this.eachLayer(t.removeLayer,t)},
             eachLayer:
             function(t,i)
              {for(var e in this._layers)t.call(i,this._layers[e]);
               return this},
             getLayer:function(t){return this._layers[t]},
             getLayers:function(){var t=[];return this.eachLayer(t.push,t),t},
             setZIndex:function(t){return this.invoke("setZIndex",t)},
             getLayerId:m}),
         Ce=
          ze.extend
           ({addLayer:
             function(t)
              {return this.hasLayer(t)
                       ?this
                       :(t.addEventParent(this),
                         ze.prototype.addLayer.call(this,t),
                         this.fire("layeradd",{layer:t}))},
             removeLayer:
             function(t)
              {return this.hasLayer(t)
                       ?(t in this._layers
                         &&
                         (t = this._layers[t]),
                         t.removeEventParent(this),
                         ze.prototype.removeLayer.call(this,t),
                         this.fire("layerremove",{layer:t}))
                       :this},
             setStyle:function(t){return this.invoke("setStyle",t)},
             bringToFront:function(){return this.invoke("bringToFront")},
             bringToBack:function(){return this.invoke("bringToBack")},
             getBounds:
             function()
              {var t=new R();
               for(var i in this._layers)
                {var e=this._layers[i];
                 t.extend(e.getBounds?e.getBounds():e.getLatLng())}
               return t}}),
         Se=
          S.extend
           ({options:{popupAnchor:[0,0],tooltipAnchor:[0,0]},
             initialize:function(t){c(this,t)},
             createIcon:function(t){return this._createIcon("icon",t)},
             createShadow:function(t){return this._createIcon("shadow",t)},
             _createIcon:
             function(t,i)
              {var e=this._getIconUrl(t);
               if(! e)
                {if("icon" === t)
                  throw new
                         Error
                         ("iconUrl not set in Icon options (see the docs).");
                 return null}
               var n=this._createImg(e,i && "IMG" === i.tagName?i:null);
               return this._setIconStyles(n,t),n},
             _setIconStyles:
             function(t,i)
              {var e=this.options,n=e[i + "Size"];
               "number" == typeof n && (n = [n,n]);
               var
                o=A(n),
                s=
                 A
                  ("shadow"
                   ===
                   i
                   &&
                   e.shadowAnchor
                   ||
                   e.iconAnchor
                   ||
                   o
                   &&
                   o.divideBy(2,! 0));
               t.className
               =
               "leaflet-marker-"
               +
               i
               +
               " "
               +
               (e.className || ""),
               s
               &&
               (t.style.marginLeft
                =
                -
                s.x
                +
                "px",
                t.style.marginTop
                =
                -
                s.y
                +
                "px"),
               o
               &&
               (t.style.width = o.x + "px",t.style.height = o.y + "px")},
             _createImg:
             function(t,i)
              {return (i = i || document.createElement("img")).src = t,i},
             _getIconUrl:
             function(t)
              {return zt
                      &&
                      this.options[t + "RetinaUrl"]
                      ||
                      this.options[t + "Url"]}}),
         Ze=
          Se.extend
           ({options:
             {iconUrl:"marker-icon.png",
              iconRetinaUrl:"marker-icon-2x.png",
              shadowUrl:"marker-shadow.png",
              iconSize:[25,41],
              iconAnchor:[12,41],
              popupAnchor:[1,- 34],
              tooltipAnchor:[16,- 28],
              shadowSize:[41,41]},
             _getIconUrl:
             function(t)
              {return Ze.imagePath
                      ||
                      (Ze.imagePath = this._detectIconPath()),
                      (this.options.imagePath || Ze.imagePath)
                      +
                      Se.prototype._getIconUrl.call(this,t)},
             _detectIconPath:
             function()
              {var
                t=si("div","leaflet-default-icon-path",document.body),
                i=oi(t,"background-image") || oi(t,"backgroundImage");
               return document.body.removeChild(t),
                      i
                      =
                      null === i || 0 !== i.indexOf("url")
                       ?""
                       :i.replace(/^url\(["']?/,"").replace
                         (/marker-icon\.png["']?\)$/,"")}}),
         Ee=
          ie.extend
           ({initialize:function(t){this._marker = t},
             addHooks:
             function()
              {var t=this._marker._icon;
               this._draggable
               ||
               (this._draggable = new ae(t,t,! 0)),
               this._draggable.on
                 ({dragstart:this._onDragStart,
                   predrag:this._onPreDrag,
                   drag:this._onDrag,
                   dragend:this._onDragEnd},
                  this).enable
                (),
               ci(t,"leaflet-marker-draggable")},
             removeHooks:
             function()
              {this._draggable.off
                 ({dragstart:this._onDragStart,
                   predrag:this._onPreDrag,
                   drag:this._onDrag,
                   dragend:this._onDragEnd},
                  this).disable
                (),
               this._marker._icon
               &&
               _i(this._marker._icon,"leaflet-marker-draggable")},
             moved:
             function(){return this._draggable && this._draggable._moved},
             _adjustPan:
             function(t)
              {var
                i,
                e=this._marker,
                n=e._map,
                o=this._marker.options.autoPanSpeed,
                s=this._marker.options.autoPanPadding,
                r=yi(e._icon),
                a=n.getPixelBounds(),
                h=n.getPixelOrigin(),
                u=O(a.min._subtract(h).add(s),a.max._subtract(h).subtract(s));
               u.contains(r)
               ||
               (i
                =
                A
                  ((Math.max(u.max.x,r.x) - u.max.x)
                   /
                   (a.max.x - u.max.x)
                   -
                   (Math.min(u.min.x,r.x) - u.min.x)
                   /
                   (a.min.x - u.min.x),
                   (Math.max(u.max.y,r.y) - u.max.y)
                   /
                   (a.max.y - u.max.y)
                   -
                   (Math.min(u.min.y,r.y) - u.min.y)
                   /
                   (a.min.y - u.min.y)).multiplyBy
                 (o),
                n.panBy(i,{animate:! 1}),
                this._draggable._newPos._add(i),
                this._draggable._startPos._add(i),
                vi(e._icon,this._draggable._newPos),
                this._onDrag(t),
                this._panRequest
                =
                M(this._adjustPan.bind(this,t)))},
             _onDragStart:
             function()
              {this._oldLatLng
               =
               this._marker.getLatLng(),
               this._marker.closePopup
               &&
               this._marker.closePopup(),
               this._marker.fire("movestart").fire("dragstart")},
             _onPreDrag:
             function(t)
              {this._marker.options.autoPan
               &&
               (z(this._panRequest),
                this._panRequest
                =
                M(this._adjustPan.bind(this,t)))},
             _onDrag:
             function(t)
              {var
                i=this._marker,
                e=i._shadow,
                n=yi(i._icon),
                o=i._map.layerPointToLatLng(n);
               e
               &&
               vi(e,n),
               i._latlng
               =
               o,
               t.latlng
               =
               o,
               t.oldLatLng
               =
               this._oldLatLng,
               i.fire("move",t).fire("drag",t)},
             _onDragEnd:
             function(t)
              {z(this._panRequest),
               delete this._oldLatLng,
               this._marker.fire("moveend").fire("dragend",t)}}),
         ke=
          Me.extend
           ({options:
             {icon:new Ze(),
              interactive:! 0,
              keyboard:! 0,
              title:"",
              alt:"",
              zIndexOffset:0,
              opacity:1,
              riseOnHover:! 1,
              riseOffset:250,
              pane:"markerPane",
              shadowPane:"shadowPane",
              bubblingMouseEvents:! 1,
              draggable:! 1,
              autoPan:! 1,
              autoPanPadding:[50,50],
              autoPanSpeed:10},
             initialize:function(t,i){c(this,i),this._latlng = j(t)},
             onAdd:
             function(t)
              {this._zoomAnimated
               =
               this._zoomAnimated
               &&
               t.options.markerZoomAnimation,
               this._zoomAnimated
               &&
               t.on("zoomanim",this._animateZoom,this),
               this._initIcon(),
               this.update()},
             onRemove:
             function(t)
              {this.dragging
               &&
               this.dragging.enabled()
               &&
               (this.options.draggable = ! 0,this.dragging.removeHooks()),
               delete this.dragging,
               this._zoomAnimated
               &&
               t.off("zoomanim",this._animateZoom,this),
               this._removeIcon(),
               this._removeShadow()},
             getEvents:
             function(){return {zoom:this.update,viewreset:this.update}},
             getLatLng:function(){return this._latlng},
             setLatLng:
             function(t)
              {var i=this._latlng;
               return this._latlng
                      =
                      j(t),
                      this.update(),
                      this.fire("move",{oldLatLng:i,latlng:this._latlng})},
             setZIndexOffset:
             function(t){return this.options.zIndexOffset = t,this.update()},
             getIcon:function(){return this.options.icon},
             setIcon:
             function(t)
              {return this.options.icon
                      =
                      t,
                      this._map
                      &&
                      (this._initIcon(),this.update()),
                      this._popup
                      &&
                      this.bindPopup(this._popup,this._popup.options),
                      this},
             getElement:function(){return this._icon},
             update:
             function()
              {var t;
               return this._icon
                      &&
                      this._map
                      &&
                      (t
                       =
                       this._map.latLngToLayerPoint(this._latlng).round(),
                       this._setPos(t)),
                      this},
             _initIcon:
             function()
              {var
                t=this.options,
                i="leaflet-zoom-" + (this._zoomAnimated?"animated":"hide"),
                e=t.icon.createIcon(this._icon),
                n=! 1;
               e
               !==
               this._icon
               &&
               (this._icon
                &&
                this._removeIcon(),
                n
                =
                !
                0,
                t.title
                &&
                (e.title = t.title),
                "IMG"
                ===
                e.tagName
                &&
                (e.alt = t.alt || "")),
               ci(e,i),
               t.keyboard
               &&
               (e.tabIndex = "0"),
               this._icon
               =
               e,
               t.riseOnHover
               &&
               this.on
                ({mouseover:this._bringToFront,mouseout:this._resetZIndex});
               var o=t.icon.createShadow(this._shadow),s=! 1;
               o
               !==
               this._shadow
               &&
               (this._removeShadow(),s = ! 0),
               o
               &&
               (ci(o,i),o.alt = ""),
               this._shadow
               =
               o,
               t.opacity
               <
               1
               &&
               this._updateOpacity(),
               n
               &&
               this.getPane().appendChild(this._icon),
               this._initInteraction(),
               o
               &&
               s
               &&
               this.getPane(t.shadowPane).appendChild(this._shadow)},
             _removeIcon:
             function()
              {this.options.riseOnHover
               &&
               this.off
                ({mouseover:this._bringToFront,mouseout:this._resetZIndex}),
               ri(this._icon),
               this.removeInteractiveTarget(this._icon),
               this._icon
               =
               null},
             _removeShadow:
             function(){this._shadow && ri(this._shadow),this._shadow = null},
             _setPos:
             function(t)
              {this._icon
               &&
               vi(this._icon,t),
               this._shadow
               &&
               vi(this._shadow,t),
               this._zIndex
               =
               t.y
               +
               this.options.zIndexOffset,
               this._resetZIndex()},
             _updateZIndex:
             function(t)
              {this._icon && (this._icon.style.zIndex = this._zIndex + t)},
             _animateZoom:
             function(t)
              {var
                i=
                 this._map._latLngToNewLayerPoint
                   (this._latlng,t.zoom,t.center).round
                  ();
               this._setPos(i)},
             _initInteraction:
             function()
              {var t;
               this.options.interactive
               &&
               (ci(this._icon,"leaflet-interactive"),
                this.addInteractiveTarget(this._icon),
                Ee
                &&
                (t
                 =
                 this.options.draggable,
                 this.dragging
                 &&
                 (t = this.dragging.enabled(),this.dragging.disable()),
                 this.dragging
                 =
                 new Ee(this),
                 t
                 &&
                 this.dragging.enable()))},
             setOpacity:
             function(t)
              {return this.options.opacity
                      =
                      t,
                      this._map
                      &&
                      this._updateOpacity(),
                      this},
             _updateOpacity:
             function()
              {var t=this.options.opacity;
               this._icon
               &&
               mi(this._icon,t),
               this._shadow
               &&
               mi(this._shadow,t)},
             _bringToFront:
             function(){this._updateZIndex(this.options.riseOffset)},
             _resetZIndex:function(){this._updateZIndex(0)},
             _getPopupAnchor:
             function(){return this.options.icon.options.popupAnchor},
             _getTooltipAnchor:
             function(){return this.options.icon.options.tooltipAnchor}}),
         Be=
          Me.extend
           ({options:
             {stroke:! 0,
              color:"#3388ff",
              weight:3,
              opacity:1,
              lineCap:"round",
              lineJoin:"round",
              dashArray:null,
              dashOffset:null,
              fill:! 1,
              fillColor:null,
              fillOpacity:.2,
              fillRule:"evenodd",
              interactive:! 0,
              bubblingMouseEvents:! 0},
             beforeAdd:function(t){this._renderer = t.getRenderer(this)},
             onAdd:
             function()
              {this._renderer._initPath(this),
               this._reset(),
               this._renderer._addPath(this)},
             onRemove:function(){this._renderer._removePath(this)},
             redraw:
             function()
              {return this._map && this._renderer._updatePath(this),this},
             setStyle:
             function(t)
              {return c(this,t),
                      this._renderer
                      &&
                      (this._renderer._updateStyle(this),
                       this.options.stroke
                       &&
                       t
                       &&
                       Object.prototype.hasOwnProperty.call(t,"weight")
                       &&
                       this._updateBounds()),
                      this},
             bringToFront:
             function()
              {return this._renderer
                      &&
                      this._renderer._bringToFront(this),
                      this},
             bringToBack:
             function()
              {return this._renderer && this._renderer._bringToBack(this),this},
             getElement:function(){return this._path},
             _reset:function(){this._project(),this._update()},
             _clickTolerance:
             function()
              {return (this.options.stroke?this.options.weight / 2:0)
                      +
                      this._renderer.options.tolerance}}),
         Ae=
          Be.extend
           ({options:{fill:! 0,radius:10},
             initialize:
             function(t,i)
              {c(this,i),
               this._latlng
               =
               j(t),
               this._radius
               =
               this.options.radius},
             setLatLng:
             function(t)
              {var i=this._latlng;
               return this._latlng
                      =
                      j(t),
                      this.redraw(),
                      this.fire("move",{oldLatLng:i,latlng:this._latlng})},
             getLatLng:function(){return this._latlng},
             setRadius:
             function(t)
              {return this.options.radius = this._radius = t,this.redraw()},
             getRadius:function(){return this._radius},
             setStyle:
             function(t)
              {var i=t && t.radius || this._radius;
               return Be.prototype.setStyle.call(this,t),
                      this.setRadius(i),
                      this},
             _project:
             function()
              {this._point
               =
               this._map.latLngToLayerPoint(this._latlng),
               this._updateBounds()},
             _updateBounds:
             function()
              {var
                t=this._radius,
                i=this._radiusY || t,
                e=this._clickTolerance(),
                n=[t + e,i + e];
               this._pxBounds
               =
               new I(this._point.subtract(n),this._point.add(n))},
             _update:function(){this._map && this._updatePath()},
             _updatePath:function(){this._renderer._updateCircle(this)},
             _empty:
             function()
              {return this._radius
                      &&
                      !
                      this._renderer._bounds.intersects(this._pxBounds)},
             _containsPoint:
             function(t)
              {return t.distanceTo(this._point)
                      <=
                      this._radius
                      +
                      this._clickTolerance()}}),
         Ie=
          Ae.extend
           ({initialize:
             function(t,i,e)
              {if
                ("number"
                 ==
                 typeof i
                 &&
                 (i = h({},e,{radius:i})),
                 c(this,i),
                 this._latlng
                 =
                 j(t),
                 isNaN(this.options.radius))
                throw new Error("Circle radius cannot be NaN");
               this._mRadius = this.options.radius},
             setRadius:function(t){return this._mRadius = t,this.redraw()},
             getRadius:function(){return this._mRadius},
             getBounds:
             function()
              {var t=[this._radius,this._radiusY || this._radius];
               return new
                       R
                       (this._map.layerPointToLatLng(this._point.subtract(t)),
                        this._map.layerPointToLatLng(this._point.add(t)))},
             setStyle:Be.prototype.setStyle,
             _project:
             function()
              {var
                t,
                i,
                e,
                n,
                o,
                s,
                r,
                a,
                h=this._latlng.lng,
                u=this._latlng.lat,
                l=this._map,
                c=l.options.crs;
               c.distance === F.distance
                ?(t
                  =
                  Math.PI
                  /
                  180,
                  i
                  =
                  this._mRadius
                  /
                  F.R
                  /
                  t,
                  e
                  =
                  l.project([u + i,h]),
                  n
                  =
                  l.project([u - i,h]),
                  o
                  =
                  e.add(n).divideBy(2),
                  s
                  =
                  l.unproject(o).lat,
                  r
                  =
                  Math.acos
                   ((Math.cos(i * t) - Math.sin(u * t) * Math.sin(s * t))
                    /
                    (Math.cos(u * t) * Math.cos(s * t)))
                  /
                  t,
                  !
                  isNaN(r)
                  &&
                  0
                  !==
                  r
                  ||
                  (r = i / Math.cos(Math.PI / 180 * u)),
                  this._point
                  =
                  o.subtract(l.getPixelOrigin()),
                  this._radius
                  =
                  isNaN(r)?0:o.x - l.project([s,h - r]).x,
                  this._radiusY
                  =
                  o.y
                  -
                  e.y)
                :(a
                  =
                  c.unproject
                   (c.project(this._latlng).subtract([this._mRadius,0])),
                  this._point
                  =
                  l.latLngToLayerPoint(this._latlng),
                  this._radius
                  =
                  this._point.x
                  -
                  l.latLngToLayerPoint(a).x),
               this._updateBounds()}}),
         Oe=
          Be.extend
           ({options:{smoothFactor:1,noClip:! 1},
             initialize:function(t,i){c(this,i),this._setLatLngs(t)},
             getLatLngs:function(){return this._latlngs},
             setLatLngs:function(t){return this._setLatLngs(t),this.redraw()},
             isEmpty:function(){return ! this._latlngs.length},
             closestLayerPoint:
             function(t)
              {for
                (var i,e,n=1 / 0,o=null,s=de,r=0,a=this._parts.length;
                 r
                 <
                 a;
                 r++)
                for(var h=this._parts[r],u=1,l=h.length;u < l;u++)
                 {var c=s(t,i = h[u - 1],e = h[u],! 0);
                  c < n && (n = c,o = s(t,i,e))}
               return o && (o.distance = Math.sqrt(n)),o},
             getCenter:
             function()
              {if(! this._map)
                throw new
                       Error
                       ("Must add layer to map before using getCenter()");
               var t,i,e,n,o,s,r,a=this._rings[0],h=a.length;
               if(! h)return null;
               for(i = t = 0;t < h - 1;t++)i += a[t].distanceTo(a[t + 1]) / 2;
               if(0 === i)return this._map.layerPointToLatLng(a[0]);
               for(n = t = 0;t < h - 1;t++)
                if(o = a[t],s = a[t + 1],i < (n += e = o.distanceTo(s)))
                 return r
                        =
                        (n - i)
                        /
                        e,
                        this._map.layerPointToLatLng
                         ([s.x - r * (s.x - o.x),s.y - r * (s.y - o.y)])},
             getBounds:function(){return this._bounds},
             addLatLng:
             function(t,i)
              {return i
                      =
                      i
                      ||
                      this._defaultShape(),
                      t
                      =
                      j(t),
                      i.push(t),
                      this._bounds.extend(t),
                      this.redraw()},
             _setLatLngs:
             function(t)
              {this._bounds = new R(),this._latlngs = this._convertLatLngs(t)},
             _defaultShape:
             function()
              {return pe(this._latlngs)?this._latlngs:this._latlngs[0]},
             _convertLatLngs:
             function(t)
              {for(var i=[],e=pe(t),n=0,o=t.length;n < o;n++)
                e
                 ?(i[n] = j(t[n]),this._bounds.extend(i[n]))
                 :i[n] = this._convertLatLngs(t[n]);
               return i},
             _project:
             function()
              {var t=new I();
               this._rings
               =
               [],
               this._projectLatlngs(this._latlngs,this._rings,t),
               this._bounds.isValid()
               &&
               t.isValid()
               &&
               (this._rawPxBounds = t,this._updateBounds())},
             _updateBounds:
             function()
              {var t=this._clickTolerance(),i=new k(t,t);
               this._pxBounds
               =
               new
                I
                ([this._rawPxBounds.min.subtract(i),
                  this._rawPxBounds.max.add(i)])},
             _projectLatlngs:
             function(t,i,e)
              {var n,o,s=t[0] instanceof D,r=t.length;
               if(s)
                {for(o = [],n = 0;n < r;n++)
                  o[n] = this._map.latLngToLayerPoint(t[n]),e.extend(o[n]);
                 i.push(o)}
               else
                for(n = 0;n < r;n++)this._projectLatlngs(t[n],i,e)},
             _clipPoints:
             function()
              {var t=this._renderer._bounds;
               if
                (this._parts
                 =
                 [],
                 this._pxBounds
                 &&
                 this._pxBounds.intersects(t))
                if(this.options.noClip)
                 this._parts = this._rings;
                else
                 for
                  (var i,e,n,o,s=this._parts,r=0,a=0,h=this._rings.length;
                   r
                   <
                   h;
                   r++)
                  for(i = 0,e = (o = this._rings[r]).length;i < e - 1;i++)
                   (n = le(o[i],o[i + 1],t,i,! 0))
                   &&
                   (s[a]
                    =
                    s[a]
                    ||
                    [],
                    s[a].push(n[0]),
                    n[1]
                    ===
                    o[i + 1]
                    &&
                    i
                    !==
                    e
                    -
                    2
                    ||
                    (s[a].push(n[1]),a++))},
             _simplifyPoints:
             function()
              {for
                (var t=this._parts,i=this.options.smoothFactor,e=0,n=t.length;
                 e
                 <
                 n;
                 e++)
                t[e] = he(t[e],i)},
             _update:
             function()
              {this._map
               &&
               (this._clipPoints(),this._simplifyPoints(),this._updatePath())},
             _updatePath:function(){this._renderer._updatePoly(this)},
             _containsPoint:
             function(t,i)
              {var e,n,o,s,r,a,h=this._clickTolerance();
               if(! this._pxBounds || ! this._pxBounds.contains(t))return ! 1;
               for(e = 0,s = this._parts.length;e < s;e++)
                for
                 (n
                  =
                  0,
                  o
                  =
                  (r = (a = this._parts[e]).length)
                  -
                  1;
                  n
                  <
                  r;
                  o
                  =
                  n++)
                 if((i || 0 !== n) && ue(t,a[o],a[n]) <= h)return ! 0;
               return ! 1}});
        Oe._flat = me;
        var
         Re=
          Oe.extend
           ({options:{fill:! 0},
             isEmpty:
             function()
              {return ! this._latlngs.length || ! this._latlngs[0].length},
             getCenter:
             function()
              {if(! this._map)
                throw new
                       Error
                       ("Must add layer to map before using getCenter()");
               var t,i,e,n,o,s,r,a,h,u=this._rings[0],l=u.length;
               if(! l)return null;
               for(t = s = r = a = 0,i = l - 1;t < l;i = t++)
                e
                =
                u[t],
                n
                =
                u[i],
                o
                =
                e.y
                *
                n.x
                -
                n.y
                *
                e.x,
                r
                +=
                (e.x + n.x)
                *
                o,
                a
                +=
                (e.y + n.y)
                *
                o,
                s
                +=
                3
                *
                o;
               return h
                      =
                      0 === s?u[0]:[r / s,a / s],
                      this._map.layerPointToLatLng(h)},
             _convertLatLngs:
             function(t)
              {var i=Oe.prototype._convertLatLngs.call(this,t),e=i.length;
               return 2
                      <=
                      e
                      &&
                      i[0] instanceof D
                      &&
                      i[0].equals(i[e - 1])
                      &&
                      i.pop(),
                      i},
             _setLatLngs:
             function(t)
              {Oe.prototype._setLatLngs.call(this,t),
               pe(this._latlngs)
               &&
               (this._latlngs = [this._latlngs])},
             _defaultShape:
             function()
              {return pe(this._latlngs[0])
                       ?this._latlngs[0]
                       :this._latlngs[0][0]},
             _clipPoints:
             function()
              {var
                t=this._renderer._bounds,
                i=this.options.weight,
                e=new k(i,i),
                t=new I(t.min.subtract(e),t.max.add(e));
               if
                (this._parts
                 =
                 [],
                 this._pxBounds
                 &&
                 this._pxBounds.intersects(t))
                if(this.options.noClip)
                 this._parts = this._rings;
                else
                 for(var n,o=0,s=this._rings.length;o < s;o++)
                  (n = ge(this._rings[o],t,! 0)).length && this._parts.push(n)},
             _updatePath:function(){this._renderer._updatePoly(this,! 0)},
             _containsPoint:
             function(t)
              {var i,e,n,o,s,r,a,h,u=! 1;
               if(! this._pxBounds || ! this._pxBounds.contains(t))return ! 1;
               for(o = 0,a = this._parts.length;o < a;o++)
                for
                 (s
                  =
                  0,
                  r
                  =
                  (h = (i = this._parts[o]).length)
                  -
                  1;
                  s
                  <
                  h;
                  r
                  =
                  s++)
                 e
                 =
                 i[s],
                 n
                 =
                 i[r],
                 e.y
                 >
                 t.y
                 !=
                 n.y
                 >
                 t.y
                 &&
                 t.x
                 <
                 (n.x - e.x)
                 *
                 (t.y - e.y)
                 /
                 (n.y - e.y)
                 +
                 e.x
                 &&
                 (u = ! u);
               return u || Oe.prototype._containsPoint.call(this,t,! 0)}}),
         Ne=
          Ce.extend
           ({initialize:
             function(t,i){c(this,i),this._layers = {},t && this.addData(t)},
             addData:
             function(t)
              {var i,e,n,o=g(t)?t:t.features;
               if(o)
                {for(i = 0,e = o.length;i < e;i++)
                  ((n = o[i]).geometries
                   ||
                   n.geometry
                   ||
                   n.features
                   ||
                   n.coordinates)
                  &&
                  this.addData(n);
                 return this}
               var s=this.options;
               if(s.filter && ! s.filter(t))return this;
               var r=De(t,s);
               return r
                       ?(r.feature
                         =
                         qe(t),
                         r.defaultOptions
                         =
                         r.options,
                         this.resetStyle(r),
                         s.onEachFeature
                         &&
                         s.onEachFeature(t,r),
                         this.addLayer(r))
                       :this},
             resetStyle:
             function(t)
              {return void 0 === t
                       ?this.eachLayer(this.resetStyle,this)
                       :(t.options
                         =
                         h({},t.defaultOptions),
                         this._setLayerStyle(t,this.options.style),
                         this)},
             setStyle:
             function(i)
              {return this.eachLayer
                       (function(t){this._setLayerStyle(t,i)},this)},
             _setLayerStyle:
             function(t,i)
              {t.setStyle
               &&
               ("function" == typeof i && (i = i(t.feature)),t.setStyle(i))}});
        function De(t,i)
         {var
           e,
           n,
           o,
           s,
           r="Feature" === t.type?t.geometry:t,
           a=r?r.coordinates:null,
           h=[],
           u=i && i.pointToLayer,
           l=i && i.coordsToLatLng || We;
          if(! a && ! r)return null;
          switch(r.type)
           {case "Point":return je(u,t,e = l(a),i);
            case "MultiPoint":
             for(o = 0,s = a.length;o < s;o++)e = l(a[o]),h.push(je(u,t,e,i));
             return new Ce(h);
            case "LineString":
            case "MultiLineString":
             return n = He(a,"LineString" === r.type?0:1,l),new Oe(n,i);
            case "Polygon":
            case "MultiPolygon":
             return n = He(a,"Polygon" === r.type?1:2,l),new Re(n,i);
            case "GeometryCollection":
             for(o = 0,s = r.geometries.length;o < s;o++)
              {var
                c=
                 De
                  ({geometry:r.geometries[o],
                    type:"Feature",
                    properties:t.properties},
                   i);
               c && h.push(c)}
             return new Ce(h);
            default:throw new Error("Invalid GeoJSON object.")}}
        function je(t,i,e,n)
         {return t?t(i,e):new ke(e,n && n.markersInheritOptions && n)}
        function We(t){return new D(t[1],t[0],t[2])}
        function He(t,i,e)
         {for(var n,o=[],s=0,r=t.length;s < r;s++)
           n = i?He(t[s],i - 1,e):(e || We)(t[s]),o.push(n);
          return o}
        function Fe(t,i)
         {return i
                 =
                 "number" == typeof i?i:6,
                 void 0 !== t.alt
                  ?[r(t.lng,i),r(t.lat,i),r(t.alt,i)]
                  :[r(t.lng,i),r(t.lat,i)]}
        function Ue(t,i,e,n)
         {for(var o=[],s=0,r=t.length;s < r;s++)
           o.push(i?Ue(t[s],i - 1,e,n):Fe(t[s],n));
          return ! i && e && o.push(o[0]),o}
        function Ve(t,i){return t.feature?h({},t.feature,{geometry:i}):qe(i)}
        function qe(t)
         {return "Feature" === t.type || "FeatureCollection" === t.type
                  ?t
                  :{type:"Feature",properties:{},geometry:t}}
        var
         Ge=
          {toGeoJSON:
           function(t)
            {return Ve(this,{type:"Point",coordinates:Fe(this.getLatLng(),t)})}};
        function Ke(t,i){return new Ne(t,i)}
        ke.include(Ge),
        Ie.include(Ge),
        Ae.include(Ge),
        Oe.include
         ({toGeoJSON:
           function(t)
            {var i=! pe(this._latlngs);
             return Ve
                     (this,
                      {type:(i?"Multi":"") + "LineString",
                       coordinates:Ue(this._latlngs,i?1:0,! 1,t)})}}),
        Re.include
         ({toGeoJSON:
           function(t)
            {var
              i=! pe(this._latlngs),
              e=i && ! pe(this._latlngs[0]),
              n=Ue(this._latlngs,e?2:i?1:0,! 0,t);
             return i
                    ||
                    (n = [n]),
                    Ve(this,{type:(e?"Multi":"") + "Polygon",coordinates:n})}}),
        ze.include
         ({toMultiPoint:
           function(i)
            {var e=[];
             return this.eachLayer
                     (function(t){e.push(t.toGeoJSON(i).geometry.coordinates)}),
                    Ve(this,{type:"MultiPoint",coordinates:e})},
           toGeoJSON:
           function(n)
            {var
              t=
               this.feature
               &&
               this.feature.geometry
               &&
               this.feature.geometry.type;
             if("MultiPoint" === t)return this.toMultiPoint(n);
             var o="GeometryCollection" === t,s=[];
             return this.eachLayer
                     (function(t)
                       {var i,e;
                        t.toGeoJSON
                        &&
                        (i
                         =
                         t.toGeoJSON(n),
                         o
                          ?s.push(i.geometry)
                          :"FeatureCollection" === (e = qe(i)).type
                            ?s.push.apply(s,e.features)
                            :s.push(e))}),
                    o
                     ?Ve(this,{geometries:s,type:"GeometryCollection"})
                     :{type:"FeatureCollection",features:s}}});
        var
         Ye=Ke,
         Xe=
          Me.extend
           ({options:
             {opacity:1,
              alt:"",
              interactive:! 1,
              crossOrigin:! 1,
              errorOverlayUrl:"",
              zIndex:1,
              className:""},
             initialize:
             function(t,i,e){this._url = t,this._bounds = N(i),c(this,e)},
             onAdd:
             function()
              {this._image
               ||
               (this._initImage(),
                this.options.opacity
                <
                1
                &&
                this._updateOpacity()),
               this.options.interactive
               &&
               (ci(this._image,"leaflet-interactive"),
                this.addInteractiveTarget(this._image)),
               this.getPane().appendChild(this._image),
               this._reset()},
             onRemove:
             function()
              {ri(this._image),
               this.options.interactive
               &&
               this.removeInteractiveTarget(this._image)},
             setOpacity:
             function(t)
              {return this.options.opacity
                      =
                      t,
                      this._image
                      &&
                      this._updateOpacity(),
                      this},
             setStyle:
             function(t){return t.opacity && this.setOpacity(t.opacity),this},
             bringToFront:function(){return this._map && hi(this._image),this},
             bringToBack:function(){return this._map && ui(this._image),this},
             setUrl:
             function(t)
              {return this._url = t,this._image && (this._image.src = t),this},
             setBounds:
             function(t)
              {return this._bounds = N(t),this._map && this._reset(),this},
             getEvents:
             function()
              {var t={zoom:this._reset,viewreset:this._reset};
               return this._zoomAnimated && (t.zoomanim = this._animateZoom),t},
             setZIndex:
             function(t)
              {return this.options.zIndex = t,this._updateZIndex(),this},
             getBounds:function(){return this._bounds},
             getElement:function(){return this._image},
             _initImage:
             function()
              {var
                t="IMG" === this._url.tagName,
                i=this._image = t?this._url:si("img");
               ci(i,"leaflet-image-layer"),
               this._zoomAnimated
               &&
               ci(i,"leaflet-zoom-animated"),
               this.options.className
               &&
               ci(i,this.options.className),
               i.onselectstart
               =
               a,
               i.onmousemove
               =
               a,
               i.onload
               =
               p(this.fire,this,"load"),
               i.onerror
               =
               p(this._overlayOnError,this,"error"),
               !
               this.options.crossOrigin
               &&
               ""
               !==
               this.options.crossOrigin
               ||
               (i.crossOrigin
                =
                ! 0 === this.options.crossOrigin?"":this.options.crossOrigin),
               this.options.zIndex
               &&
               this._updateZIndex(),
               t
                ?this._url = i.src
                :(i.src = this._url,i.alt = this.options.alt)},
             _animateZoom:
             function(t)
              {var
                i=this._map.getZoomScale(t.zoom),
                e=
                 this._map._latLngBoundsToNewLayerBounds
                  (this._bounds,t.zoom,t.center).min;
               gi(this._image,e,i)},
             _reset:
             function()
              {var
                t=this._image,
                i=
                 new
                  I
                  (this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
                   this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
                e=i.getSize();
               vi(t,i.min),
               t.style.width
               =
               e.x
               +
               "px",
               t.style.height
               =
               e.y
               +
               "px"},
             _updateOpacity:function(){mi(this._image,this.options.opacity)},
             _updateZIndex:
             function()
              {this._image
               &&
               void 0
               !==
               this.options.zIndex
               &&
               null
               !==
               this.options.zIndex
               &&
               (this._image.style.zIndex = this.options.zIndex)},
             _overlayOnError:
             function()
              {this.fire("error");
               var t=this.options.errorOverlayUrl;
               t && this._url !== t && (this._url = t,this._image.src = t)}}),
         Je=
          Xe.extend
           ({options:{autoplay:! 0,loop:! 0,keepAspectRatio:! 0,muted:! 1},
             _initImage:
             function()
              {var
                t="VIDEO" === this._url.tagName,
                i=this._image = t?this._url:si("video");
               if
                (ci(i,"leaflet-image-layer"),
                 this._zoomAnimated
                 &&
                 ci(i,"leaflet-zoom-animated"),
                 this.options.className
                 &&
                 ci(i,this.options.className),
                 i.onselectstart
                 =
                 a,
                 i.onmousemove
                 =
                 a,
                 i.onloadeddata
                 =
                 p(this.fire,this,"load"),
                 t)
                {for
                  (var e=i.getElementsByTagName("source"),n=[],o=0;
                   o
                   <
                   e.length;
                   o++)
                  n.push(e[o].src);
                 this._url = 0 < e.length?n:[i.src]}
               else
                {g(this._url)
                 ||
                 (this._url = [this._url]),
                 !
                 this.options.keepAspectRatio
                 &&
                 Object.prototype.hasOwnProperty.call(i.style,"objectFit")
                 &&
                 (i.style.objectFit = "fill"),
                 i.autoplay
                 =
                 !
                 !
                 this.options.autoplay,
                 i.loop
                 =
                 !
                 !
                 this.options.loop,
                 i.muted
                 =
                 !
                 !
                 this.options.muted;
                 for(var s=0;s < this._url.length;s++)
                  {var r=si("source");r.src = this._url[s],i.appendChild(r)}}}}),
         $e=
          Xe.extend
           ({_initImage:
             function()
              {var t=this._image = this._url;
               ci(t,"leaflet-image-layer"),
               this._zoomAnimated
               &&
               ci(t,"leaflet-zoom-animated"),
               this.options.className
               &&
               ci(t,this.options.className),
               t.onselectstart
               =
               a,
               t.onmousemove
               =
               a}}),
         Qe=
          Me.extend
           ({options:{offset:[0,7],className:"",pane:"popupPane"},
             initialize:function(t,i){c(this,t),this._source = i},
             onAdd:
             function(t)
              {this._zoomAnimated
               =
               t._zoomAnimated,
               this._container
               ||
               this._initLayout(),
               t._fadeAnimated
               &&
               mi(this._container,0),
               clearTimeout(this._removeTimeout),
               this.getPane().appendChild(this._container),
               this.update(),
               t._fadeAnimated
               &&
               mi(this._container,1),
               this.bringToFront()},
             onRemove:
             function(t)
              {t._fadeAnimated
                ?(mi(this._container,0),
                  this._removeTimeout
                  =
                  setTimeout(p(ri,void 0,this._container),200))
                :ri(this._container)},
             getLatLng:function(){return this._latlng},
             setLatLng:
             function(t)
              {return this._latlng
                      =
                      j(t),
                      this._map
                      &&
                      (this._updatePosition(),this._adjustPan()),
                      this},
             getContent:function(){return this._content},
             setContent:
             function(t){return this._content = t,this.update(),this},
             getElement:function(){return this._container},
             update:
             function()
              {this._map
               &&
               (this._container.style.visibility
                =
                "hidden",
                this._updateContent(),
                this._updateLayout(),
                this._updatePosition(),
                this._container.style.visibility
                =
                "",
                this._adjustPan())},
             getEvents:
             function()
              {var
                t=
                 {zoom:this._updatePosition,viewreset:this._updatePosition};
               return this._zoomAnimated && (t.zoomanim = this._animateZoom),t},
             isOpen:
             function(){return ! ! this._map && this._map.hasLayer(this)},
             bringToFront:
             function(){return this._map && hi(this._container),this},
             bringToBack:
             function(){return this._map && ui(this._container),this},
             _prepareOpen:
             function(t,i,e)
              {if(i instanceof Me || (e = i,i = t),i instanceof Ce)
                for(var n in t._layers){i = t._layers[n];break}
               if(! e)
                if(i.getCenter)
                 e = i.getCenter();
                else
                 {if(! i.getLatLng)
                   throw new Error("Unable to get source layer LatLng.");
                  e = i.getLatLng()}
               return this._source = i,this.update(),e},
             _updateContent:
             function()
              {if(this._content)
                {var
                  t=this._contentNode,
                  i=
                   "function" == typeof this._content
                    ?this._content(this._source || this)
                    :this._content;
                 if("string" == typeof i)
                  t.innerHTML = i;
                 else
                  {for(;t.hasChildNodes();)t.removeChild(t.firstChild);
                   t.appendChild(i)}
                 this.fire("contentupdate")}},
             _updatePosition:
             function()
              {var t,i,e,n,o;
               this._map
               &&
               (t
                =
                this._map.latLngToLayerPoint(this._latlng),
                i
                =
                A(this.options.offset),
                e
                =
                this._getAnchor(),
                this._zoomAnimated
                 ?vi(this._container,t.add(e))
                 :i = i.add(t).add(e),
                n
                =
                this._containerBottom
                =
                -
                i.y,
                o
                =
                this._containerLeft
                =
                -
                Math.round(this._containerWidth / 2)
                +
                i.x,
                this._container.style.bottom
                =
                n
                +
                "px",
                this._container.style.left
                =
                o
                +
                "px")},
             _getAnchor:function(){return [0,0]}}),
         tn=
          Qe.extend
           ({options:
             {maxWidth:300,
              minWidth:50,
              maxHeight:null,
              autoPan:! 0,
              autoPanPaddingTopLeft:null,
              autoPanPaddingBottomRight:null,
              autoPanPadding:[5,5],
              keepInView:! 1,
              closeButton:! 0,
              autoClose:! 0,
              closeOnEscapeKey:! 0,
              className:""},
             openOn:function(t){return t.openPopup(this),this},
             onAdd:
             function(t)
              {Qe.prototype.onAdd.call(this,t),
               t.fire("popupopen",{popup:this}),
               this._source
               &&
               (this._source.fire("popupopen",{popup:this},! 0),
                this._source instanceof Be
                ||
                this._source.on("preclick",Ai))},
             onRemove:
             function(t)
              {Qe.prototype.onRemove.call(this,t),
               t.fire("popupclose",{popup:this}),
               this._source
               &&
               (this._source.fire("popupclose",{popup:this},! 0),
                this._source instanceof Be
                ||
                this._source.off("preclick",Ai))},
             getEvents:
             function()
              {var t=Qe.prototype.getEvents.call(this);
               return (void 0 !== this.options.closeOnClick
                        ?this.options.closeOnClick
                        :this._map.options.closePopupOnClick)
                      &&
                      (t.preclick = this._close),
                      this.options.keepInView
                      &&
                      (t.moveend = this._adjustPan),
                      t},
             _close:function(){this._map && this._map.closePopup(this)},
             _initLayout:
             function()
              {var
                t,
                i="leaflet-popup",
                e=
                 this._container
                 =
                 si
                  ("div",
                   i
                   +
                   " "
                   +
                   (this.options.className || "")
                   +
                   " leaflet-zoom-animated"),
                n=this._wrapper = si("div",i + "-content-wrapper",e);
               this._contentNode
               =
               si("div",i + "-content",n),
               Oi(e),
               Ii(this._contentNode),
               zi(e,"contextmenu",Ai),
               this._tipContainer
               =
               si("div",i + "-tip-container",e),
               this._tip
               =
               si("div",i + "-tip",this._tipContainer),
               this.options.closeButton
               &&
               ((t = this._closeButton = si("a",i + "-close-button",e)).href
                =
                "#close",
                t.innerHTML
                =
                "&#215;",
                zi(t,"click",this._onCloseButtonClick,this))},
             _updateLayout:
             function()
              {var t=this._contentNode,i=t.style;
               i.width = "",i.whiteSpace = "nowrap";
               var e=t.offsetWidth,e=Math.min(e,this.options.maxWidth);
               e
               =
               Math.max(e,this.options.minWidth),
               i.width
               =
               e
               +
               1
               +
               "px",
               i.whiteSpace
               =
               "",
               i.height
               =
               "";
               var
                n=t.offsetHeight,
                o=this.options.maxHeight,
                s="leaflet-popup-scrolled";
               o && o < n?(i.height = o + "px",ci(t,s)):_i(t,s),
               this._containerWidth
               =
               this._container.offsetWidth},
             _animateZoom:
             function(t)
              {var
                i=
                 this._map._latLngToNewLayerPoint
                  (this._latlng,t.zoom,t.center),
                e=this._getAnchor();
               vi(this._container,i.add(e))},
             _adjustPan:
             function()
              {var t,i,e,n,o,s,r,a,h,u,l,c;
               this.options.autoPan
               &&
               (this._map._panAnim
                &&
                this._map._panAnim.stop(),
                t
                =
                this._map,
                i
                =
                parseInt(oi(this._container,"marginBottom"),10)
                ||
                0,
                e
                =
                this._container.offsetHeight
                +
                i,
                n
                =
                this._containerWidth,
                (o = new k(this._containerLeft,- e - this._containerBottom))._add
                 (yi(this._container)),
                s
                =
                t.layerPointToContainerPoint(o),
                r
                =
                A(this.options.autoPanPadding),
                a
                =
                A(this.options.autoPanPaddingTopLeft || r),
                h
                =
                A(this.options.autoPanPaddingBottomRight || r),
                u
                =
                t.getSize(),
                c
                =
                l
                =
                0,
                s.x
                +
                n
                +
                h.x
                >
                u.x
                &&
                (l = s.x + n - u.x + h.x),
                s.x
                -
                l
                -
                a.x
                <
                0
                &&
                (l = s.x - a.x),
                s.y
                +
                e
                +
                h.y
                >
                u.y
                &&
                (c = s.y + e - u.y + h.y),
                s.y
                -
                c
                -
                a.y
                <
                0
                &&
                (c = s.y - a.y),
                (l || c)
                &&
                t.fire("autopanstart").panBy([l,c]))},
             _onCloseButtonClick:function(t){this._close(),Ni(t)},
             _getAnchor:
             function()
              {return A
                       (this._source && this._source._getPopupAnchor
                         ?this._source._getPopupAnchor()
                         :[0,0])}});
        Ki.mergeOptions({closePopupOnClick:! 0}),
        Ki.include
         ({openPopup:
           function(t,i,e)
            {return t instanceof tn
                    ||
                    (t = new tn(e).setContent(t)),
                    i
                    &&
                    t.setLatLng(i),
                    this.hasLayer(t)
                     ?this
                     :(this._popup
                       &&
                       this._popup.options.autoClose
                       &&
                       this.closePopup(),
                       this._popup
                       =
                       t,
                       this.addLayer(t))},
           closePopup:
           function(t)
            {return t
                    &&
                    t
                    !==
                    this._popup
                    ||
                    (t = this._popup,this._popup = null),
                    t
                    &&
                    this.removeLayer(t),
                    this}}),
        Me.include
         ({bindPopup:
           function(t,i)
            {return t instanceof tn
                     ?(c(t,i),(this._popup = t)._source = this)
                     :(this._popup
                       &&
                       !
                       i
                       ||
                       (this._popup = new tn(i,this)),
                       this._popup.setContent(t)),
                    this._popupHandlersAdded
                    ||
                    (this.on
                      ({click:this._openPopup,
                        keypress:this._onKeyPress,
                        remove:this.closePopup,
                        move:this._movePopup}),
                     this._popupHandlersAdded
                     =
                     !
                     0),
                    this},
           unbindPopup:
           function()
            {return this._popup
                    &&
                    (this.off
                      ({click:this._openPopup,
                        keypress:this._onKeyPress,
                        remove:this.closePopup,
                        move:this._movePopup}),
                     this._popupHandlersAdded
                     =
                     !
                     1,
                     this._popup
                     =
                     null),
                    this},
           openPopup:
           function(t,i)
            {return this._popup
                    &&
                    this._map
                    &&
                    (i
                     =
                     this._popup._prepareOpen(this,t,i),
                     this._map.openPopup(this._popup,i)),
                    this},
           closePopup:
           function(){return this._popup && this._popup._close(),this},
           togglePopup:
           function(t)
            {return this._popup
                    &&
                    (this._popup._map?this.closePopup():this.openPopup(t)),
                    this},
           isPopupOpen:
           function(){return ! ! this._popup && this._popup.isOpen()},
           setPopupContent:
           function(t){return this._popup && this._popup.setContent(t),this},
           getPopup:function(){return this._popup},
           _openPopup:
           function(t)
            {var i=t.layer || t.target;
             this._popup
             &&
             this._map
             &&
             (Ni(t),
              i instanceof Be
               ?this.openPopup(t.layer || t.target,t.latlng)
               :this._map.hasLayer(this._popup) && this._popup._source === i
                 ?this.closePopup()
                 :this.openPopup(i,t.latlng))},
           _movePopup:function(t){this._popup.setLatLng(t.latlng)},
           _onKeyPress:
           function(t){13 === t.originalEvent.keyCode && this._openPopup(t)}});
        var
         en=
          Qe.extend
           ({options:
             {pane:"tooltipPane",
              offset:[0,0],
              direction:"auto",
              permanent:! 1,
              sticky:! 1,
              interactive:! 1,
              opacity:.9},
             onAdd:
             function(t)
              {Qe.prototype.onAdd.call(this,t),
               this.setOpacity(this.options.opacity),
               t.fire("tooltipopen",{tooltip:this}),
               this._source
               &&
               this._source.fire("tooltipopen",{tooltip:this},! 0)},
             onRemove:
             function(t)
              {Qe.prototype.onRemove.call(this,t),
               t.fire("tooltipclose",{tooltip:this}),
               this._source
               &&
               this._source.fire("tooltipclose",{tooltip:this},! 0)},
             getEvents:
             function()
              {var t=Qe.prototype.getEvents.call(this);
               return bt
                      &&
                      !
                      this.options.permanent
                      &&
                      (t.preclick = this._close),
                      t},
             _close:function(){this._map && this._map.closeTooltip(this)},
             _initLayout:
             function()
              {var
                t=
                 "leaflet-tooltip "
                 +
                 (this.options.className || "")
                 +
                 " leaflet-zoom-"
                 +
                 (this._zoomAnimated?"animated":"hide");
               this._contentNode = this._container = si("div",t)},
             _updateLayout:function(){},
             _adjustPan:function(){},
             _setPosition:
             function(t)
              {var
                i,
                e=this._map,
                n=this._container,
                o=e.latLngToContainerPoint(e.getCenter()),
                s=e.layerPointToContainerPoint(t),
                r=this.options.direction,
                a=n.offsetWidth,
                h=n.offsetHeight,
                u=A(this.options.offset),
                l=this._getAnchor(),
                c=
                 "top" === r
                  ?(i = a / 2,h)
                  :"bottom" === r
                    ?(i = a / 2,0)
                    :(i
                      =
                      "center" === r
                       ?a / 2
                       :"right" === r
                         ?0
                         :"left" === r
                           ?a
                           :s.x < o.x?(r = "right",0):(r = "left",a + 2 * (u.x + l.x)),
                      h
                      /
                      2);
               t
               =
               t.subtract(A(i,c,! 0)).add(u).add(l),
               _i(n,"leaflet-tooltip-right"),
               _i(n,"leaflet-tooltip-left"),
               _i(n,"leaflet-tooltip-top"),
               _i(n,"leaflet-tooltip-bottom"),
               ci(n,"leaflet-tooltip-" + r),
               vi(n,t)},
             _updatePosition:
             function()
              {var t=this._map.latLngToLayerPoint(this._latlng);
               this._setPosition(t)},
             setOpacity:
             function(t)
              {this.options.opacity
               =
               t,
               this._container
               &&
               mi(this._container,t)},
             _animateZoom:
             function(t)
              {var
                i=
                 this._map._latLngToNewLayerPoint
                  (this._latlng,t.zoom,t.center);
               this._setPosition(i)},
             _getAnchor:
             function()
              {return A
                       (this._source
                         &&
                         this._source._getTooltipAnchor
                         &&
                         !
                         this.options.sticky
                         ?this._source._getTooltipAnchor()
                         :[0,0])}});
        Ki.include
         ({openTooltip:
           function(t,i,e)
            {return t instanceof en
                    ||
                    (t = new en(e).setContent(t)),
                    i
                    &&
                    t.setLatLng(i),
                    this.hasLayer(t)?this:this.addLayer(t)},
           closeTooltip:function(t){return t && this.removeLayer(t),this}}),
        Me.include
         ({bindTooltip:
           function(t,i)
            {return t instanceof en
                     ?(c(t,i),(this._tooltip = t)._source = this)
                     :(this._tooltip
                       &&
                       !
                       i
                       ||
                       (this._tooltip = new en(i,this)),
                       this._tooltip.setContent(t)),
                    this._initTooltipInteractions(),
                    this._tooltip.options.permanent
                    &&
                    this._map
                    &&
                    this._map.hasLayer(this)
                    &&
                    this.openTooltip(),
                    this},
           unbindTooltip:
           function()
            {return this._tooltip
                    &&
                    (this._initTooltipInteractions(! 0),
                     this.closeTooltip(),
                     this._tooltip
                     =
                     null),
                    this},
           _initTooltipInteractions:
           function(t)
            {var i,e;
             !
             t
             &&
             this._tooltipHandlersAdded
             ||
             (i
              =
              t?"off":"on",
              e
              =
              {remove:this.closeTooltip,move:this._moveTooltip},
              this._tooltip.options.permanent
               ?e.add = this._openTooltip
               :(e.mouseover
                 =
                 this._openTooltip,
                 e.mouseout
                 =
                 this.closeTooltip,
                 this._tooltip.options.sticky
                 &&
                 (e.mousemove = this._moveTooltip),
                 bt
                 &&
                 (e.click = this._openTooltip)),
              this[i](e),
              this._tooltipHandlersAdded
              =
              !
              t)},
           openTooltip:
           function(t,i)
            {return this._tooltip
                    &&
                    this._map
                    &&
                    (i
                     =
                     this._tooltip._prepareOpen(this,t,i),
                     this._map.openTooltip(this._tooltip,i),
                     this._tooltip.options.interactive
                     &&
                     this._tooltip._container
                     &&
                     (ci(this._tooltip._container,"leaflet-clickable"),
                      this.addInteractiveTarget(this._tooltip._container))),
                    this},
           closeTooltip:
           function()
            {return this._tooltip
                    &&
                    (this._tooltip._close(),
                     this._tooltip.options.interactive
                     &&
                     this._tooltip._container
                     &&
                     (_i(this._tooltip._container,"leaflet-clickable"),
                      this.removeInteractiveTarget(this._tooltip._container))),
                    this},
           toggleTooltip:
           function(t)
            {return this._tooltip
                    &&
                    (this._tooltip._map?this.closeTooltip():this.openTooltip(t)),
                    this},
           isTooltipOpen:function(){return this._tooltip.isOpen()},
           setTooltipContent:
           function(t)
            {return this._tooltip && this._tooltip.setContent(t),this},
           getTooltip:function(){return this._tooltip},
           _openTooltip:
           function(t)
            {var i=t.layer || t.target;
             this._tooltip
             &&
             this._map
             &&
             this.openTooltip(i,this._tooltip.options.sticky?t.latlng:void 0)},
           _moveTooltip:
           function(t)
            {var i,e,n=t.latlng;
             this._tooltip.options.sticky
             &&
             t.originalEvent
             &&
             (i
              =
              this._map.mouseEventToContainerPoint(t.originalEvent),
              e
              =
              this._map.containerPointToLayerPoint(i),
              n
              =
              this._map.layerPointToLatLng(e)),
             this._tooltip.setLatLng(n)}});
        var
         nn=
          Se.extend
           ({options:
             {iconSize:[12,12],
              html:! 1,
              bgPos:null,
              className:"leaflet-div-icon"},
             createIcon:
             function(t)
              {var
                i,
                e=t && "DIV" === t.tagName?t:document.createElement("div"),
                n=this.options;
               return n.html instanceof Element
                       ?(ai(e),e.appendChild(n.html))
                       :e.innerHTML = ! 1 !== n.html?n.html:"",
                      n.bgPos
                      &&
                      (i
                       =
                       A(n.bgPos),
                       e.style.backgroundPosition
                       =
                       -
                       i.x
                       +
                       "px "
                       +
                       -
                       i.y
                       +
                       "px"),
                      this._setIconStyles(e,"icon"),
                      e},
             createShadow:function(){return null}});
        Se.Default = Ze;
        var
         on=
          Me.extend
           ({options:
             {tileSize:256,
              opacity:1,
              updateWhenIdle:yt,
              updateWhenZooming:! 0,
              updateInterval:200,
              zIndex:1,
              bounds:null,
              minZoom:0,
              maxZoom:void 0,
              maxNativeZoom:void 0,
              minNativeZoom:void 0,
              noWrap:! 1,
              pane:"tilePane",
              className:"",
              keepBuffer:2},
             initialize:function(t){c(this,t)},
             onAdd:
             function()
              {this._initContainer(),
               this._levels
               =
               {},
               this._tiles
               =
               {},
               this._resetView(),
               this._update()},
             beforeAdd:function(t){t._addZoomLimit(this)},
             onRemove:
             function(t)
              {this._removeAllTiles(),
               ri(this._container),
               t._removeZoomLimit(this),
               this._container
               =
               null,
               this._tileZoom
               =
               void 0},
             bringToFront:
             function()
              {return this._map
                      &&
                      (hi(this._container),this._setAutoZIndex(Math.max)),
                      this},
             bringToBack:
             function()
              {return this._map
                      &&
                      (ui(this._container),this._setAutoZIndex(Math.min)),
                      this},
             getContainer:function(){return this._container},
             setOpacity:
             function(t)
              {return this.options.opacity = t,this._updateOpacity(),this},
             setZIndex:
             function(t)
              {return this.options.zIndex = t,this._updateZIndex(),this},
             isLoading:function(){return this._loading},
             redraw:
             function()
              {return this._map
                      &&
                      (this._removeAllTiles(),this._update()),
                      this},
             getEvents:
             function()
              {var
                t=
                 {viewprereset:this._invalidateAll,
                  viewreset:this._resetView,
                  zoom:this._resetView,
                  moveend:this._onMoveEnd};
               return this.options.updateWhenIdle
                      ||
                      (this._onMove
                       ||
                       (this._onMove
                        =
                        n(this._onMoveEnd,this.options.updateInterval,this)),
                       t.move
                       =
                       this._onMove),
                      this._zoomAnimated
                      &&
                      (t.zoomanim = this._animateZoom),
                      t},
             createTile:function(){return document.createElement("div")},
             getTileSize:
             function()
              {var t=this.options.tileSize;return t instanceof k?t:new k(t,t)},
             _updateZIndex:
             function()
              {this._container
               &&
               void 0
               !==
               this.options.zIndex
               &&
               null
               !==
               this.options.zIndex
               &&
               (this._container.style.zIndex = this.options.zIndex)},
             _setAutoZIndex:
             function(t)
              {for
                (var
                  i,
                  e=this.getPane().children,
                  n=- t(- (1 / 0),1 / 0),
                  o=0,
                  s=e.length;
                 o
                 <
                 s;
                 o++)
                i
                =
                e[o].style.zIndex,
                e[o]
                !==
                this._container
                &&
                i
                &&
                (n = t(n,+ i));
               isFinite(n)
               &&
               (this.options.zIndex = n + t(- 1,1),this._updateZIndex())},
             _updateOpacity:
             function()
              {if(this._map && ! it)
                {mi(this._container,this.options.opacity);
                 var t=+ new Date(),i=! 1,e=! 1;
                 for(var n in this._tiles)
                  {var o,s=this._tiles[n];
                   s.current
                   &&
                   s.loaded
                   &&
                   (o
                    =
                    Math.min(1,(t - s.loaded) / 200),
                    mi(s.el,o),
                    o < 1
                     ?i = ! 0
                     :(s.active?e = ! 0:this._onOpaqueTile(s),s.active = ! 0))}
                 e
                 &&
                 !
                 this._noPrune
                 &&
                 this._pruneTiles(),
                 i
                 &&
                 (z(this._fadeFrame),
                  this._fadeFrame
                  =
                  M(this._updateOpacity,this))}},
             _onOpaqueTile:a,
             _initContainer:
             function()
              {this._container
               ||
               (this._container
                =
                si("div","leaflet-layer " + (this.options.className || "")),
                this._updateZIndex(),
                this.options.opacity
                <
                1
                &&
                this._updateOpacity(),
                this.getPane().appendChild(this._container))},
             _updateLevels:
             function()
              {var t=this._tileZoom,i=this.options.maxZoom;
               if(void 0 !== t)
                {for(var e in this._levels)
                  e
                  =
                  Number(e),
                  this._levels[e].el.children.length || e === t
                   ?(this._levels[e].el.style.zIndex
                     =
                     i
                     -
                     Math.abs(t - e),
                     this._onUpdateLevel(e))
                   :(ri(this._levels[e].el),
                     this._removeTilesAtZoom(e),
                     this._onRemoveLevel(e),
                     delete this._levels[e]);
                 var n=this._levels[t],o=this._map;
                 return n
                        ||
                        ((n = this._levels[t] = {}).el
                         =
                         si
                          ("div",
                           "leaflet-tile-container leaflet-zoom-animated",
                           this._container),
                         n.el.style.zIndex
                         =
                         i,
                         n.origin
                         =
                         o.project(o.unproject(o.getPixelOrigin()),t).round(),
                         n.zoom
                         =
                         t,
                         this._setZoomTransform(n,o.getCenter(),o.getZoom()),
                         a(n.el.offsetWidth),
                         this._onCreateLevel(n)),
                        this._level
                        =
                        n}},
             _onUpdateLevel:a,
             _onRemoveLevel:a,
             _onCreateLevel:a,
             _pruneTiles:
             function()
              {if(this._map)
                {var t,i,e,n=this._map.getZoom();
                 if(n > this.options.maxZoom || n < this.options.minZoom)
                  this._removeAllTiles();
                 else
                  {for(t in this._tiles)
                    (e = this._tiles[t]).retain = e.current;
                   for(t in this._tiles)
                    (e = this._tiles[t]).current
                    &&
                    !
                    e.active
                    &&
                    (i
                     =
                     e.coords,
                     this._retainParent(i.x,i.y,i.z,i.z - 5)
                     ||
                     this._retainChildren(i.x,i.y,i.z,i.z + 2));
                   for(t in this._tiles)
                    this._tiles[t].retain || this._removeTile(t)}}},
             _removeTilesAtZoom:
             function(t)
              {for(var i in this._tiles)
                this._tiles[i].coords.z === t && this._removeTile(i)},
             _removeAllTiles:
             function(){for(var t in this._tiles)this._removeTile(t)},
             _invalidateAll:
             function()
              {for(var t in this._levels)
                ri(this._levels[t].el),
                this._onRemoveLevel(Number(t)),
                delete this._levels[t];
               this._removeAllTiles(),this._tileZoom = void 0},
             _retainParent:
             function(t,i,e,n)
              {var
                o=Math.floor(t / 2),
                s=Math.floor(i / 2),
                r=e - 1,
                a=new k(+ o,+ s);
               a.z = + r;
               var h=this._tileCoordsToKey(a),u=this._tiles[h];
               return u && u.active
                       ?u.retain = ! 0
                       :(u
                         &&
                         u.loaded
                         &&
                         (u.retain = ! 0),
                         n
                         <
                         r
                         &&
                         this._retainParent(o,s,r,n))},
             _retainChildren:
             function(t,i,e,n)
              {for(var o=2 * t;o < 2 * t + 2;o++)
                for(var s=2 * i;s < 2 * i + 2;s++)
                 {var r=new k(o,s);
                  r.z = e + 1;
                  var a=this._tileCoordsToKey(r),h=this._tiles[a];
                  h && h.active
                   ?h.retain = ! 0
                   :(h
                     &&
                     h.loaded
                     &&
                     (h.retain = ! 0),
                     e
                     +
                     1
                     <
                     n
                     &&
                     this._retainChildren(o,s,e + 1,n))}},
             _resetView:
             function(t)
              {var i=t && (t.pinch || t.flyTo);
               this._setView(this._map.getCenter(),this._map.getZoom(),i,i)},
             _animateZoom:
             function(t){this._setView(t.center,t.zoom,! 0,t.noUpdate)},
             _clampZoom:
             function(t)
              {var i=this.options;
               return void 0 !== i.minNativeZoom && t < i.minNativeZoom
                       ?i.minNativeZoom
                       :void 0 !== i.maxNativeZoom && i.maxNativeZoom < t
                         ?i.maxNativeZoom
                         :t},
             _setView:
             function(t,i,e,n)
              {var
                o=Math.round(i),
                o=
                 void 0
                  !==
                  this.options.maxZoom
                  &&
                  o
                  >
                  this.options.maxZoom
                  ||
                  void 0
                  !==
                  this.options.minZoom
                  &&
                  o
                  <
                  this.options.minZoom
                  ?void 0
                  :this._clampZoom(o),
                s=this.options.updateWhenZooming && o !== this._tileZoom;
               n
               &&
               !
               s
               ||
               (this._tileZoom
                =
                o,
                this._abortLoading
                &&
                this._abortLoading(),
                this._updateLevels(),
                this._resetGrid(),
                void 0
                !==
                o
                &&
                this._update(t),
                e
                ||
                this._pruneTiles(),
                this._noPrune
                =
                !
                !
                e),
               this._setZoomTransforms(t,i)},
             _setZoomTransforms:
             function(t,i)
              {for(var e in this._levels)
                this._setZoomTransform(this._levels[e],t,i)},
             _setZoomTransform:
             function(t,i,e)
              {var
                n=this._map.getZoomScale(e,t.zoom),
                o=
                 t.origin.multiplyBy(n).subtract
                   (this._map._getNewPixelOrigin(i,e)).round
                  ();
               vt?gi(t.el,o,n):vi(t.el,o)},
             _resetGrid:
             function()
              {var
                t=this._map,
                i=t.options.crs,
                e=this._tileSize = this.getTileSize(),
                n=this._tileZoom,
                o=this._map.getPixelWorldBounds(this._tileZoom);
               o
               &&
               (this._globalTileRange = this._pxBoundsToTileRange(o)),
               this._wrapX
               =
               i.wrapLng
               &&
               !
               this.options.noWrap
               &&
               [Math.floor(t.project([0,i.wrapLng[0]],n).x / e.x),
                Math.ceil(t.project([0,i.wrapLng[1]],n).x / e.y)],
               this._wrapY
               =
               i.wrapLat
               &&
               !
               this.options.noWrap
               &&
               [Math.floor(t.project([i.wrapLat[0],0],n).y / e.x),
                Math.ceil(t.project([i.wrapLat[1],0],n).y / e.y)]},
             _onMoveEnd:
             function()
              {this._map && ! this._map._animatingZoom && this._update()},
             _getTiledPixelBounds:
             function(t)
              {var
                i=this._map,
                e=
                 i._animatingZoom
                  ?Math.max(i._animateToZoom,i.getZoom())
                  :i.getZoom(),
                n=i.getZoomScale(e,this._tileZoom),
                o=i.project(t,this._tileZoom).floor(),
                s=i.getSize().divideBy(2 * n);
               return new I(o.subtract(s),o.add(s))},
             _update:
             function(t)
              {var i=this._map;
               if(i)
                {var e=this._clampZoom(i.getZoom());
                 if
                  (void 0
                   ===
                   t
                   &&
                   (t = i.getCenter()),
                   void 0
                   !==
                   this._tileZoom)
                  {var
                    n=this._getTiledPixelBounds(t),
                    o=this._pxBoundsToTileRange(n),
                    s=o.getCenter(),
                    r=[],
                    a=this.options.keepBuffer,
                    h=
                     new
                      I
                      (o.getBottomLeft().subtract([a,- a]),
                       o.getTopRight().add([a,- a]));
                   if
                    (!
                     (isFinite(o.min.x)
                      &&
                      isFinite(o.min.y)
                      &&
                      isFinite(o.max.x)
                      &&
                      isFinite(o.max.y)))
                    throw new
                           Error
                           ("Attempted to load an infinite number of tiles");
                   for(var u in this._tiles)
                    {var l=this._tiles[u].coords;
                     l.z
                     ===
                     this._tileZoom
                     &&
                     h.contains(new k(l.x,l.y))
                     ||
                     (this._tiles[u].current = ! 1)}
                   if(1 < Math.abs(e - this._tileZoom))
                    this._setView(t,e);
                   else
                    {for(var c=o.min.y;c <= o.max.y;c++)
                      for(var _=o.min.x;_ <= o.max.x;_++)
                       {var d,p=new k(_,c);
                        p.z
                        =
                        this._tileZoom,
                        this._isValidTile(p)
                        &&
                        ((d = this._tiles[this._tileCoordsToKey(p)])
                          ?d.current = ! 0
                          :r.push(p))}
                     if
                      (r.sort
                        (function(t,i){return t.distanceTo(s) - i.distanceTo(s)}),
                       0
                       !==
                       r.length)
                      {this._loading
                       ||
                       (this._loading = ! 0,this.fire("loading"));
                       for
                        (var m=document.createDocumentFragment(),_=0;
                         _
                         <
                         r.length;
                         _++)
                        this._addTile(r[_],m);
                       this._level.el.appendChild(m)}}}}},
             _isValidTile:
             function(t)
              {var i=this._map.options.crs;
               if(! i.infinite)
                {var e=this._globalTileRange;
                 if
                  (!
                   i.wrapLng
                   &&
                   (t.x < e.min.x || t.x > e.max.x)
                   ||
                   !
                   i.wrapLat
                   &&
                   (t.y < e.min.y || t.y > e.max.y))
                  return ! 1}
               if(! this.options.bounds)return ! 0;
               var n=this._tileCoordsToBounds(t);
               return N(this.options.bounds).overlaps(n)},
             _keyToBounds:
             function(t)
              {return this._tileCoordsToBounds(this._keyToTileCoords(t))},
             _tileCoordsToNwSe:
             function(t)
              {var i=this._map,e=this.getTileSize(),n=t.scaleBy(e),o=n.add(e);
               return [i.unproject(n,t.z),i.unproject(o,t.z)]},
             _tileCoordsToBounds:
             function(t)
              {var i=this._tileCoordsToNwSe(t),e=new R(i[0],i[1]);
               return this.options.noWrap
                      ||
                      (e = this._map.wrapLatLngBounds(e)),
                      e},
             _tileCoordsToKey:function(t){return t.x + ":" + t.y + ":" + t.z},
             _keyToTileCoords:
             function(t)
              {var i=t.split(":"),e=new k(+ i[0],+ i[1]);
               return e.z = + i[2],e},
             _removeTile:
             function(t)
              {var i=this._tiles[t];
               i
               &&
               (ri(i.el),
                delete this._tiles[t],
                this.fire
                 ("tileunload",{tile:i.el,coords:this._keyToTileCoords(t)}))},
             _initTile:
             function(t)
              {ci(t,"leaflet-tile");
               var i=this.getTileSize();
               t.style.width
               =
               i.x
               +
               "px",
               t.style.height
               =
               i.y
               +
               "px",
               t.onselectstart
               =
               a,
               t.onmousemove
               =
               a,
               it
               &&
               this.options.opacity
               <
               1
               &&
               mi(t,this.options.opacity),
               ot
               &&
               !
               st
               &&
               (t.style.WebkitBackfaceVisibility = "hidden")},
             _addTile:
             function(t,i)
              {var
                e=this._getTilePos(t),
                n=this._tileCoordsToKey(t),
                o=
                 this.createTile
                  (this._wrapCoords(t),p(this._tileReady,this,t));
               this._initTile(o),
               this.createTile.length
               <
               2
               &&
               M(p(this._tileReady,this,t,null,o)),
               vi(o,e),
               this._tiles[n]
               =
               {el:o,coords:t,current:! 0},
               i.appendChild(o),
               this.fire("tileloadstart",{tile:o,coords:t})},
             _tileReady:
             function(t,i,e)
              {i && this.fire("tileerror",{error:i,tile:e,coords:t});
               var n=this._tileCoordsToKey(t);
               (e = this._tiles[n])
               &&
               (e.loaded
                =
                +
                new Date(),
                this._map._fadeAnimated
                 ?(mi(e.el,0),
                   z(this._fadeFrame),
                   this._fadeFrame
                   =
                   M(this._updateOpacity,this))
                 :(e.active = ! 0,this._pruneTiles()),
                i
                ||
                (ci(e.el,"leaflet-tile-loaded"),
                 this.fire("tileload",{tile:e.el,coords:t})),
                this._noTilesToLoad()
                &&
                (this._loading
                 =
                 !
                 1,
                 this.fire("load"),
                 it || ! this._map._fadeAnimated
                  ?M(this._pruneTiles,this)
                  :setTimeout(p(this._pruneTiles,this),250)))},
             _getTilePos:
             function(t)
              {return t.scaleBy(this.getTileSize()).subtract
                       (this._level.origin)},
             _wrapCoords:
             function(t)
              {var
                i=
                 new
                  k
                  (this._wrapX?o(t.x,this._wrapX):t.x,
                   this._wrapY?o(t.y,this._wrapY):t.y);
               return i.z = t.z,i},
             _pxBoundsToTileRange:
             function(t)
              {var i=this.getTileSize();
               return new
                       I
                       (t.min.unscaleBy(i).floor(),
                        t.max.unscaleBy(i).ceil().subtract([1,1]))},
             _noTilesToLoad:
             function()
              {for(var t in this._tiles)if(! this._tiles[t].loaded)return ! 1;
               return ! 0}}),
         sn=
          on.extend
           ({options:
             {minZoom:0,
              maxZoom:18,
              subdomains:"abc",
              errorTileUrl:"",
              zoomOffset:0,
              tms:! 1,
              zoomReverse:! 1,
              detectRetina:! 1,
              crossOrigin:! 1},
             initialize:
             function(t,i)
              {this._url
               =
               t,
               (i = c(this,i)).detectRetina
               &&
               zt
               &&
               0
               <
               i.maxZoom
               &&
               (i.tileSize
                =
                Math.floor(i.tileSize / 2),
                i.zoomReverse
                 ?(i.zoomOffset--,i.minZoom++)
                 :(i.zoomOffset++,i.maxZoom--),
                i.minZoom
                =
                Math.max(0,i.minZoom)),
               "string"
               ==
               typeof i.subdomains
               &&
               (i.subdomains = i.subdomains.split("")),
               ot
               ||
               this.on("tileunload",this._onTileRemove)},
             setUrl:
             function(t,i)
              {return this._url
                      ===
                      t
                      &&
                      void 0
                      ===
                      i
                      &&
                      (i = ! 0),
                      this._url
                      =
                      t,
                      i
                      ||
                      this.redraw(),
                      this},
             createTile:
             function(t,i)
              {var e=document.createElement("img");
               return zi(e,"load",p(this._tileOnLoad,this,i,e)),
                      zi(e,"error",p(this._tileOnError,this,i,e)),
                      !
                      this.options.crossOrigin
                      &&
                      ""
                      !==
                      this.options.crossOrigin
                      ||
                      (e.crossOrigin
                       =
                       ! 0 === this.options.crossOrigin?"":this.options.crossOrigin),
                      e.alt
                      =
                      "",
                      e.setAttribute("role","presentation"),
                      e.src
                      =
                      this.getTileUrl(t),
                      e},
             getTileUrl:
             function(t)
              {var
                i,
                e=
                 {r:zt?"@2x":"",
                  s:this._getSubdomain(t),
                  x:t.x,
                  y:t.y,
                  z:this._getZoomForUrl()};
               return this._map
                      &&
                      !
                      this._map.options.crs.infinite
                      &&
                      (i
                       =
                       this._globalTileRange.max.y
                       -
                       t.y,
                       this.options.tms
                       &&
                       (e.y = i),
                       e["-y"]
                       =
                       i),
                      f(this._url,h(e,this.options))},
             _tileOnLoad:
             function(t,i){it?setTimeout(p(t,this,null,i),0):t(null,i)},
             _tileOnError:
             function(t,i,e)
              {var n=this.options.errorTileUrl;
               n && i.getAttribute("src") !== n && (i.src = n),t(e,i)},
             _onTileRemove:function(t){t.tile.onload = null},
             _getZoomForUrl:
             function()
              {var t=this._tileZoom,i=this.options.maxZoom;
               return this.options.zoomReverse
                      &&
                      (t = i - t),
                      t
                      +
                      this.options.zoomOffset},
             _getSubdomain:
             function(t)
              {var i=Math.abs(t.x + t.y) % this.options.subdomains.length;
               return this.options.subdomains[i]},
             _abortLoading:
             function()
              {var t,i;
               for(t in this._tiles)
                this._tiles[t].coords.z
                !==
                this._tileZoom
                &&
                ((i = this._tiles[t].el).onload
                 =
                 a,
                 i.onerror
                 =
                 a,
                 i.complete
                 ||
                 (i.src = y,ri(i),delete this._tiles[t]))},
             _removeTile:
             function(t)
              {var i=this._tiles[t];
               if(i)
                return at
                       ||
                       i.el.setAttribute("src",y),
                       on.prototype._removeTile.call(this,t)},
             _tileReady:
             function(t,i,e)
              {if(this._map && (! e || e.getAttribute("src") !== y))
                return on.prototype._tileReady.call(this,t,i,e)}});
        function rn(t,i){return new sn(t,i)}
        var
         an=
          sn.extend
           ({defaultWmsParams:
             {service:"WMS",
              request:"GetMap",
              layers:"",
              styles:"",
              format:"image/jpeg",
              transparent:! 1,
              version:"1.1.1"},
             options:{crs:null,uppercase:! 1},
             initialize:
             function(t,i)
              {this._url = t;
               var e=h({},this.defaultWmsParams);
               for(var n in i)n in this.options || (e[n] = i[n]);
               var
                o=(i = c(this,i)).detectRetina && zt?2:1,
                s=this.getTileSize();
               e.width = s.x * o,e.height = s.y * o,this.wmsParams = e},
             onAdd:
             function(t)
              {this._crs
               =
               this.options.crs
               ||
               t.options.crs,
               this._wmsVersion
               =
               parseFloat(this.wmsParams.version);
               var i=1.3 <= this._wmsVersion?"crs":"srs";
               this.wmsParams[i]
               =
               this._crs.code,
               sn.prototype.onAdd.call(this,t)},
             getTileUrl:
             function(t)
              {var
                i=this._tileCoordsToNwSe(t),
                e=this._crs,
                n=O(e.project(i[0]),e.project(i[1])),
                o=n.min,
                s=n.max,
                r=
                 (1.3 <= this._wmsVersion && this._crs === be
                    ?[o.y,o.x,s.y,s.x]
                    :[o.x,o.y,s.x,s.y]).join
                  (","),
                a=sn.prototype.getTileUrl.call(this,t);
               return a
                      +
                      _(this.wmsParams,a,this.options.uppercase)
                      +
                      (this.options.uppercase?"&BBOX=":"&bbox=")
                      +
                      r},
             setParams:
             function(t,i){return h(this.wmsParams,t),i || this.redraw(),this}});
        sn.WMS = an,rn.wms = function(t,i){return new an(t,i)};
        var
         hn=
          Me.extend
           ({options:{padding:.1,tolerance:0},
             initialize:
             function(t){c(this,t),m(this),this._layers = this._layers || {}},
             onAdd:
             function()
              {this._container
               ||
               (this._initContainer(),
                this._zoomAnimated
                &&
                ci(this._container,"leaflet-zoom-animated")),
               this.getPane().appendChild(this._container),
               this._update(),
               this.on("update",this._updatePaths,this)},
             onRemove:
             function()
              {this.off("update",this._updatePaths,this),
               this._destroyContainer()},
             getEvents:
             function()
              {var
                t=
                 {viewreset:this._reset,
                  zoom:this._onZoom,
                  moveend:this._update,
                  zoomend:this._onZoomEnd};
               return this._zoomAnimated && (t.zoomanim = this._onAnimZoom),t},
             _onAnimZoom:function(t){this._updateTransform(t.center,t.zoom)},
             _onZoom:
             function()
              {this._updateTransform
                (this._map.getCenter(),this._map.getZoom())},
             _updateTransform:
             function(t,i)
              {var
                e=this._map.getZoomScale(i,this._zoom),
                n=yi(this._container),
                o=this._map.getSize().multiplyBy(.5 + this.options.padding),
                s=this._map.project(this._center,i),
                r=this._map.project(t,i).subtract(s),
                a=o.multiplyBy(- e).add(n).add(o).subtract(r);
               vt?gi(this._container,a,e):vi(this._container,a)},
             _reset:
             function()
              {for
                (var t
                 in
                 
                 this._update(),
                 this._updateTransform(this._center,this._zoom),
                 this._layers)
                this._layers[t]._reset()},
             _onZoomEnd:
             function(){for(var t in this._layers)this._layers[t]._project()},
             _updatePaths:
             function(){for(var t in this._layers)this._layers[t]._update()},
             _update:
             function()
              {var
                t=this.options.padding,
                i=this._map.getSize(),
                e=
                 this._map.containerPointToLayerPoint(i.multiplyBy(- t)).round
                  ();
               this._bounds
               =
               new I(e,e.add(i.multiplyBy(1 + 2 * t)).round()),
               this._center
               =
               this._map.getCenter(),
               this._zoom
               =
               this._map.getZoom()}}),
         un=
          hn.extend
           ({getEvents:
             function()
              {var t=hn.prototype.getEvents.call(this);
               return t.viewprereset = this._onViewPreReset,t},
             _onViewPreReset:function(){this._postponeUpdatePaths = ! 0},
             onAdd:function(){hn.prototype.onAdd.call(this),this._draw()},
             _initContainer:
             function()
              {var t=this._container = document.createElement("canvas");
               zi(t,"mousemove",this._onMouseMove,this),
               zi
                (t,
                 "click dblclick mousedown mouseup contextmenu",
                 this._onClick,
                 this),
               zi(t,"mouseout",this._handleMouseOut,this),
               this._ctx
               =
               t.getContext("2d")},
             _destroyContainer:
             function()
              {z(this._redrawRequest),
               delete this._ctx,
               ri(this._container),
               Si(this._container),
               delete this._container},
             _updatePaths:
             function()
              {if(! this._postponeUpdatePaths)
                {for(var t in this._redrawBounds = null,this._layers)
                  this._layers[t]._update();
                 this._redraw()}},
             _update:
             function()
              {var t,i,e,n;
               this._map._animatingZoom
               &&
               this._bounds
               ||
               (hn.prototype._update.call(this),
                t
                =
                this._bounds,
                i
                =
                this._container,
                e
                =
                t.getSize(),
                n
                =
                zt?2:1,
                vi(i,t.min),
                i.width
                =
                n
                *
                e.x,
                i.height
                =
                n
                *
                e.y,
                i.style.width
                =
                e.x
                +
                "px",
                i.style.height
                =
                e.y
                +
                "px",
                zt
                &&
                this._ctx.scale(2,2),
                this._ctx.translate(- t.min.x,- t.min.y),
                this.fire("update"))},
             _reset:
             function()
              {hn.prototype._reset.call(this),
               this._postponeUpdatePaths
               &&
               (this._postponeUpdatePaths = ! 1,this._updatePaths())},
             _initPath:
             function(t)
              {this._updateDashArray(t);
               var
                i=
                 (this._layers[m(t)] = t)._order
                 =
                 {layer:t,prev:this._drawLast,next:null};
               this._drawLast
               &&
               (this._drawLast.next = i),
               this._drawLast
               =
               i,
               this._drawFirst
               =
               this._drawFirst
               ||
               this._drawLast},
             _addPath:function(t){this._requestRedraw(t)},
             _removePath:
             function(t)
              {var i=t._order,e=i.next,n=i.prev;
               e?e.prev = n:this._drawLast = n,
               n?n.next = e:this._drawFirst = e,
               delete t._order,
               delete this._layers[m(t)],
               this._requestRedraw(t)},
             _updatePath:
             function(t)
              {this._extendRedrawBounds(t),
               t._project(),
               t._update(),
               this._requestRedraw(t)},
             _updateStyle:
             function(t){this._updateDashArray(t),this._requestRedraw(t)},
             _updateDashArray:
             function(t)
              {if("string" == typeof t.options.dashArray)
                {for
                  (var i,e=t.options.dashArray.split(/[, ]+/),n=[],o=0;
                   o
                   <
                   e.length;
                   o++)
                  {if(i = Number(e[o]),isNaN(i))return;n.push(i)}
                 t.options._dashArray = n}
               else
                t.options._dashArray = t.options.dashArray},
             _requestRedraw:
             function(t)
              {this._map
               &&
               (this._extendRedrawBounds(t),
                this._redrawRequest
                =
                this._redrawRequest
                ||
                M(this._redraw,this))},
             _extendRedrawBounds:
             function(t)
              {var i;
               t._pxBounds
               &&
               (i
                =
                (t.options.weight || 0)
                +
                1,
                this._redrawBounds
                =
                this._redrawBounds
                ||
                new I(),
                this._redrawBounds.extend(t._pxBounds.min.subtract([i,i])),
                this._redrawBounds.extend(t._pxBounds.max.add([i,i])))},
             _redraw:
             function()
              {this._redrawRequest
               =
               null,
               this._redrawBounds
               &&
               (this._redrawBounds.min._floor(),
                this._redrawBounds.max._ceil()),
               this._clear(),
               this._draw(),
               this._redrawBounds
               =
               null},
             _clear:
             function()
              {var t,i=this._redrawBounds;
               i
                ?(t
                  =
                  i.getSize(),
                  this._ctx.clearRect(i.min.x,i.min.y,t.x,t.y))
                :(this._ctx.save(),
                  this._ctx.setTransform(1,0,0,1,0,0),
                  this._ctx.clearRect
                   (0,0,this._container.width,this._container.height),
                  this._ctx.restore())},
             _draw:
             function()
              {var t,i,e=this._redrawBounds;
               this._ctx.save(),
               e
               &&
               (i
                =
                e.getSize(),
                this._ctx.beginPath(),
                this._ctx.rect(e.min.x,e.min.y,i.x,i.y),
                this._ctx.clip()),
               this._drawing
               =
               !
               0;
               for(var n=this._drawFirst;n;n = n.next)
                t
                =
                n.layer,
                (! e || t._pxBounds && t._pxBounds.intersects(e))
                &&
                t._updatePath();
               this._drawing = ! 1,this._ctx.restore()},
             _updatePoly:
             function(t,i)
              {if(this._drawing)
                {var e,n,o,s,r=t._parts,a=r.length,h=this._ctx;
                 if(a)
                  {for(h.beginPath(),e = 0;e < a;e++)
                    {for(n = 0,o = r[e].length;n < o;n++)
                      s = r[e][n],h[n?"lineTo":"moveTo"](s.x,s.y);
                     i && h.closePath()}
                   this._fillStroke(h,t)}}},
             _updateCircle:
             function(t)
              {var i,e,n,o;
               this._drawing
               &&
               !
               t._empty()
               &&
               (i
                =
                t._point,
                e
                =
                this._ctx,
                n
                =
                Math.max(Math.round(t._radius),1),
                1
                !=
                (o = (Math.max(Math.round(t._radiusY),1) || n) / n)
                &&
                (e.save(),e.scale(1,o)),
                e.beginPath(),
                e.arc(i.x,i.y / o,n,0,2 * Math.PI,! 1),
                1
                !=
                o
                &&
                e.restore(),
                this._fillStroke(e,t))},
             _fillStroke:
             function(t,i)
              {var e=i.options;
               e.fill
               &&
               (t.globalAlpha
                =
                e.fillOpacity,
                t.fillStyle
                =
                e.fillColor
                ||
                e.color,
                t.fill(e.fillRule || "evenodd")),
               e.stroke
               &&
               0
               !==
               e.weight
               &&
               (t.setLineDash
                &&
                t.setLineDash(i.options && i.options._dashArray || []),
                t.globalAlpha
                =
                e.opacity,
                t.lineWidth
                =
                e.weight,
                t.strokeStyle
                =
                e.color,
                t.lineCap
                =
                e.lineCap,
                t.lineJoin
                =
                e.lineJoin,
                t.stroke())},
             _onClick:
             function(t)
              {for
                (var
                  i,
                  e,
                  n=this._map.mouseEventToLayerPoint(t),
                  o=this._drawFirst;
                 o;
                 o
                 =
                 o.next)
                (i = o.layer).options.interactive
                &&
                i._containsPoint(n)
                &&
                (("click" === t.type || "preclick" !== t.type)
                 &&
                 this._map._draggableMoved(i)
                 ||
                 (e = i));
               e && (Fi(t),this._fireEvent([e],t))},
             _onMouseMove:
             function(t)
              {var i;
               !
               this._map
               ||
               this._map.dragging.moving()
               ||
               this._map._animatingZoom
               ||
               (i
                =
                this._map.mouseEventToLayerPoint(t),
                this._handleMouseHover(t,i))},
             _handleMouseOut:
             function(t)
              {var i=this._hoveredLayer;
               i
               &&
               (_i(this._container,"leaflet-interactive"),
                this._fireEvent([i],t,"mouseout"),
                this._hoveredLayer
                =
                null,
                this._mouseHoverThrottled
                =
                !
                1)},
             _handleMouseHover:
             function(t,i)
              {if(! this._mouseHoverThrottled)
                {for(var e,n,o=this._drawFirst;o;o = o.next)
                  (e = o.layer).options.interactive
                  &&
                  e._containsPoint(i)
                  &&
                  (n = e);
                 n
                 !==
                 this._hoveredLayer
                 &&
                 (this._handleMouseOut(t),
                  n
                  &&
                  (ci(this._container,"leaflet-interactive"),
                   this._fireEvent([n],t,"mouseover"),
                   this._hoveredLayer
                   =
                   n)),
                 this._hoveredLayer
                 &&
                 this._fireEvent([this._hoveredLayer],t),
                 this._mouseHoverThrottled
                 =
                 !
                 0,
                 setTimeout
                  (p(function(){this._mouseHoverThrottled = ! 1},this),32)}},
             _fireEvent:
             function(t,i,e){this._map._fireDOMEvent(i,e || i.type,t)},
             _bringToFront:
             function(t)
              {var i,e,n=t._order;
               n
               &&
               (i
                =
                n.next,
                e
                =
                n.prev,
                i
                &&
                ((i.prev = e)?e.next = i:i && (this._drawFirst = i),
                 n.prev
                 =
                 this._drawLast,
                 (this._drawLast.next = n).next
                 =
                 null,
                 this._drawLast
                 =
                 n,
                 this._requestRedraw(t)))},
             _bringToBack:
             function(t)
              {var i,e,n=t._order;
               n
               &&
               (i
                =
                n.next,
                (e = n.prev)
                &&
                ((e.next = i)?i.prev = e:e && (this._drawLast = e),
                 n.prev
                 =
                 null,
                 n.next
                 =
                 this._drawFirst,
                 this._drawFirst.prev
                 =
                 n,
                 this._drawFirst
                 =
                 n,
                 this._requestRedraw(t)))}});
        function ln(t){return St?new un(t):null}
        var
         cn=
          function()
            {try
              {return document.namespaces.add
                       ("lvml","urn:schemas-microsoft-com:vml"),
                      function(t)
                       {return document.createElement
                                ("<lvml:" + t + ' class="lvml">')}}
             catch(t)
              {return function(t)
                {return document.createElement
                         ("<"
                          +
                          t
                          +
                          ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}
           (),
         _n=
          {_initContainer:
           function(){this._container = si("div","leaflet-vml-container")},
           _update:
           function()
            {this._map._animatingZoom
             ||
             (hn.prototype._update.call(this),this.fire("update"))},
           _initPath:
           function(t)
            {var i=t._container = cn("shape");
             ci(i,"leaflet-vml-shape " + (this.options.className || "")),
             i.coordsize
             =
             "1 1",
             t._path
             =
             cn("path"),
             i.appendChild(t._path),
             this._updateStyle(t),
             this._layers[m(t)]
             =
             t},
           _addPath:
           function(t)
            {var i=t._container;
             this._container.appendChild(i),
             t.options.interactive
             &&
             t.addInteractiveTarget(i)},
           _removePath:
           function(t)
            {var i=t._container;
             ri(i),t.removeInteractiveTarget(i),delete this._layers[m(t)]},
           _updateStyle:
           function(t)
            {var i=t._stroke,e=t._fill,n=t.options,o=t._container;
             o.stroked
             =
             !
             !
             n.stroke,
             o.filled
             =
             !
             !
             n.fill,
             n.stroke
              ?(i
                =
                i
                ||
                (t._stroke = cn("stroke")),
                o.appendChild(i),
                i.weight
                =
                n.weight
                +
                "px",
                i.color
                =
                n.color,
                i.opacity
                =
                n.opacity,
                n.dashArray
                 ?i.dashStyle
                  =
                  g(n.dashArray)
                   ?n.dashArray.join(" ")
                   :n.dashArray.replace(/( *, *)/g," ")
                 :i.dashStyle = "",
                i.endcap
                =
                n.lineCap.replace("butt","flat"),
                i.joinstyle
                =
                n.lineJoin)
              :i && (o.removeChild(i),t._stroke = null),
             n.fill
              ?(e
                =
                e
                ||
                (t._fill = cn("fill")),
                o.appendChild(e),
                e.color
                =
                n.fillColor
                ||
                n.color,
                e.opacity
                =
                n.fillOpacity)
              :e && (o.removeChild(e),t._fill = null)},
           _updateCircle:
           function(t)
            {var
              i=t._point.round(),
              e=Math.round(t._radius),
              n=Math.round(t._radiusY || e);
             this._setPath
              (t,
               t._empty()
                ?"M0 0"
                :"AL " + i.x + "," + i.y + " " + e + "," + n + " 0,23592600")},
           _setPath:function(t,i){t._path.v = i},
           _bringToFront:function(t){hi(t._container)},
           _bringToBack:function(t){ui(t._container)}},
         dn=Et?cn:J,
         pn=
          hn.extend
           ({getEvents:
             function()
              {var t=hn.prototype.getEvents.call(this);
               return t.zoomstart = this._onZoomStart,t},
             _initContainer:
             function()
              {this._container
               =
               dn("svg"),
               this._container.setAttribute("pointer-events","none"),
               this._rootGroup
               =
               dn("g"),
               this._container.appendChild(this._rootGroup)},
             _destroyContainer:
             function()
              {ri(this._container),
               Si(this._container),
               delete this._container,
               delete this._rootGroup,
               delete this._svgSize},
             _onZoomStart:function(){this._update()},
             _update:
             function()
              {var t,i,e;
               this._map._animatingZoom
               &&
               this._bounds
               ||
               (hn.prototype._update.call(this),
                i
                =
                (t = this._bounds).getSize(),
                e
                =
                this._container,
                this._svgSize
                &&
                this._svgSize.equals(i)
                ||
                (this._svgSize
                 =
                 i,
                 e.setAttribute("width",i.x),
                 e.setAttribute("height",i.y)),
                vi(e,t.min),
                e.setAttribute("viewBox",[t.min.x,t.min.y,i.x,i.y].join(" ")),
                this.fire("update"))},
             _initPath:
             function(t)
              {var i=t._path = dn("path");
               t.options.className
               &&
               ci(i,t.options.className),
               t.options.interactive
               &&
               ci(i,"leaflet-interactive"),
               this._updateStyle(t),
               this._layers[m(t)]
               =
               t},
             _addPath:
             function(t)
              {this._rootGroup
               ||
               this._initContainer(),
               this._rootGroup.appendChild(t._path),
               t.addInteractiveTarget(t._path)},
             _removePath:
             function(t)
              {ri(t._path),
               t.removeInteractiveTarget(t._path),
               delete this._layers[m(t)]},
             _updatePath:function(t){t._project(),t._update()},
             _updateStyle:
             function(t)
              {var i=t._path,e=t.options;
               i
               &&
               (e.stroke
                 ?(i.setAttribute("stroke",e.color),
                   i.setAttribute("stroke-opacity",e.opacity),
                   i.setAttribute("stroke-width",e.weight),
                   i.setAttribute("stroke-linecap",e.lineCap),
                   i.setAttribute("stroke-linejoin",e.lineJoin),
                   e.dashArray
                    ?i.setAttribute("stroke-dasharray",e.dashArray)
                    :i.removeAttribute("stroke-dasharray"),
                   e.dashOffset
                    ?i.setAttribute("stroke-dashoffset",e.dashOffset)
                    :i.removeAttribute("stroke-dashoffset"))
                 :i.setAttribute("stroke","none"),
                e.fill
                 ?(i.setAttribute("fill",e.fillColor || e.color),
                   i.setAttribute("fill-opacity",e.fillOpacity),
                   i.setAttribute("fill-rule",e.fillRule || "evenodd"))
                 :i.setAttribute("fill","none"))},
             _updatePoly:function(t,i){this._setPath(t,$(t._parts,i))},
             _updateCircle:
             function(t)
              {var
                i=t._point,
                e=Math.max(Math.round(t._radius),1),
                n=
                 "a"
                 +
                 e
                 +
                 ","
                 +
                 (Math.max(Math.round(t._radiusY),1) || e)
                 +
                 " 0 1,0 ",
                o=
                 t._empty()
                  ?"M0 0"
                  :"M"
                   +
                   (i.x - e)
                   +
                   ","
                   +
                   i.y
                   +
                   n
                   +
                   2
                   *
                   e
                   +
                   ",0 "
                   +
                   n
                   +
                   2
                   *
                   -
                   e
                   +
                   ",0 ";
               this._setPath(t,o)},
             _setPath:function(t,i){t._path.setAttribute("d",i)},
             _bringToFront:function(t){hi(t._path)},
             _bringToBack:function(t){ui(t._path)}});
        function mn(t){return Zt || Et?new pn(t):null}
        Et
        &&
        pn.include(_n),
        Ki.include
         ({getRenderer:
           function(t)
            {var
              i=
               (i
                =
                t.options.renderer
                ||
                this._getPaneRenderer(t.options.pane)
                ||
                this.options.renderer
                ||
                this._renderer)
               ||
               (this._renderer = this._createRenderer());
             return this.hasLayer(i) || this.addLayer(i),i},
           _getPaneRenderer:
           function(t)
            {if("overlayPane" === t || void 0 === t)return ! 1;
             var i=this._paneRenderers[t];
             return void 0
                    ===
                    i
                    &&
                    (i
                     =
                     this._createRenderer({pane:t}),
                     this._paneRenderers[t]
                     =
                     i),
                    i},
           _createRenderer:
           function(t){return this.options.preferCanvas && ln(t) || mn(t)}});
        var
         fn=
          Re.extend
           ({initialize:
             function(t,i)
              {Re.prototype.initialize.call(this,this._boundsToLatLngs(t),i)},
             setBounds:
             function(t){return this.setLatLngs(this._boundsToLatLngs(t))},
             _boundsToLatLngs:
             function(t)
              {return [(t = N(t)).getSouthWest(),
                       t.getNorthWest(),
                       t.getNorthEast(),
                       t.getSouthEast()]}});
        pn.create
        =
        dn,
        pn.pointsToPath
        =
        $,
        Ne.geometryToLayer
        =
        De,
        Ne.coordsToLatLng
        =
        We,
        Ne.coordsToLatLngs
        =
        He,
        Ne.latLngToCoords
        =
        Fe,
        Ne.latLngsToCoords
        =
        Ue,
        Ne.getFeature
        =
        Ve,
        Ne.asFeature
        =
        qe,
        Ki.mergeOptions({boxZoom:! 0});
        var
         gn=
          ie.extend
           ({initialize:
             function(t)
              {this._map
               =
               t,
               this._container
               =
               t._container,
               this._pane
               =
               t._panes.overlayPane,
               this._resetStateTimeout
               =
               0,
               t.on("unload",this._destroy,this)},
             addHooks:
             function()
              {zi(this._container,"mousedown",this._onMouseDown,this)},
             removeHooks:
             function()
              {Si(this._container,"mousedown",this._onMouseDown,this)},
             moved:function(){return this._moved},
             _destroy:function(){ri(this._pane),delete this._pane},
             _resetState:
             function(){this._resetStateTimeout = 0,this._moved = ! 1},
             _clearDeferredResetState:
             function()
              {0
               !==
               this._resetStateTimeout
               &&
               (clearTimeout(this._resetStateTimeout),
                this._resetStateTimeout
                =
                0)},
             _onMouseDown:
             function(t)
              {if(! t.shiftKey || 1 !== t.which && 1 !== t.button)return ! 1;
               this._clearDeferredResetState(),
               this._resetState(),
               Xt(),
               xi(),
               this._startPoint
               =
               this._map.mouseEventToContainerPoint(t),
               zi
                (document,
                 {contextmenu:Ni,
                  mousemove:this._onMouseMove,
                  mouseup:this._onMouseUp,
                  keydown:this._onKeyDown},
                 this)},
             _onMouseMove:
             function(t)
              {this._moved
               ||
               (this._moved
                =
                !
                0,
                this._box
                =
                si("div","leaflet-zoom-box",this._container),
                ci(this._container,"leaflet-crosshair"),
                this._map.fire("boxzoomstart")),
               this._point
               =
               this._map.mouseEventToContainerPoint(t);
               var i=new I(this._point,this._startPoint),e=i.getSize();
               vi(this._box,i.min),
               this._box.style.width
               =
               e.x
               +
               "px",
               this._box.style.height
               =
               e.y
               +
               "px"},
             _finish:
             function()
              {this._moved
               &&
               (ri(this._box),_i(this._container,"leaflet-crosshair")),
               Jt(),
               wi(),
               Si
                (document,
                 {contextmenu:Ni,
                  mousemove:this._onMouseMove,
                  mouseup:this._onMouseUp,
                  keydown:this._onKeyDown},
                 this)},
             _onMouseUp:
             function(t)
              {var i;
               1
               !==
               t.which
               &&
               1
               !==
               t.button
               ||
               (this._finish(),
                this._moved
                &&
                (this._clearDeferredResetState(),
                 this._resetStateTimeout
                 =
                 setTimeout(p(this._resetState,this),0),
                 i
                 =
                 new
                  R
                  (this._map.containerPointToLatLng(this._startPoint),
                   this._map.containerPointToLatLng(this._point)),
                 this._map.fitBounds(i).fire("boxzoomend",{boxZoomBounds:i})))},
             _onKeyDown:function(t){27 === t.keyCode && this._finish()}});
        Ki.addInitHook("addHandler","boxZoom",gn),
        Ki.mergeOptions({doubleClickZoom:! 0});
        var
         vn=
          ie.extend
           ({addHooks:
             function(){this._map.on("dblclick",this._onDoubleClick,this)},
             removeHooks:
             function(){this._map.off("dblclick",this._onDoubleClick,this)},
             _onDoubleClick:
             function(t)
              {var
                i=this._map,
                e=i.getZoom(),
                n=i.options.zoomDelta,
                o=t.originalEvent.shiftKey?e - n:e + n;
               "center" === i.options.doubleClickZoom
                ?i.setZoom(o)
                :i.setZoomAround(t.containerPoint,o)}});
        Ki.addInitHook("addHandler","doubleClickZoom",vn),
        Ki.mergeOptions
         ({dragging:! 0,
           inertia:! st,
           inertiaDeceleration:3400,
           inertiaMaxSpeed:1 / 0,
           easeLinearity:.2,
           worldCopyJump:! 1,
           maxBoundsViscosity:0});
        var
         yn=
          ie.extend
           ({addHooks:
             function()
              {var t;
               this._draggable
               ||
               (t
                =
                this._map,
                this._draggable
                =
                new ae(t._mapPane,t._container),
                this._draggable.on
                 ({dragstart:this._onDragStart,
                   drag:this._onDrag,
                   dragend:this._onDragEnd},
                  this),
                this._draggable.on("predrag",this._onPreDragLimit,this),
                t.options.worldCopyJump
                &&
                (this._draggable.on("predrag",this._onPreDragWrap,this),
                 t.on("zoomend",this._onZoomEnd,this),
                 t.whenReady(this._onZoomEnd,this))),
               ci(this._map._container,"leaflet-grab leaflet-touch-drag"),
               this._draggable.enable(),
               this._positions
               =
               [],
               this._times
               =
               []},
             removeHooks:
             function()
              {_i(this._map._container,"leaflet-grab"),
               _i(this._map._container,"leaflet-touch-drag"),
               this._draggable.disable()},
             moved:
             function(){return this._draggable && this._draggable._moved},
             moving:
             function(){return this._draggable && this._draggable._moving},
             _onDragStart:
             function()
              {var t,i=this._map;
               i._stop(),
               this._map.options.maxBounds
                &&
                this._map.options.maxBoundsViscosity
                ?(t
                  =
                  N(this._map.options.maxBounds),
                  this._offsetLimit
                  =
                  O
                   (this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy
                     (- 1),
                    this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy
                      (- 1).add
                     (this._map.getSize())),
                  this._viscosity
                  =
                  Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity)))
                :this._offsetLimit = null,
               i.fire("movestart").fire("dragstart"),
               i.options.inertia
               &&
               (this._positions = [],this._times = [])},
             _onDrag:
             function(t)
              {var i,e;
               this._map.options.inertia
               &&
               (i
                =
                this._lastTime
                =
                +
                new Date(),
                e
                =
                this._lastPos
                =
                this._draggable._absPos
                ||
                this._draggable._newPos,
                this._positions.push(e),
                this._times.push(i),
                this._prunePositions(i)),
               this._map.fire("move",t).fire("drag",t)},
             _prunePositions:
             function(t)
              {for(;1 < this._positions.length && 50 < t - this._times[0];)
                this._positions.shift(),this._times.shift()},
             _onZoomEnd:
             function()
              {var
                t=this._map.getSize().divideBy(2),
                i=this._map.latLngToLayerPoint([0,0]);
               this._initialWorldOffset
               =
               i.subtract(t).x,
               this._worldWidth
               =
               this._map.getPixelWorldBounds().getSize().x},
             _viscousLimit:function(t,i){return t - (t - i) * this._viscosity},
             _onPreDragLimit:
             function()
              {var t,i;
               this._viscosity
               &&
               this._offsetLimit
               &&
               (t
                =
                this._draggable._newPos.subtract(this._draggable._startPos),
                i
                =
                this._offsetLimit,
                t.x
                <
                i.min.x
                &&
                (t.x = this._viscousLimit(t.x,i.min.x)),
                t.y
                <
                i.min.y
                &&
                (t.y = this._viscousLimit(t.y,i.min.y)),
                t.x
                >
                i.max.x
                &&
                (t.x = this._viscousLimit(t.x,i.max.x)),
                t.y
                >
                i.max.y
                &&
                (t.y = this._viscousLimit(t.y,i.max.y)),
                this._draggable._newPos
                =
                this._draggable._startPos.add(t))},
             _onPreDragWrap:
             function()
              {var
                t=this._worldWidth,
                i=Math.round(t / 2),
                e=this._initialWorldOffset,
                n=this._draggable._newPos.x,
                o=(n - i + e) % t + i - e,
                s=(n + i + e) % t - i - e,
                r=Math.abs(o + e) < Math.abs(s + e)?o:s;
               this._draggable._absPos
               =
               this._draggable._newPos.clone(),
               this._draggable._newPos.x
               =
               r},
             _onDragEnd:
             function(t)
              {var
                i,
                e,
                n,
                o,
                s,
                r,
                a,
                h,
                u,
                l=this._map,
                c=l.options,
                _=! c.inertia || this._times.length < 2;
               l.fire("dragend",t),
               _
                ?l.fire("moveend")
                :(this._prunePositions(+ new Date()),
                  i
                  =
                  this._lastPos.subtract(this._positions[0]),
                  e
                  =
                  (this._lastTime - this._times[0])
                  /
                  1e3,
                  n
                  =
                  c.easeLinearity,
                  s
                  =
                  (o = i.multiplyBy(n / e)).distanceTo([0,0]),
                  r
                  =
                  Math.min(c.inertiaMaxSpeed,s),
                  a
                  =
                  o.multiplyBy(r / s),
                  h
                  =
                  r
                  /
                  (c.inertiaDeceleration * n),
                  (u = a.multiplyBy(- (h / 2)).round()).x || u.y
                   ?(u
                     =
                     l._limitOffset(u,l.options.maxBounds),
                     M
                      (function()
                        {l.panBy
                          (u,{duration:h,easeLinearity:n,noMoveStart:! 0,animate:! 0})}))
                   :l.fire("moveend"))}});
        Ki.addInitHook("addHandler","dragging",yn),
        Ki.mergeOptions({keyboard:! 0,keyboardPanDelta:80});
        var
         xn=
          ie.extend
           ({keyCodes:
             {left:[37],
              right:[39],
              down:[40],
              up:[38],
              zoomIn:[187,107,61,171],
              zoomOut:[189,109,54,173]},
             initialize:
             function(t)
              {this._map
               =
               t,
               this._setPanDelta(t.options.keyboardPanDelta),
               this._setZoomDelta(t.options.zoomDelta)},
             addHooks:
             function()
              {var t=this._map._container;
               t.tabIndex
               <=
               0
               &&
               (t.tabIndex = "0"),
               zi
                (t,
                 {focus:this._onFocus,
                  blur:this._onBlur,
                  mousedown:this._onMouseDown},
                 this),
               this._map.on
                ({focus:this._addHooks,blur:this._removeHooks},this)},
             removeHooks:
             function()
              {this._removeHooks(),
               Si
                (this._map._container,
                 {focus:this._onFocus,
                  blur:this._onBlur,
                  mousedown:this._onMouseDown},
                 this),
               this._map.off
                ({focus:this._addHooks,blur:this._removeHooks},this)},
             _onMouseDown:
             function()
              {var t,i,e,n;
               this._focused
               ||
               (t
                =
                document.body,
                i
                =
                document.documentElement,
                e
                =
                t.scrollTop
                ||
                i.scrollTop,
                n
                =
                t.scrollLeft
                ||
                i.scrollLeft,
                this._map._container.focus(),
                window.scrollTo(n,e))},
             _onFocus:function(){this._focused = ! 0,this._map.fire("focus")},
             _onBlur:function(){this._focused = ! 1,this._map.fire("blur")},
             _setPanDelta:
             function(t)
              {for
                (var i=this._panKeys = {},e=this.keyCodes,n=0,o=e.left.length;
                 n
                 <
                 o;
                 n++)
                i[e.left[n]] = [- (1 * t),0];
               for(n = 0,o = e.right.length;n < o;n++)i[e.right[n]] = [t,0];
               for(n = 0,o = e.down.length;n < o;n++)i[e.down[n]] = [0,t];
               for(n = 0,o = e.up.length;n < o;n++)i[e.up[n]] = [0,- (1 * t)]},
             _setZoomDelta:
             function(t)
              {for
                (var
                  i=this._zoomKeys = {},
                  e=this.keyCodes,
                  n=0,
                  o=e.zoomIn.length;
                 n
                 <
                 o;
                 n++)
                i[e.zoomIn[n]] = t;
               for(n = 0,o = e.zoomOut.length;n < o;n++)i[e.zoomOut[n]] = - t},
             _addHooks:function(){zi(document,"keydown",this._onKeyDown,this)},
             _removeHooks:
             function(){Si(document,"keydown",this._onKeyDown,this)},
             _onKeyDown:
             function(t)
              {if(! (t.altKey || t.ctrlKey || t.metaKey))
                {var i,e=t.keyCode,n=this._map;
                 if(e in this._panKeys)
                  n._panAnim
                  &&
                  n._panAnim._inProgress
                  ||
                  (i
                   =
                   this._panKeys[e],
                   t.shiftKey
                   &&
                   (i = A(i).multiplyBy(3)),
                   n.panBy(i),
                   n.options.maxBounds
                   &&
                   n.panInsideBounds(n.options.maxBounds));
                 else
                  if(e in this._zoomKeys)
                   n.setZoom
                    (n.getZoom() + (t.shiftKey?3:1) * this._zoomKeys[e]);
                  else
                   {if
                     (27
                      !==
                      e
                      ||
                      !
                      n._popup
                      ||
                      !
                      n._popup.options.closeOnEscapeKey)
                     return;
                    n.closePopup()}
                 Ni(t)}}});
        Ki.addInitHook("addHandler","keyboard",xn),
        Ki.mergeOptions
         ({scrollWheelZoom:! 0,wheelDebounceTime:40,wheelPxPerZoomLevel:60});
        var
         wn=
          ie.extend
           ({addHooks:
             function()
              {zi(this._map._container,"wheel",this._onWheelScroll,this),
               this._delta
               =
               0},
             removeHooks:
             function()
              {Si(this._map._container,"wheel",this._onWheelScroll,this)},
             _onWheelScroll:
             function(t)
              {var i=Wi(t),e=this._map.options.wheelDebounceTime;
               this._delta
               +=
               i,
               this._lastMousePos
               =
               this._map.mouseEventToContainerPoint(t),
               this._startTime
               ||
               (this._startTime = + new Date());
               var n=Math.max(e - (new Date() - this._startTime),0);
               clearTimeout(this._timer),
               this._timer
               =
               setTimeout(p(this._performZoom,this),n),
               Ni(t)},
             _performZoom:
             function()
              {var
                t=this._map,
                i=t.getZoom(),
                e=this._map.options.zoomSnap || 0;
               t._stop();
               var
                n=this._delta / (4 * this._map.options.wheelPxPerZoomLevel),
                o=4 * Math.log(2 / (1 + Math.exp(- Math.abs(n)))) / Math.LN2,
                s=e?Math.ceil(o / e) * e:o,
                r=t._limitZoom(i + (0 < this._delta?s:- s)) - i;
               this._delta
               =
               0,
               this._startTime
               =
               null,
               r
               &&
               ("center" === t.options.scrollWheelZoom
                 ?t.setZoom(i + r)
                 :t.setZoomAround(this._lastMousePos,i + r))}});
        Ki.addInitHook("addHandler","scrollWheelZoom",wn),
        Ki.mergeOptions({tap:! 0,tapTolerance:15});
        var
         Pn=
          ie.extend
           ({addHooks:
             function()
              {zi(this._map._container,"touchstart",this._onDown,this)},
             removeHooks:
             function()
              {Si(this._map._container,"touchstart",this._onDown,this)},
             _onDown:
             function(t)
              {if(t.touches)
                {if(Ri(t),this._fireClick = ! 0,1 < t.touches.length)
                  return this._fireClick
                         =
                         !
                         1,
                         void clearTimeout(this._holdTimeout);
                 var i=t.touches[0],e=i.target;
                 this._startPos
                 =
                 this._newPos
                 =
                 new k(i.clientX,i.clientY),
                 e.tagName
                 &&
                 "a"
                 ===
                 e.tagName.toLowerCase()
                 &&
                 ci(e,"leaflet-active"),
                 this._holdTimeout
                 =
                 setTimeout
                  (p
                    (function()
                      {this._isTapValid()
                       &&
                       (this._fireClick
                        =
                        !
                        1,
                        this._onUp(),
                        this._simulateEvent("contextmenu",i))},
                     this),
                   1e3),
                 this._simulateEvent("mousedown",i),
                 zi
                  (document,{touchmove:this._onMove,touchend:this._onUp},this)}},
             _onUp:
             function(t)
              {var i,e;
               clearTimeout(this._holdTimeout),
               Si(document,{touchmove:this._onMove,touchend:this._onUp},this),
               this._fireClick
               &&
               t
               &&
               t.changedTouches
               &&
               ((e = (i = t.changedTouches[0]).target)
                &&
                e.tagName
                &&
                "a"
                ===
                e.tagName.toLowerCase()
                &&
                _i(e,"leaflet-active"),
                this._simulateEvent("mouseup",i),
                this._isTapValid()
                &&
                this._simulateEvent("click",i))},
             _isTapValid:
             function()
              {return this._newPos.distanceTo(this._startPos)
                      <=
                      this._map.options.tapTolerance},
             _onMove:
             function(t)
              {var i=t.touches[0];
               this._newPos
               =
               new k(i.clientX,i.clientY),
               this._simulateEvent("mousemove",i)},
             _simulateEvent:
             function(t,i)
              {var e=document.createEvent("MouseEvents");
               e._simulated
               =
               !
               0,
               i.target._simulatedClick
               =
               !
               0,
               e.initMouseEvent
                (t,
                 ! 0,
                 ! 0,
                 window,
                 1,
                 i.screenX,
                 i.screenY,
                 i.clientX,
                 i.clientY,
                 ! 1,
                 ! 1,
                 ! 1,
                 ! 1,
                 0,
                 null),
               i.target.dispatchEvent(e)}});
        !
        bt
        ||
        Lt
        &&
        !
        ct
        ||
        Ki.addInitHook("addHandler","tap",Pn),
        Ki.mergeOptions({touchZoom:bt && ! st,bounceAtZoomLimits:! 0});
        var
         Ln=
          ie.extend
           ({addHooks:
             function()
              {ci(this._map._container,"leaflet-touch-zoom"),
               zi(this._map._container,"touchstart",this._onTouchStart,this)},
             removeHooks:
             function()
              {_i(this._map._container,"leaflet-touch-zoom"),
               Si(this._map._container,"touchstart",this._onTouchStart,this)},
             _onTouchStart:
             function(t)
              {var i,e,n=this._map;
               !
               t.touches
               ||
               2
               !==
               t.touches.length
               ||
               n._animatingZoom
               ||
               this._zooming
               ||
               (i
                =
                n.mouseEventToContainerPoint(t.touches[0]),
                e
                =
                n.mouseEventToContainerPoint(t.touches[1]),
                this._centerPoint
                =
                n.getSize()._divideBy(2),
                this._startLatLng
                =
                n.containerPointToLatLng(this._centerPoint),
                "center"
                !==
                n.options.touchZoom
                &&
                (this._pinchStartLatLng
                 =
                 n.containerPointToLatLng(i.add(e)._divideBy(2))),
                this._startDist
                =
                i.distanceTo(e),
                this._startZoom
                =
                n.getZoom(),
                this._moved
                =
                !
                1,
                this._zooming
                =
                !
                0,
                n._stop(),
                zi(document,"touchmove",this._onTouchMove,this),
                zi(document,"touchend",this._onTouchEnd,this),
                Ri(t))},
             _onTouchMove:
             function(t)
              {if(t.touches && 2 === t.touches.length && this._zooming)
                {var
                  i=this._map,
                  e=i.mouseEventToContainerPoint(t.touches[0]),
                  n=i.mouseEventToContainerPoint(t.touches[1]),
                  o=e.distanceTo(n) / this._startDist;
                 if
                  (this._zoom
                   =
                   i.getScaleZoom(o,this._startZoom),
                   !
                   i.options.bounceAtZoomLimits
                   &&
                   (this._zoom
                    <
                    i.getMinZoom()
                    &&
                    o
                    <
                    1
                    ||
                    this._zoom
                    >
                    i.getMaxZoom()
                    &&
                    1
                    <
                    o)
                   &&
                   (this._zoom = i._limitZoom(this._zoom)),
                   "center"
                   ===
                   i.options.touchZoom)
                  {if(this._center = this._startLatLng,1 == o)return}
                 else
                  {var s=e._add(n)._divideBy(2)._subtract(this._centerPoint);
                   if(1 == o && 0 === s.x && 0 === s.y)return;
                   this._center
                   =
                   i.unproject
                    (i.project(this._pinchStartLatLng,this._zoom).subtract(s),
                     this._zoom)}
                 this._moved
                 ||
                 (i._moveStart(! 0,! 1),this._moved = ! 0),
                 z(this._animRequest);
                 var
                  r=
                   p(i._move,i,this._center,this._zoom,{pinch:! 0,round:! 1});
                 this._animRequest = M(r,this,! 0),Ri(t)}},
             _onTouchEnd:
             function()
              {this._moved && this._zooming
                ?(this._zooming
                  =
                  !
                  1,
                  z(this._animRequest),
                  Si(document,"touchmove",this._onTouchMove,this),
                  Si(document,"touchend",this._onTouchEnd,this),
                  this._map.options.zoomAnimation
                   ?this._map._animateZoom
                     (this._center,
                      this._map._limitZoom(this._zoom),
                      ! 0,
                      this._map.options.zoomSnap)
                   :this._map._resetView
                     (this._center,this._map._limitZoom(this._zoom)))
                :this._zooming = ! 1}});
        Ki.addInitHook("addHandler","touchZoom",Ln),
        Ki.BoxZoom
        =
        gn,
        Ki.DoubleClickZoom
        =
        vn,
        Ki.Drag
        =
        yn,
        Ki.Keyboard
        =
        xn,
        Ki.ScrollWheelZoom
        =
        wn,
        Ki.Tap
        =
        Pn,
        Ki.TouchZoom
        =
        Ln,
        t.version
        =
        "1.7.1",
        t.Control
        =
        Xi,
        t.control
        =
        Yi,
        t.Browser
        =
        Bt,
        t.Evented
        =
        E,
        t.Mixin
        =
        ne,
        t.Util
        =
        C,
        t.Class
        =
        S,
        t.Handler
        =
        ie,
        t.extend
        =
        h,
        t.bind
        =
        p,
        t.stamp
        =
        m,
        t.setOptions
        =
        c,
        t.DomEvent
        =
        qi,
        t.DomUtil
        =
        Mi,
        t.PosAnimation
        =
        Gi,
        t.Draggable
        =
        ae,
        t.LineUtil
        =
        fe,
        t.PolyUtil
        =
        ye,
        t.Point
        =
        k,
        t.point
        =
        A,
        t.Bounds
        =
        I,
        t.bounds
        =
        O,
        t.Transformation
        =
        q,
        t.transformation
        =
        G,
        t.Projection
        =
        Pe,
        t.LatLng
        =
        D,
        t.latLng
        =
        j,
        t.LatLngBounds
        =
        R,
        t.latLngBounds
        =
        N,
        t.CRS
        =
        H,
        t.GeoJSON
        =
        Ne,
        t.geoJSON
        =
        Ke,
        t.geoJson
        =
        Ye,
        t.Layer
        =
        Me,
        t.LayerGroup
        =
        ze,
        t.layerGroup
        =
        function(t,i){return new ze(t,i)},
        t.FeatureGroup
        =
        Ce,
        t.featureGroup
        =
        function(t,i){return new Ce(t,i)},
        t.ImageOverlay
        =
        Xe,
        t.imageOverlay
        =
        function(t,i,e){return new Xe(t,i,e)},
        t.VideoOverlay
        =
        Je,
        t.videoOverlay
        =
        function(t,i,e){return new Je(t,i,e)},
        t.SVGOverlay
        =
        $e,
        t.svgOverlay
        =
        function(t,i,e){return new $e(t,i,e)},
        t.DivOverlay
        =
        Qe,
        t.Popup
        =
        tn,
        t.popup
        =
        function(t,i){return new tn(t,i)},
        t.Tooltip
        =
        en,
        t.tooltip
        =
        function(t,i){return new en(t,i)},
        t.Icon
        =
        Se,
        t.icon
        =
        function(t){return new Se(t)},
        t.DivIcon
        =
        nn,
        t.divIcon
        =
        function(t){return new nn(t)},
        t.Marker
        =
        ke,
        t.marker
        =
        function(t,i){return new ke(t,i)},
        t.TileLayer
        =
        sn,
        t.tileLayer
        =
        rn,
        t.GridLayer
        =
        on,
        t.gridLayer
        =
        function(t){return new on(t)},
        t.SVG
        =
        pn,
        t.svg
        =
        mn,
        t.Renderer
        =
        hn,
        t.Canvas
        =
        un,
        t.canvas
        =
        ln,
        t.Path
        =
        Be,
        t.CircleMarker
        =
        Ae,
        t.circleMarker
        =
        function(t,i){return new Ae(t,i)},
        t.Circle
        =
        Ie,
        t.circle
        =
        function(t,i,e){return new Ie(t,i,e)},
        t.Polyline
        =
        Oe,
        t.polyline
        =
        function(t,i){return new Oe(t,i)},
        t.Polygon
        =
        Re,
        t.polygon
        =
        function(t,i){return new Re(t,i)},
        t.Rectangle
        =
        fn,
        t.rectangle
        =
        function(t,i){return new fn(t,i)},
        t.Map
        =
        Ki,
        t.map
        =
        function(t,i){return new Ki(t,i)};
        var bn=window.L;
        t.noConflict = function(){return window.L = bn,this},window.L = t})}
  (globalThis));
(function(globalThis)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {s.t & 6 && caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x){return Math.expm1(x)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    function fs_node_supported()
     {return typeof globalThis.process
             !==
             "undefined"
             &&
             typeof globalThis.process.versions
             !==
             "undefined"
             &&
             typeof globalThis.process.versions.node
             !==
             "undefined"}
    function make_path_is_absolute()
     {function posix(path)
       {if(path.charAt(0) === "/")return ["",path.substring(1)];return}
      function win32(path)
       {var
         splitDeviceRe=
          /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/,
         result=splitDeviceRe.exec(path),
         device=result[1] || "",
         isUnc=Boolean(device && device.charAt(1) !== ":");
        if(Boolean(result[2] || isUnc))
         {var root=result[1] || "",sep=result[2] || "";
          return [root,path.substring(root.length + sep.length)]}
        return}
      return fs_node_supported()
              &&
              globalThis.process
              &&
              globalThis.process.platform
              ?globalThis.process.platform === "win32"?win32:posix
              :posix}
    var path_is_absolute=make_path_is_absolute();
    function caml_trailing_slash(name)
     {return name.slice(- 1) !== "/"?name + "/":name}
    if(fs_node_supported() && globalThis.process && globalThis.process.cwd)
     var caml_current_dir=globalThis.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    caml_current_dir = caml_trailing_slash(caml_current_dir);
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(! path_is_absolute(name))name = caml_current_dir + name;
      var comp0=path_is_absolute(name),comp=comp0[1].split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         default:ncomp.push(comp[i]);break}
      ncomp.unshift(comp0[0]);
      ncomp.orig = name;
      return ncomp}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    var
     unix_error=
      ["E2BIG",
       "EACCES",
       "EAGAIN",
       "EBADF",
       "EBUSY",
       "ECHILD",
       "EDEADLK",
       "EDOM",
       "EEXIST",
       "EFAULT",
       "EFBIG",
       "EINTR",
       "EINVAL",
       "EIO",
       "EISDIR",
       "EMFILE",
       "EMLINK",
       "ENAMETOOLONG",
       "ENFILE",
       "ENODEV",
       "ENOENT",
       "ENOEXEC",
       "ENOLCK",
       "ENOMEM",
       "ENOSPC",
       "ENOSYS",
       "ENOTDIR",
       "ENOTEMPTY",
       "ENOTTY",
       "ENXIO",
       "EPERM",
       "EPIPE",
       "ERANGE",
       "EROFS",
       "ESPIPE",
       "ESRCH",
       "EXDEV",
       "EWOULDBLOCK",
       "EINPROGRESS",
       "EALREADY",
       "ENOTSOCK",
       "EDESTADDRREQ",
       "EMSGSIZE",
       "EPROTOTYPE",
       "ENOPROTOOPT",
       "EPROTONOSUPPORT",
       "ESOCKTNOSUPPORT",
       "EOPNOTSUPP",
       "EPFNOSUPPORT",
       "EAFNOSUPPORT",
       "EADDRINUSE",
       "EADDRNOTAVAIL",
       "ENETDOWN",
       "ENETUNREACH",
       "ENETRESET",
       "ECONNABORTED",
       "ECONNRESET",
       "ENOBUFS",
       "EISCONN",
       "ENOTCONN",
       "ESHUTDOWN",
       "ETOOMANYREFS",
       "ETIMEDOUT",
       "ECONNREFUSED",
       "EHOSTDOWN",
       "EHOSTUNREACH",
       "ELOOP",
       "EOVERFLOW"];
    function make_unix_err_args(code,syscall,path,errno)
     {var variant=unix_error.indexOf(code);
      if(variant < 0){if(errno == null)errno = - 9999;variant = [0,errno]}
      var
       args=
        [variant,
         caml_string_of_jsstring(syscall || ""),
         caml_string_of_jsstring(path || "")];
      return args}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_raise_with_args(tag,args){throw [0,tag].concat(args)}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(globalThis.Uint8Array)
       var a=new (globalThis.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.create_dir_if_needed
    =
    function(name)
     {var comp=name.split("/"),res="";
      for(var i=0;i < comp.length - 1;i++)
       {res += comp[i] + "/";
        if(this.content[res])continue;
        this.content[res] = Symbol("directory")}};
    MlFakeDevice.prototype.slash
    =
    function(name){return /\/$/.test(name)?name:name + "/"};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         {this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=this.slash(name);
      if(this.content[name_slash])return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {var unix_error=raise_unix && caml_named_value("Unix.Unix_error");
      if(this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("EEXIST","mkdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": File exists");
      var parent=/^(.*)\/[^/]+/.exec(name);
      parent = parent && parent[1] || "";
      if(! this.exists(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": No such file or directory");
      if(! this.is_dir(parent))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","mkdir",this.nm(parent)));
       else
        caml_raise_sys_error(parent + ": Not a directory");
      this.create_dir_if_needed(this.slash(name))};
    MlFakeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {var
       unix_error=raise_unix && caml_named_value("Unix.Unix_error"),
       name_slash=name == ""?"":this.slash(name),
       r=new RegExp("^" + name_slash + "([^/]+)");
      if(! this.exists(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOENT","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))
       if(unix_error)
        caml_raise_with_args
         (unix_error,make_unix_err_args("ENOTDIR","rmdir",this.nm(name)));
       else
        caml_raise_sys_error(name + ": Not a directory");
      for(var n in this.content)
       if(n.match(r))
        if(unix_error)
         caml_raise_with_args
          (unix_error,make_unix_err_args("ENOTEMPTY","rmdir",this.nm(name)));
        else
         caml_raise_sys_error(this.nm(name) + ": Directory not empty");
      delete this.content[name_slash]};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var name_slash=name == ""?"":this.slash(name);
      if(! this.exists(name))
       caml_raise_sys_error(name + ": No such file or directory");
      if(! this.is_dir(name))caml_raise_sys_error(name + ": Not a directory");
      var r=new RegExp("^" + name_slash + "([^/]+)"),seen={},a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {if(name == "")return true;
      var name_slash=this.slash(name);
      return this.content[name_slash]?1:0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.create_dir_if_needed(name);
         this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {var file;
      if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))file = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       file = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        file = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           file = new MlFakeFile(bytes)}
      if(file)
       {this.create_dir_if_needed(name);this.content[name] = file}
      else
       caml_raise_sys_error
        (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof globalThis.Uint8Array))
       a = new (globalThis.Uint8Array)(a);
      var buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var a=new (globalThis.Uint8Array)(1),buffer=globalThis.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try {return this.fs.existsSync(this.nm(name))?1:0}catch(err){return 0}};
    MlNodeDevice.prototype.mkdir
    =
    function(name,mode,raise_unix)
     {try
       {this.fs.mkdirSync(this.nm(name),{mode:mode});return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rmdir
    =
    function(name,raise_unix)
     {try
       {this.fs.rmdirSync(this.nm(name));return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readdir
    =
    function(name,raise_unix)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name,raise_unix)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name));
        return b}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.open
    =
    function(name,f,raise_unix)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.rename
    =
    function(o,n,raise_unix)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.stat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.statSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.lstat
    =
    function(name,raise_unix)
     {try
       {var js_stats=this.fs.lstatSync(this.nm(name));
        return this.stats_from_js(js_stats)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.symlink
    =
    function(to_dir,target,path,raise_unix)
     {try
       {this.fs.symlinkSync(this.nm(target),this.nm(path),to_dir?"dir":"file");
        return 0}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.readlink
    =
    function(name,raise_unix)
     {try
       {var link=this.fs.readlinkSync(this.nm(name),"utf8");
        return caml_string_of_jsstring(link)}
      catch(err){this.raise_nodejs_error(err,raise_unix)}};
    MlNodeDevice.prototype.raise_nodejs_error
    =
    function(err,raise_unix)
     {var unix_error=caml_named_value("Unix.Unix_error");
      if(raise_unix && unix_error)
       {var args=make_unix_err_args(err.code,err.syscall,err.path,err.errno);
        caml_raise_with_args(unix_error,args)}
      else
       caml_raise_sys_error(err.toString())};
    MlNodeDevice.prototype.stats_from_js
    =
    function(js_stats)
     {var file_kind;
      if(js_stats.isFile())
       file_kind = 0;
      else
       if(js_stats.isDirectory())
        file_kind = 1;
       else
        if(js_stats.isCharacterDevice())
         file_kind = 2;
        else
         if(js_stats.isBlockDevice())
          file_kind = 3;
         else
          if(js_stats.isSymbolicLink())
           file_kind = 4;
          else
           if(js_stats.isFIFO())
            file_kind = 5;
           else
            if(js_stats.isSocket())file_kind = 6;
      return [0,
              js_stats.dev,
              js_stats.ino,
              file_kind,
              js_stats.mode,
              js_stats.nlink,
              js_stats.uid,
              js_stats.gid,
              js_stats.rdev,
              js_stats.size,
              js_stats.atimeMs,
              js_stats.mtimeMs,
              js_stats.ctimeMs]};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    function caml_get_root(path)
     {var x=path_is_absolute(path);if(! x)return;return x[0] + "/"}
    function caml_failwith(msg)
     {if(! caml_global_data.Failure)
       caml_global_data.Failure = [248,caml_string_of_jsbytes("Failure"),- 3];
      caml_raise_with_string(caml_global_data.Failure,msg)}
    var
     caml_root=
      caml_get_root(caml_current_dir)
      ||
      caml_failwith("unable to compute caml_root"),
     jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:"/static/",device:new MlFakeDevice("/static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=caml_trailing_slash(name),
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      if(! res && fs_node_supported())
       {var root=caml_get_root(name);
        if(root && root.match(/^[a-zA-Z]:\/$/))
         {var m={path:root,device:new MlNodeDevice(root)};
          jsoo_mount_point.push(m);
          res
          =
          {path:m.path,
           device:m.device,
           rest:name.substring(m.path.length,name.length)}}}
      if(res)return res;
      caml_raise_sys_error("no device found for " + name_slash)}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=globalThis,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if(globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
       return caml_string_of_jsstring(globalThis.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof globalThis.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function(){this.objs = [];this.lookup = new (globalThis.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.log10(x)}
    function unix_unlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.unlink)caml_failwith("unix_unlink: not implemented");
      return root.device.unlink(root.rest,true)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function unix_rmdir(name)
     {var root=resolve_fs_device(name);
      if(! root.device.rmdir)caml_failwith("unix_rmdir: not implemented");
      return root.device.rmdir(root.rest,true)}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (globalThis.RangeError
        &&
        e instanceof globalThis.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (globalThis.InternalError
        &&
        e instanceof globalThis.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof globalThis.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function jsoo_create_file(name,content)
     {var
       name=caml_string_of_jsbytes(name),
       content=caml_string_of_jsbytes(content);
      return caml_create_file(name,content)}
    function caml_fs_init()
     {var tmp=globalThis.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        jsoo_create_file(tmp[i].name,tmp[i].content);
      globalThis.jsoo_create_file = jsoo_create_file;
      globalThis.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = caml_trailing_slash(root.path + root.rest);
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(caml_jsbytes_of_string(dir))}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    function unix_has_symlink(unit){return fs_node_supported()?1:0}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (globalThis.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (globalThis.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=globalThis,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (globalThis.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (globalThis.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (globalThis.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=globalThis,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=globalThis;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_erf_float(x)
     {var
       a1=0.254829592,
       a2=- 0.284496736,
       a3=1.421413741,
       a4=- 1.453152027,
       a5=1.061405429,
       p=0.3275911,
       sign=1;
      if(x < 0)sign = - 1;
      x = Math.abs(x);
      var
       t=1.0 / (1.0 + p * x),
       y=
        1.0
        -
        ((((a5 * t + a4) * t + a3) * t + a2) * t + a1)
        *
        t
        *
        Math.exp(- (x * x));
      return sign * y}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_obj_add_offset(v,offset)
     {caml_failwith("Obj.add_offset is not supported")}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function unix_getuid(unit)
     {if(globalThis.process && globalThis.process.getuid)
       return globalThis.process.getuid();
      caml_raise_not_found()}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    var
     os_type=
      globalThis.process
       &&
       globalThis.process.platform
       &&
       globalThis.process.platform
       ==
       "win32"
       ?"Cygwin"
       :"Unix";
    function caml_sys_const_ostype_cygwin(){return os_type == "Cygwin"?1:0}
    function caml_cosh_float(x){return Math.cosh(x)}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_acosh_float(x){return Math.acosh(x)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_ml_set_buffered(c,v){return 0}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (globalThis.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_log2_float(x){return Math.log2(x)}
    function caml_gc_huge_fallback_count(unit){return 0}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(caml_jsbytes_of_string(name));
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y){return Math.hypot(x,y)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_ml_bytes_content(s)
     {switch(s.t & 6)
       {default:caml_convert_string_to_bytes(s);case 0:return s.c;
        case 4:return s.c
        }}
    function caml_hash_mix_bytes(h,v)
     {var content=caml_ml_bytes_content(v);
      return typeof content === "string"
              ?caml_hash_mix_jsbytes(h,content)
              :caml_hash_mix_bytes_arr(h,content)}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_erfc_float(x){return 1 - caml_erf_float(x)}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function caml_obj_reachable_words(o){return 0}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[5] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            globalThis.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)?1:0}
      else
       return 0}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function unix_lstat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.lstat)caml_failwith("unix_lstat: not implemented");
      return root.device.lstat(root.rest,true)}
    var unix_lstat_64=unix_lstat;
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[],content=caml_ml_bytes_content(s);
           if(typeof content === "string")
            {var b=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               b.charCodeAt(j)
               |
               b.charCodeAt(j + 1)
               <<
               8
               |
               b.charCodeAt(j + 2)
               <<
               16
               |
               b.charCodeAt(j + 3)
               <<
               24}
             for(;i < len;i++)
              buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3)}
           else
            {var a=content;
             for(var i=0;i < len;i += 4)
              {var j=i + ofs;
               buf[i >> 2]
               =
               a[j]
               |
               a[j + 1]
               <<
               8
               |
               a[j + 2]
               <<
               16
               |
               a[j + 3]
               <<
               24}
             for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)}
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=globalThis;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return os_type == "Unix"?1:0}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_ba_kind_of_typed_array(ta)
     {var g=globalThis,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    function caml_is_special_exception(exn)
     {switch(exn[2]){case - 8:case - 11:case - 12:return 1;default:return 0}}
    function caml_format_exception(exn)
     {var r="";
      if(exn[0] == 0)
       {r += exn[1][1];
        if
         (exn.length
          ==
          3
          &&
          exn[2][0]
          ==
          0
          &&
          caml_is_special_exception(exn[1]))
         var bucket=exn[2],start=1;
        else
         var start=2,bucket=exn;
        r += "(";
        for(var i=start;i < bucket.length;i++)
         {if(i > start)r += ", ";
          var v=bucket[i];
          if(typeof v == "number")
           r += v.toString();
          else
           if(v instanceof MlBytes)
            r += '"' + v.toString() + '"';
           else
            if(typeof v == "string")
             r += '"' + v.toString() + '"';
            else
             r += "_"}
        r += ")"}
      else
       if(exn[0] == 248)r += exn[1];
      return r}
    function caml_fatal_uncaught_exception(err)
     {if(err instanceof Array && (err[0] == 0 || err[0] == 248))
       {var handler=caml_named_value("Printexc.handle_uncaught_exception");
        if(handler)
         handler(err,false);
        else
         {var
           msg=caml_format_exception(err),
           at_exit=caml_named_value("Pervasives.do_at_exit");
          if(at_exit)at_exit(0);
          globalThis.console.error("Fatal error: exception " + msg + "\n")}}
      else
       throw err}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_exp2_float(x){return Math.pow(2,x)}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_atanh_float(x){return Math.atanh(x)}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=globalThis;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_ml_is_buffered(c){return 1}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_eventlog_resume(unit){return 0}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           var content=caml_ml_bytes_content(obj);
           if(typeof content === "string")
            for(var b=content,l=b.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            for(var a=content,l=a.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + a[i] | 0}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function jsoo_create_file_extern(name,content)
     {if(globalThis.jsoo_create_file)
       globalThis.jsoo_create_file(name,content);
      else
       {if(! globalThis.caml_fs_tmp)globalThis.caml_fs_tmp = [];
        globalThis.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return os_type == "Win32"?1:0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {if(globalThis.crypto)
       if(typeof globalThis.crypto.getRandomValues === "function")
        {var a=new (globalThis.Uint32Array)(1);
         globalThis.crypto.getRandomValues(a);
         return [0,a[0]]}
       else
        if(globalThis.crypto.randomBytes === "function")
         {var
           buff=globalThis.crypto.randomBytes(4),
           a=new (globalThis.Uint32Array)(buff);
          return [0,a[0]]}
      var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    var win_filedescr_of_channel=caml_channel_descriptor;
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_gc_major_slice(work){return 0}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes(os_type),32,0]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_asinh_float(x){return Math.asinh(x)}
    function bigstring_of_array_buffer(ab)
     {var ta=new (globalThis.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=caml_trailing_slash(path.join("/"));
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && globalThis.toplevelReloc)
       n = globalThis.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_get_major_credit(n){return 0}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=globalThis.console?globalThis.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var refill=null;
      if(fd == 0 && fs_node_supported())
       {var fs=require("fs");
        refill
        =
        function(){return caml_string_of_jsstring(fs.readFileSync(0,"utf8"))}}
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:refill};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (globalThis.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function unix_stat(name)
     {var root=resolve_fs_device(name);
      if(! root.device.stat)caml_failwith("unix_stat: not implemented");
      return root.device.stat(root.rest,true)}
    var unix_stat_64=unix_stat;
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return Math.sinh(x)}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_gc_minor_words(unit){return 0}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function unix_readlink(name)
     {var root=resolve_fs_device(name);
      if(! root.device.readlink)
       caml_failwith("unix_readlink: not implemented");
      return root.device.readlink(root.rest,true)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c?1:0}
    function caml_get_major_bucket(n){return 0}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function unix_symlink(to_dir,src,dst)
     {var src_root=resolve_fs_device(src),dst_root=resolve_fs_device(dst);
      if(src_root.device != dst_root.device)
       caml_failwith("unix_symlink: cannot symlink between two filesystems");
      if(! src_root.device.symlink)
       caml_failwith("unix_symlink: not implemented");
      return src_root.device.symlink(to_dir,src_root.rest,dst_root.rest,true)}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x){return Math.tanh(x)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var
       path=caml_make_path(name),
       name=caml_trailing_slash(path.join("/")),
       idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (globalThis.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_sys_rmdir(name)
     {var root=resolve_fs_device(name);root.device.rmdir(root.rest);return 0}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_bytes_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_fma_float(x,y,z)
     {var
       SPLIT=Math.pow(2,27) + 1,
       MIN_VALUE=Math.pow(2,- 1022),
       EPSILON=Math.pow(2,- 52),
       C=416,
       A=Math.pow(2,+ C),
       B=Math.pow(2,- C);
      function multiply(a,b)
       {var
         at=SPLIT * a,
         ahi=at - (at - a),
         alo=a - ahi,
         bt=SPLIT * b,
         bhi=bt - (bt - b),
         blo=b - bhi,
         p=a * b,
         e=ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
        return {p:p,e:e}}
      function add(a,b)
       {var s=a + b,v=s - a,e=a - (s - v) + (b - v);return {s:s,e:e}}
      function adjust(x,y)
       {return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x
                ?x * (1 + (x < 0?- 1:+ 1) * (y < 0?- 1:+ 1) * EPSILON)
                :x}
      if
       (x
        ===
        0
        ||
        x
        !==
        x
        ||
        x
        ===
        +
        (1 / 0)
        ||
        x
        ===
        -
        (1 / 0)
        ||
        y
        ===
        0
        ||
        y
        !==
        y
        ||
        y
        ===
        +
        (1 / 0)
        ||
        y
        ===
        -
        (1 / 0))
       return x * y + z;
      if(z === 0)return x * y;
      if(z !== z || z === + (1 / 0) || z === - (1 / 0))return z;
      var scale=1;
      while(Math.abs(x) > A){scale *= A;x *= B}
      while(Math.abs(y) > A){scale *= A;y *= B}
      if(scale === 1 / 0)return x * y * scale;
      while(Math.abs(x) < B){scale *= B;x *= A}
      while(Math.abs(y) < B){scale *= B;y *= A}
      if(scale === 0)return z;
      var xs=x,ys=y,zs=z / scale;
      if(Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)return z;
      if(Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
       zs = (z < 0?- 1:+ 1) * MIN_VALUE;
      var
       xy=multiply(xs,ys),
       s=add(xy.p,zs),
       u=add(xy.e,s.e),
       i=add(s.s,u.s),
       f=i.s + adjust(i.e,u.e);
      if(f === 0)return f;
      var fs=f * scale;
      if(Math.abs(fs) > MIN_VALUE)return fs;
      return fs + adjust(f - fs / scale,i.e) * scale}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function unix_getpwuid(unit){caml_raise_not_found()}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_js_error_option_of_exception(exn)
     {if(exn.js_error)return [0,exn.js_error];return 0}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_get_minor_free(unit){return 0}
    function caml_set_static_env(k,v)
     {if(! globalThis.jsoo_static_env)globalThis.jsoo_static_env = {};
      globalThis.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function unix_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      if(! root.device.mkdir)caml_failwith("unix_mkdir: not implemented");
      return root.device.mkdir(root.rest,perm,true)}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=globalThis,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_cbrt_float(x){return Math.cbrt(x)}
    function caml_memprof_stop(unit){return 0}
    function caml_eventlog_pause(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x){return Math.log1p(x)}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var ua=globalThis.navigator?globalThis.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_install_signal_handler(){return 0}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_sys_mkdir(name,perm)
     {var root=resolve_fs_device(name);
      root.device.mkdir(root.rest,perm);
      return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(caml_jsbytes_of_string(name))}
    function caml_js_to_float(x){return x}
    function caml_setup_uncaught_exception_handler()
     {var g=globalThis;
      if(g.process && g.process.on)
       g.process.on
        ("uncaughtException",
         function(err,origin)
          {caml_fatal_uncaught_exception(err);g.process.exit(2)});
      else
       if(g.addEventListener)
        g.addEventListener
         ("error",
          function(event)
           {if(event.error)caml_fatal_uncaught_exception(event.error)})}
    caml_setup_uncaught_exception_handler();
    globalThis.jsoo_runtime
    =
    {caml_ephe_key_offset:caml_ephe_key_offset,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_weak_create:caml_weak_create,
     caml_weak_set:caml_weak_set,
     caml_weak_get:caml_weak_get,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_check:caml_weak_check,
     caml_weak_blit:caml_weak_blit,
     caml_ephe_create:caml_ephe_create,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_check_data:caml_ephe_check_data,
     unix_gettimeofday:unix_gettimeofday,
     unix_time:unix_time,
     unix_gmtime:unix_gmtime,
     unix_localtime:unix_localtime,
     unix_mktime:unix_mktime,
     win_startup:win_startup,
     win_cleanup:win_cleanup,
     win_handle_fd:win_handle_fd,
     unix_isatty:unix_isatty,
     make_unix_err_args:make_unix_err_args,
     unix_stat:unix_stat,
     unix_stat_64:unix_stat_64,
     unix_lstat:unix_lstat,
     unix_lstat_64:unix_lstat_64,
     unix_mkdir:unix_mkdir,
     unix_rmdir:unix_rmdir,
     unix_symlink:unix_symlink,
     unix_readlink:unix_readlink,
     unix_unlink:unix_unlink,
     unix_getuid:unix_getuid,
     unix_getpwuid:unix_getpwuid,
     unix_has_symlink:unix_has_symlink,
     re_match:re_match,
     re_search_forward:re_search_forward,
     re_search_backward:re_search_backward,
     re_string_match:re_string_match,
     re_partial_match:re_partial_match,
     re_replacement_text:re_replacement_text,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_sys_exit:caml_sys_exit,
     caml_is_special_exception:caml_is_special_exception,
     caml_format_exception:caml_format_exception,
     caml_fatal_uncaught_exception:caml_fatal_uncaught_exception,
     caml_set_static_env:caml_set_static_env,
     caml_sys_getenv:caml_sys_getenv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_argv:caml_argv,
     caml_executable_name:caml_executable_name,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_time:caml_sys_time,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     os_type:os_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_variant:caml_runtime_variant,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_install_signal_handler:caml_install_signal_handler,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_call_gen:caml_call_gen,
     caml_named_values:caml_named_values,
     caml_register_named_value:caml_register_named_value,
     caml_named_value:caml_named_value,
     caml_global_data:caml_global_data,
     caml_register_global:caml_register_global,
     caml_get_global_data:caml_get_global_data,
     caml_is_printable:caml_is_printable,
     caml_parse_engine:caml_parse_engine,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_update_dummy:caml_update_dummy,
     caml_obj_is_block:caml_obj_is_block,
     caml_obj_tag:caml_obj_tag,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_dup:caml_obj_dup,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_get_public_method:caml_get_public_method,
     caml_oo_last_id:caml_oo_last_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_reachable_words:caml_obj_reachable_words,
     caml_obj_add_offset:caml_obj_add_offset,
     initialize_nat:initialize_nat,
     MlNat:MlNat,
     caml_hash_nat:caml_hash_nat,
     nat_of_array:nat_of_array,
     create_nat:create_nat,
     set_to_zero_nat:set_to_zero_nat,
     blit_nat:blit_nat,
     set_digit_nat:set_digit_nat,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat_native:nth_digit_nat_native,
     num_digits_nat:num_digits_nat,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     is_digit_int:is_digit_int,
     is_digit_zero:is_digit_zero,
     is_digit_odd:is_digit_odd,
     incr_nat:incr_nat,
     add_nat:add_nat,
     complement_nat:complement_nat,
     decr_nat:decr_nat,
     sub_nat:sub_nat,
     mult_digit_nat:mult_digit_nat,
     mult_nat:mult_nat,
     square_nat:square_nat,
     shift_left_nat:shift_left_nat,
     div_helper:div_helper,
     div_digit_nat:div_digit_nat,
     div_nat:div_nat,
     shift_right_nat:shift_right_nat,
     compare_digits_nat:compare_digits_nat,
     compare_nat:compare_nat,
     compare_nat_real:compare_nat_real,
     land_digit_nat:land_digit_nat,
     lor_digit_nat:lor_digit_nat,
     lxor_digit_nat:lxor_digit_nat,
     serialize_nat:serialize_nat,
     deserialize_nat:deserialize_nat,
     caml_str_repeat:caml_str_repeat,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_get:caml_string_get,
     caml_string_get16:caml_string_get16,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get32:caml_string_get32,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get64:caml_string_get64,
     caml_bytes_get64:caml_bytes_get64,
     caml_bytes_get:caml_bytes_get,
     caml_string_set:caml_string_set,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set16:caml_string_set16,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set32:caml_string_set32,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set64:caml_string_set64,
     caml_bytes_set:caml_bytes_set,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     MlBytes:MlBytes,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_array_of_string:caml_array_of_string,
     caml_create_string:caml_create_string,
     caml_create_bytes:caml_create_bytes,
     caml_string_of_array:caml_string_of_array,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_fill_bytes:caml_fill_bytes,
     caml_fill_string:caml_fill_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_blit_string:caml_blit_string,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_compare:caml_string_compare,
     caml_string_equal:caml_string_equal,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_ml_bytes_content:caml_ml_bytes_content,
     caml_is_ml_string:caml_is_ml_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_new_string:caml_new_string,
     caml_js_from_string:caml_js_from_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_to_string:caml_js_to_string,
     caml_md5_chan:caml_md5_chan,
     caml_md5_string:caml_md5_string,
     caml_md5_bytes:caml_md5_bytes,
     caml_marshal_constants:caml_marshal_constants,
     MlStringReader:MlStringReader,
     BigStringReader:BigStringReader,
     caml_float_of_bytes:caml_float_of_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_custom_ops:caml_custom_ops,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_marshal_data_size:caml_marshal_data_size,
     MlObjectTable:MlObjectTable,
     caml_legacy_custom_code:caml_legacy_custom_code,
     caml_output_val:caml_output_val,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_lex_array:caml_lex_array,
     caml_lex_engine:caml_lex_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_get_console:caml_js_get_console,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_js_set:caml_js_set,
     caml_js_get:caml_js_get,
     caml_js_delete:caml_js_delete,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_typeof:caml_js_typeof,
     caml_trampoline:caml_trampoline,
     caml_trampoline_return:caml_trampoline_return,
     js_print_stdout:js_print_stdout,
     js_print_stderr:js_print_stderr,
     caml_is_js:caml_is_js,
     caml_wrap_exception:caml_wrap_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_js_error_option_of_exception:caml_js_error_option_of_exception,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_array:caml_js_to_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_js_var:caml_js_var,
     caml_js_call:caml_js_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_new:caml_js_new,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_equals:caml_js_equals,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_expr:caml_js_expr,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_object:caml_js_object,
     caml_sys_close:caml_sys_close,
     caml_std_output:caml_std_output,
     caml_sys_open:caml_sys_open,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_ml_channels:caml_ml_channels,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_channel_descriptor:caml_channel_descriptor,
     win_filedescr_of_channel:win_filedescr_of_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_input:caml_ml_input,
     caml_input_value:caml_input_value,
     caml_ml_input_char:caml_ml_input_char,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_flush:caml_ml_flush,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_output:caml_ml_output,
     caml_ml_output_char:caml_ml_output_char,
     caml_output_value:caml_output_value,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_is_buffered:caml_ml_is_buffered,
     caml_ml_set_buffered:caml_ml_set_buffered,
     caml_format_int:caml_format_int,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_parse_digit:caml_parse_digit,
     caml_int_of_string:caml_int_of_string,
     caml_mul:caml_mul,
     caml_div:caml_div,
     caml_mod:caml_mod,
     caml_bswap16:caml_bswap16,
     caml_int32_bswap:caml_int32_bswap,
     caml_int64_bswap:caml_int64_bswap,
     caml_int64_offset:caml_int64_offset,
     MlInt64:MlInt64,
     caml_int64_ult:caml_int64_ult,
     caml_int64_compare:caml_int64_compare,
     caml_int64_neg:caml_int64_neg,
     caml_int64_add:caml_int64_add,
     caml_int64_sub:caml_int64_sub,
     caml_int64_mul:caml_int64_mul,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_and:caml_int64_and,
     caml_int64_or:caml_int64_or,
     caml_int64_xor:caml_int64_xor,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_div:caml_int64_div,
     caml_int64_mod:caml_int64_mod,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_format:caml_int64_format,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_hash:caml_int64_hash,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_nextafter_float:caml_nextafter_float,
     caml_trunc_float:caml_trunc_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_classify_float:caml_classify_float,
     caml_modf_float:caml_modf_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_frexp_float:caml_frexp_float,
     caml_float_compare:caml_float_compare,
     caml_copysign_float:caml_copysign_float,
     caml_signbit_float:caml_signbit_float,
     caml_expm1_float:caml_expm1_float,
     caml_exp2_float:caml_exp2_float,
     caml_log1p_float:caml_log1p_float,
     caml_log2_float:caml_log2_float,
     caml_hypot_float:caml_hypot_float,
     caml_log10_float:caml_log10_float,
     caml_cosh_float:caml_cosh_float,
     caml_acosh_float:caml_acosh_float,
     caml_sinh_float:caml_sinh_float,
     caml_asinh_float:caml_asinh_float,
     caml_tanh_float:caml_tanh_float,
     caml_atanh_float:caml_atanh_float,
     caml_round_float:caml_round_float,
     caml_cbrt_float:caml_cbrt_float,
     caml_erf_float:caml_erf_float,
     caml_erfc_float:caml_erfc_float,
     caml_fma_float:caml_fma_float,
     caml_format_float:caml_format_float,
     caml_float_of_string:caml_float_of_string,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash:caml_hash,
     caml_gr_state:caml_gr_state,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gc_minor:caml_gc_minor,
     caml_gc_major:caml_gc_major,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_counters:caml_gc_counters,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_stat:caml_gc_stat,
     caml_gc_set:caml_gc_set,
     caml_gc_get:caml_gc_get,
     caml_memprof_set:caml_memprof_set,
     caml_final_register:caml_final_register,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_release:caml_final_release,
     caml_memprof_start:caml_memprof_start,
     caml_memprof_stop:caml_memprof_stop,
     caml_eventlog_resume:caml_eventlog_resume,
     caml_eventlog_pause:caml_eventlog_pause,
     caml_gc_huge_fallback_count:caml_gc_huge_fallback_count,
     caml_gc_major_slice:caml_gc_major_slice,
     caml_gc_minor_words:caml_gc_minor_words,
     caml_get_minor_free:caml_get_minor_free,
     caml_get_major_bucket:caml_get_major_bucket,
     caml_get_major_credit:caml_get_major_credit,
     fs_node_supported:fs_node_supported,
     MlNodeDevice:MlNodeDevice,
     MlNodeFile:MlNodeFile,
     MlFakeDevice:MlFakeDevice,
     MlFakeFile:MlFakeFile,
     caml_trailing_slash:caml_trailing_slash,
     caml_current_dir:caml_current_dir,
     caml_get_root:caml_get_root,
     caml_root:caml_root,
     MlFile:MlFile,
     path_is_absolute:path_is_absolute,
     caml_make_path:caml_make_path,
     jsoo_mount_point:jsoo_mount_point,
     caml_list_mount_point:caml_list_mount_point,
     resolve_fs_device:resolve_fs_device,
     caml_mount_autoload:caml_mount_autoload,
     caml_unmount:caml_unmount,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_sys_chdir:caml_sys_chdir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_rename:caml_sys_rename,
     caml_sys_mkdir:caml_sys_mkdir,
     caml_sys_rmdir:caml_sys_rmdir,
     caml_ba_map_file:caml_ba_map_file,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     jsoo_create_file_extern:jsoo_create_file_extern,
     caml_fs_init:caml_fs_init,
     caml_create_file:caml_create_file,
     jsoo_create_file:jsoo_create_file,
     caml_read_file_content:caml_read_file_content,
     caml_parse_format:caml_parse_format,
     caml_finish_formatting:caml_finish_formatting,
     caml_raise_constant:caml_raise_constant,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_raise_with_args:caml_raise_with_args,
     caml_raise_with_string:caml_raise_with_string,
     caml_failwith:caml_failwith,
     caml_invalid_argument:caml_invalid_argument,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_not_found:caml_raise_not_found,
     caml_array_bound_error:caml_array_bound_error,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val:caml_compare_val,
     caml_compare:caml_compare,
     caml_int_compare:caml_int_compare,
     caml_equal:caml_equal,
     caml_notequal:caml_notequal,
     caml_greaterequal:caml_greaterequal,
     caml_greaterthan:caml_greaterthan,
     caml_lessequal:caml_lessequal,
     caml_lessthan:caml_lessthan,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_of_typed_array:bigstring_of_typed_array,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_ba_init:caml_ba_init,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_custom_name:caml_ba_custom_name,
     Ml_Bigarray:Ml_Bigarray,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     caml_ba_compare:caml_ba_compare,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_create:caml_ba_create,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_layout:caml_ba_layout,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_dim:caml_ba_dim,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_sub:caml_ba_sub,
     caml_ba_slice:caml_ba_slice,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_hash:caml_ba_hash,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_backtrace_status:caml_backtrace_status,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_array_sub:caml_array_sub,
     caml_array_append:caml_array_append,
     caml_array_concat:caml_array_concat,
     caml_array_blit:caml_array_blit,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_set:caml_array_set,
     caml_array_get:caml_array_get,
     caml_array_fill:caml_array_fill,
     caml_check_bound:caml_check_bound,
     caml_make_vect:caml_make_vect,
     caml_make_float_vect:caml_make_float_vect,
     caml_floatarray_create:caml_floatarray_create};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),-1],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-2],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-3],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-4],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-5],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-6],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-7],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-8],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-9],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-11],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
      "Undefined_recursive_module");
    return}
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtYXAuYmMucnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJPYmplY3QiLCJnbG9iYWxUaGlzIiwidGhpcyIsImdldCIsIl9UXyIsImdsb2JhbCIsInNlbGYiLCJ0IiwiaSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJoIiwiZSIsIm4iLCJvIiwiYXJndW1lbnRzIiwicyIsInAiLCJBcnJheSIsIm0iLCJyIiwic2V0VGltZW91dCIsImEiLCJNYXRoIiwidSIsImwiLCJjIiwiXyIsImVuY29kZVVSSUNvbXBvbmVudCIsImQiLCJmIiwiRXJyb3IiLCJnIiwidiIsInkiLCJ4Iiwid2luZG93IiwidyIsIlAiLCJEYXRlIiwiYiIsIlQiLCJNIiwieiIsIkMiLCJTIiwiTCIsImNvbnNvbGUiLCJudWxsIiwiWiIsIkUiLCJrIiwiQiIsIkEiLCJJIiwiTyIsIlIiLCJOIiwiRCIsImlzTmFOIiwiaiIsIlciLCJIIiwiRiIsIlUiLCJWIiwicSIsIkciLCJLIiwiWSIsIlgiLCJKIiwiZG9jdW1lbnQiLCIkIiwiWnQiLCJRIiwidHQiLCJpdCIsImV0IiwibmF2aWdhdG9yIiwibnQiLCJrdCIsIm90Iiwic3QiLCJydCIsInBhcnNlSW50IiwiYXQiLCJodCIsInV0IiwibHQiLCJjdCIsIl90IiwiZHQiLCJwdCIsIm10IiwiZnQiLCJndCIsInZ0IiwieXQiLCJvcmllbnRhdGlvbiIsInh0Iiwid3QiLCJQdCIsIkx0IiwiYnQiLCJUdCIsIk10IiwienQiLCJDdCIsIlN0IiwiRXQiLCJCdCIsIkF0IiwiSXQiLCJPdCIsIlJ0IiwiTnQiLCJEdCIsImp0IiwiVXQiLCJSaSIsIld0IiwiSHQiLCJGdCIsIlZ0IiwicXQiLCJHdCIsIkt0IiwiWXQiLCJYdCIsIkp0IiwiJHQiLCJRdCIsInRpIiwiZmkiLCJpaSIsImVpIiwibmkiLCJvaSIsInNpIiwicmkiLCJhaSIsImhpIiwidWkiLCJsaSIsInBpIiwiUmVnRXhwIiwiY2kiLCJkaSIsIl9pIiwibWkiLCJnaSIsInZpIiwieWkiLCJ4aSIsInppIiwid2kiLCJTaSIsIlBpIiwiTGkiLCJiaSIsIlRpIiwiTWkiLCJraSIsIkNpIiwiQmkiLCJaaSIsIkVpIiwiVmkiLCJBaSIsIlVpIiwiSWkiLCJPaSIsIkZpIiwiTmkiLCJEaSIsImppIiwiV2kiLCJIaSIsInFpIiwiR2kiLCJLaSIsImNsZWFyVGltZW91dCIsIllpIiwiWGkiLCJKaSIsIiRpIiwiUWkiLCJ0ZSIsImllIiwiZWUiLCJuZSIsIm9lIiwic2UiLCJyZSIsImFlIiwiaGUiLCJVaW50OEFycmF5IiwiZGUiLCJ1ZSIsImxlIiwiX2UiLCJjZSIsInBlIiwibWUiLCJmZSIsImdlIiwidmUiLCJ5ZSIsInhlIiwid2UiLCJQZSIsIkxlIiwiYmUiLCJUZSIsIk1lIiwiemUiLCJDZSIsIlNlIiwiWmUiLCJFZSIsImtlIiwiQmUiLCJBZSIsIkllIiwiT2UiLCJSZSIsIk5lIiwiRGUiLCJxZSIsIldlIiwiamUiLCJIZSIsIkZlIiwiVWUiLCJWZSIsIkdlIiwiS2UiLCJZZSIsIlhlIiwiSmUiLCIkZSIsIlFlIiwidG4iLCJlbiIsIm5uIiwiRWxlbWVudCIsIm9uIiwiaXNGaW5pdGUiLCJOdW1iZXIiLCJzbiIsInJuIiwiYW4iLCJwYXJzZUZsb2F0IiwiaG4iLCJ1biIsImxuIiwiY24iLCJfbiIsImRuIiwicG4iLCJtbiIsImZuIiwiZ24iLCJ2biIsInluIiwieG4iLCJ3biIsIlBuIiwiTG4iLCJibiIsImNhbWxfaW50NjRfaXNfemVybyIsImNhbWxfc3RyX3JlcGVhdCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiY2FtbF9yYWlzZV9jb25zdGFudCIsInRhZyIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwieGhpIiwic2lnbiIsIm9mZnNldCIsIm1vZHVsdXMiLCJkaXZpc29yIiwicXVvdGllbnQiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImxlbiIsIlN0cmluZyIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX2FyZyIsImFyZyIsImpzb29faXNfYXNjaWkiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJjMSIsImMyIiwiTWxCeXRlcyIsImNvbnRlbnRzIiwibGVuZ3RoIiwiY29udGVudCIsImNhbWxfYnl0ZXNfb2ZfanNieXRlcyIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIiwibXNnIiwiY2FtbF9pbnZhbGlkX2FyZ3VtZW50IiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiYnVmZmVyIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwiY2FtbF9leHBtMV9mbG9hdCIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJtYWtlX3BhdGhfaXNfYWJzb2x1dGUiLCJwb3NpeCIsInBhdGgiLCJ3aW4zMiIsInNwbGl0RGV2aWNlUmUiLCJyZXN1bHQiLCJkZXZpY2UiLCJpc1VuYyIsIkJvb2xlYW4iLCJyb290Iiwic2VwIiwicGF0aF9pc19hYnNvbHV0ZSIsImNhbWxfdHJhaWxpbmdfc2xhc2giLCJuYW1lIiwiY2FtbF9jdXJyZW50X2RpciIsImNhbWxfbWFrZV9wYXRoIiwiY29tcDAiLCJjb21wIiwibmNvbXAiLCJjYW1sX3V0Zjhfb2ZfdXRmMTYiLCJjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIiwiY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmciLCJ1bml4X2Vycm9yIiwibWFrZV91bml4X2Vycl9hcmdzIiwiY29kZSIsInN5c2NhbGwiLCJlcnJubyIsInZhcmlhbnQiLCJhcmdzIiwiY2FtbF9uYW1lZF92YWx1ZXMiLCJjYW1sX25hbWVkX3ZhbHVlIiwibm0iLCJjYW1sX3JhaXNlX3dpdGhfYXJncyIsImNhbWxfaXNfbWxfYnl0ZXMiLCJjYW1sX2lzX21sX3N0cmluZyIsImNhbWxfYnl0ZXNfb2ZfYXJyYXkiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiY2FtbF9ibGl0X2J5dGVzIiwiczEiLCJpMSIsInMyIiwiaTIiLCJjYW1sX2JsaXRfc3RyaW5nIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJyZXMiLCJTeW1ib2wiLCJuYW1lX3NsYXNoIiwibW9kZSIsInJhaXNlX3VuaXgiLCJwYXJlbnQiLCJzZWVuIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9ieXRlc19zZXQiLCJNbE5vZGVGaWxlIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsImpzX3N0YXRzIiwidG9fZGlyIiwidGFyZ2V0IiwibGluayIsImZpbGVfa2luZCIsImNhbWxfZ2V0X3Jvb3QiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9yb290IiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJ1bmRlZmluZWQiLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsImNhbWxfZ3Jfc3RhdGUiLCJjYW1sX2dyX3N0YXRlX2dldCIsImNhbWxfZ3JfcG9pbnRfY29sb3IiLCJpbSIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwidW5peF91bmxpbmsiLCJjYW1sX3J1bnRpbWVfd2FybmluZ3MiLCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwiYm9vbCIsImNhbWxfY2xhc3NpZnlfZmxvYXQiLCJ1bml4X3JtZGlyIiwiY2FtbF9tbF9yZWZpbGxfaW5wdXQiLCJjaGFuIiwic3RyIiwic3RyX2xlbiIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX21heV9yZWZpbGxfaW5wdXQiLCJjaGFuaWQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjYW1sX2djX21pbm9yIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiYSIsImkwIiwib2ZzIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJ3cml0ZXIiLCJzaXplcyIsImNhbWxfYmFfbnVtX2RpbXMiLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jcmVhdGVfZmlsZSIsImpzb29fY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJ1bml4X2dldHRpbWVvZmRheSIsImNhbWxfbXVsIiwiY2FtbF9oYXNoX21peF9pbnQiLCJudW1fZGlnaXRzX25hdCIsIm5hdCIsImNhbWxfaGFzaF9uYXQiLCJjYW1sX2NhbGxfZ2VuIiwiYXJnc0xlbiIsImV4dHJhX2FyZ3MiLCJuYXJncyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3N5c19jaGRpciIsImRpciIsImNhbWxfZ2NfY291bnRlcnMiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwidW5peF9oYXNfc3ltbGluayIsInVuaXQiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsImludDMyYSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwicjMiLCJyMiIsInIxIiwiY2FtbF9iYV9zZXJpYWxpemUiLCJzeiIsImNvbXBsZXgiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50Iiwia2luZCIsImNhbWxfYmFfY3JlYXRlX2J1ZmZlciIsInNpemUiLCJ2aWV3IiwiZGF0YSIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsIk5hTiIsImNhbWxfYmFfZ2V0X3NpemUiLCJkaW1zIiwibl9kaW1zIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJjYW1sX2JhX2N1c3RvbV9uYW1lIiwiTWxfQmlnYXJyYXkiLCJsYXlvdXQiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwiY2FtbF9pbnQzMl91bm1hcnNoYWwiLCJjYW1sX25hdGl2ZWludF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X3VubWFyc2hhbCIsImNhbWxfaW50NjRfY29tcGFyZSIsImNhbWxfaW50NjRfaGFzaCIsImNhbWxfY3VzdG9tX29wcyIsImNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSIsImNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbSIsIm51bSIsImN1c3RvbSIsInN3YXAiLCJjYW1sX2NvbXBhcmVfdmFsX3RhZyIsImNhbWxfaW50X2NvbXBhcmUiLCJjYW1sX2J5dGVzX2NvbXBhcmUiLCJjYW1sX3N0cmluZ19jb21wYXJlIiwiY2FtbF9jb21wYXJlX3ZhbCIsInN0YWNrIiwidGFnX2EiLCJ0YWdfYiIsImNhbWxfZ3JlYXRlcnRoYW4iLCJkaXZfaGVscGVyIiwiZGl2X2RpZ2l0X25hdCIsIm5hdHEiLCJvZnNxIiwibmF0ciIsIm9mc3IiLCJyZW0iLCJudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQiLCJzaGlmdF9sZWZ0X25hdCIsIk1sTmF0IiwiY3JlYXRlX25hdCIsImFyciIsInNldF90b196ZXJvX25hdCIsImluY3JfbmF0IiwiY2FycnlfaW4iLCJjYXJyeSIsImFkZF9uYXQiLCJsZW4yIiwibmF0X29mX2FycmF5IiwibXVsdF9kaWdpdF9uYXQiLCJuYXQzIiwib2ZzMyIsIngxIiwieDIiLCJ4MyIsImRlY3JfbmF0IiwiYm9ycm93Iiwic3ViX25hdCIsImNvbXBhcmVfbmF0IiwiZGl2X25hdCIsInF1byIsImNhbWxfYmFfYmxpdCIsInNyYyIsImRzdCIsImlzX2RpZ2l0X2ludCIsImNhbWxfaW50NjRfZGl2IiwiY2FtbF9qc19odG1sX2VudGl0aWVzIiwiZW50aXR5IiwidGVtcCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsImV2YWwiLCJzZXJpYWxpemVfbmF0IiwiY2FtbF9tZW1wcm9mX3NldCIsIl9jb250cm9sIiwiY2FtbF9zeXNfZXhpdCIsImNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yIiwiY2FtbF9qc19mcm9tX2FycmF5IiwiY2FtbF9iYV9yZXNoYXBlIiwidmluZCIsIm5ld19kaW0iLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX3NldF9vb19pZCIsImNhbWxfZ3JfZmlsbF9yZWN0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwicG9zMSIsImJhMiIsInBvczIiLCJzbGljZSIsImNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZSIsImpzbmFtZSIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX25ld19zdHJpbmciLCJjYW1sX2VyZl9mbG9hdCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCIsImNhbWxfb2JqX2Jsb2NrIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImJpZ3N0cmluZ190b19hcnJheV9idWZmZXIiLCJicyIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9vYmpfYWRkX29mZnNldCIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2dyX3Bsb3QiLCJjb2xvciIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsInN0YXRlIiwiYmFzZSIsImJhY2t0cmsiLCJ1bml4X2dldHVpZCIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfYXJyYXlfc3ViIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfZ3Jfc2l6ZV94IiwiY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyIsIm9zX3R5cGUiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX2VwaGVfY2hlY2tfa2V5IiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9hY29zaF9mbG9hdCIsImNhbWxfbWxfZmx1c2giLCJvdXRwdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiY2FtbF9qc19nZXQiLCJjYW1sX21sX3NldF9idWZmZXJlZCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJ3aW5fY2xlYW51cCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9sb2cyX2Zsb2F0IiwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9tbF9ieXRlc19jb250ZW50IiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2VyZmNfZmxvYXQiLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9ncl9kaXNwbGF5X21vZGUiLCJjYW1sX29ial9yZWFjaGFibGVfd29yZHMiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9hcnJheV9ibGl0IiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJjYW1sX3N5c19nZXRjd2QiLCJjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIiwiY2FtbF9saXN0X3RvX2pzX2FycmF5IiwiY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUiLCJjYW1sX291dHB1dF92YWwiLCJXcml0ZXIiLCJ2YWx1ZSIsImZsYWdzIiwibm9fc2hhcmluZyIsImNsb3N1cmVzIiwiaW50ZXJuX29ial90YWJsZSIsIm1lbW8iLCJleGlzdGluZ19vZmZzZXQiLCJleHRlcm5fcmVjIiwib3BzIiwic3pfMzJfNjQiLCJoZWFkZXJfcG9zIiwib2xkX3BvcyIsInR5cGVfb2ZfdiIsImNhbWxfc3RyaW5nX29mX2FycmF5IiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIiwiY2FtbF9yYWlzZV9ub3RfYV9kaXIiLCJjYW1sX3N5c19zeXN0ZW1fY29tbWFuZCIsImNtZCIsInVuaXhfaXNhdHR5IiwiZmlsZURlc2NyaXB0b3IiLCJ0dHkiLCJjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbiIsImRlc2VyaWFsaXplX25hdCIsImluaXRpYWxpemVfbmF0IiwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyIsInVuaXhfbHN0YXQiLCJ1bml4X2xzdGF0XzY0IiwianNfcHJpbnRfc3Rkb3V0IiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSIsImNhbWxfbWQ1X2J5dGVzIiwiYWRkIiwieHgiLCJmZiIsImdnIiwiaGgiLCJtZDUiLCJjYW1sX2JhX3NldF9nZW5lcmljIiwiY2FtbF9lcGhlX3NldF9rZXkiLCJjYW1sX2J5dGVzX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2xlc3NlcXVhbCIsImNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbCIsImNhbWxfaW50NjRfYWRkIiwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXQiLCJiaXRzIiwib25lIiwiY2FtbF9ncl9zaXplX3kiLCJjYW1sX21sX3Bvc19pbiIsImNhbWxfaW50NjRfYW5kIiwiY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIiwiY2FtbF9zdGRfb3V0cHV0Iiwic2xlbiIsImpzX3ByaW50X3N0ZGVyciIsImNhbWxfc3lzX29wZW5faW50ZXJuYWwiLCJpZHgiLCJpbmZvIiwiY2FtbF9zeXNfb3BlbiIsIl9wZXJtcyIsIk1sU3RyaW5nUmVhZGVyIiwiY2FtbF9mbG9hdF9vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIiLCJfbWFnaWMiLCJfYmxvY2tfbGVuIiwibnVtX29iamVjdHMiLCJfc2l6ZV8zMiIsIl9zaXplXzY0Iiwib2JqX2NvdW50ZXIiLCJpbnRlcm5fcmVjIiwiaGVhZGVyIiwiZXhwZWN0ZWRfc2l6ZSIsImNhbWxfc3RyaW5nX29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIiwiY2FtbF9zdHJpbmdfZ2V0IiwicmVfbWF0Y2giLCJyZV93b3JkX2xldHRlcnMiLCJvcGNvZGVzIiwiaXNfd29yZF9sZXR0ZXIiLCJpbl9iaXRzZXQiLCJyZV9tYXRjaF9pbXBsIiwicGFydGlhbCIsInByb2ciLCJjcG9vbCIsIm5vcm10YWJsZSIsIm51bWdyb3VwcyIsIm51bXJlZ2lzdGVycyIsInN0YXJ0Y2hhcnMiLCJwYyIsInF1aXQiLCJncm91cHMiLCJyZV9yZWdpc3RlciIsImJhY2t0cmFjayIsIml0ZW0iLCJwdXNoIiwiYWNjZXB0IiwicHJlZml4X21hdGNoIiwib3AiLCJzYXJnIiwidWFyZyIsImdyb3VwIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9ncl9zZXRfbGluZV93aWR0aCIsImNhbWxfZ3Jfc2V0X2ZvbnQiLCJjYW1sX2dyX3NldF9jb2xvciIsImNvbnZlcnQiLCJudW1iZXIiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJ0YSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiY2FtbF9ncl9saW5ldG8iLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2JhX2RpbV8zIiwiY2FtbF9pc19zcGVjaWFsX2V4Y2VwdGlvbiIsImNhbWxfZm9ybWF0X2V4Y2VwdGlvbiIsImJ1Y2tldCIsInN0YXJ0IiwiY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb24iLCJoYW5kbGVyIiwiYXRfZXhpdCIsImNhbWxfZXBoZV9kYXRhX29mZnNldCIsImNhbWxfZXBoZV9jaGVja19kYXRhIiwiY2FtbF9ieXRlc19nZXQxNiIsImNhbWxfb2JqX21ha2VfZm9yd2FyZCIsImNhbWxfanNfZnJvbV9ib29sIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lIiwiY2FtbF9leHAyX2Zsb2F0IiwiY2FtbF9ncl9jbG9zZV9ncmFwaCIsImNhbWxfY3JlYXRlX3N0cmluZyIsImNhbWxfbWQ1X3N0cmluZyIsImNhbWxfbWQ1X2NoYW4iLCJjaGFuX2xlbiIsImNhbWxfb2JqX2R1cCIsImNhbWxfd2Vha19nZXRfY29weSIsImNhbWxfYXRhbmhfZmxvYXQiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfbWxfaXNfYnVmZmVyZWQiLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfanNfZXhwciIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfZXZlbnRsb2dfcmVzdW1lIiwiY2FtbF9oYXNoX3VuaXZfcGFyYW0iLCJjb3VudCIsImxpbWl0Iiwib2JqIiwiaGFzaF9hY2N1IiwiaGFzaF9hdXgiLCJqc2J5dGVzIiwiY2FtbF9zdHJpbmdfZXF1YWwiLCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIiLCJyZV9yZXBsYWNlbWVudF90ZXh0IiwicmVwbCIsIm9yaWciLCJjdXIiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMiLCJiYTEiLCJieXRlczIiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwianNvb19jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX3RvX2pzX3N0cmluZyIsImNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSIsImNhbWxfcGFyc2VfZGlnaXQiLCJjYW1sX2ludDY0X29mX3N0cmluZyIsImJhc2U2NCIsInRocmVzaG9sZCIsInJlX3NlYXJjaF9mb3J3YXJkIiwiY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX21ha2VfdmVjdCIsImluaXQiLCJjYW1sX21sX3NlZWtfaW4iLCJjYW1sX3N5c19yZWFkX2RpcmVjdG9yeSIsImNhbWxfbWxfb3V0cHV0X2NoYXIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIiLCJjYW1sX29ial9pc19ibG9jayIsImNhbWxfbWxfaW5wdXRfY2hhciIsImNhbWxfb2JqX3NldF9yYXdfZmllbGQiLCJjYW1sX2pzX3ZhciIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX2VwaGVfYmxpdF9kYXRhIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2VxdWFsIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwiYnVmZiIsIm5vdyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJ3aW5fZmlsZWRlc2NyX29mX2NoYW5uZWwiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjdHgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9nY19tYWpvcl9zbGljZSIsIndvcmsiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3dhaXRfZXZlbnQiLCJfZXZsIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJ1bml4X2dtdGltZSIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsImNhbWxfc3lzX2dldF9jb25maWciLCJ1bml4X3RpbWUiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwiY2FtbF9hc2luaF9mbG9hdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9zeXNfdW5zYWZlX2dldGVudiIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwicmVmaWxsIiwiZnMiLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsInVuaXhfc3RhdCIsInVuaXhfc3RhdF82NCIsImNhbWxfb2pzX25ld19hcnIiLCJjb21wbGVtZW50X25hdCIsImNhbWxfanNfcmVnZXhwcyIsImNhbWxfanNfaHRtbF9lc2NhcGUiLCJjYW1sX2JhX2RpbV8yIiwiY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zaW5oX2Zsb2F0IiwiY2FtbF9sZGV4cF9mbG9hdCIsImNhbWxfZ3Jfc3RhdGVfc2V0IiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCIsImFyaXR5IiwiY2FtbF9nY19taW5vcl93b3JkcyIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJ1bml4X3JlYWRsaW5rIiwiY2FtbF9vYmpfc2V0X3RhZyIsImNhbWxfaW50MzJfYnN3YXAiLCJ3aW5fc3RhcnR1cCIsImNhbWxfYmFfc2V0XzMiLCJjYW1sX2pzX2luc3RhbmNlb2YiLCJjYW1sX2dldF9tYWpvcl9idWNrZXQiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsImNhbWxfc3RyaW5nX3NldDY0IiwiY2FtbF9ncl9zdGF0ZV9jcmVhdGUiLCJjYW52YXMiLCJjb250ZXh0IiwiY2FtbF9qc193cmFwX2NhbGxiYWNrIiwiY2FtbF9ncl9kcmF3X2FyYyIsImNhbWxfYmFfbWFwX2ZpbGUiLCJ2ZmQiLCJzaGFyZWQiLCJjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlIiwiYXJnbiIsInVuaXhfc3ltbGluayIsInNyY19yb290IiwiZHN0X3Jvb3QiLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9zeXNfcm1kaXIiLCJjYW1sX21sX3Bvc19vdXQiLCJjYW1sX3NwYWNldGltZV9lbmFibGVkIiwiY2FtbF9ieXRlc19ub3RlcXVhbCIsImNhbWxfcnVudGltZV9wYXJhbWV0ZXJzIiwiY2FtbF9qc19vYmplY3QiLCJjYW1sX2JhX2NyZWF0ZSIsImRpbXNfbWwiLCJjYW1sX3dlYWtfYmxpdCIsImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSIsImNhbWxfZm1hX2Zsb2F0IiwiU1BMSVQiLCJNSU5fVkFMVUUiLCJFUFNJTE9OIiwibXVsdGlwbHkiLCJhaGkiLCJhbG8iLCJiaGkiLCJibG8iLCJhZGp1c3QiLCJzY2FsZSIsInhzIiwieXMiLCJ6cyIsInh5IiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiY2FtbF9jaGVja19ib3VuZCIsInVuaXhfZ2V0cHd1aWQiLCJjYW1sX2hhc2hfbWl4X3N0cmluZyIsImNhbWxfaGFzaCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJjYW1sX29ial90YWciLCJGdW5jdGlvbiIsImNhbWxfYmFfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImNhbWxfc3RyaW5nX2dldDY0IiwiY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uIiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3ciLCJjYW1sX2Zsb2F0YXJyYXlfYmxpdCIsImNhbWxfZ2V0X21pbm9yX2ZyZWUiLCJjYW1sX3NldF9zdGF0aWNfZW52IiwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0IiwiY2FtbF9qc19uZXciLCJ1bml4X21rZGlyIiwicGVybSIsImNhbWxfZ3JfY3VycmVudF95IiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9vYmpfdHJ1bmNhdGUiLCJjYW1sX2pzX3RvX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX29wZW5fZ3JhcGgiLCJzcGVjcyIsInN0YXR1cyIsIndpbiIsImRvYyIsInRpdGxlIiwiYm9keSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9jYnJ0X2Zsb2F0IiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2V2ZW50bG9nX3BhdXNlIiwiY2FtbF9ncmVhdGVyZXF1YWwiLCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSIsImNhbWxfbG9nMXBfZmxvYXQiLCJjYW1sX2ludDY0X29yIiwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZCIsImxvcl9kaWdpdF9uYXQiLCJjYW1sX2dyX2JsaXRfaW1hZ2UiLCJpbTIiLCJjYW1sX2dyX3dpbmRvd19pZCIsImNhbWxfanNfb25faWUiLCJ1YSIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHQiLCJjYW1sX2JhX2xheW91dCIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIiwiY2FtbF9hcnJheV9zZXQiLCJuZXd2YWwiLCJjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbCIsInNldF9kaWdpdF9uYXQiLCJjYW1sX2dyX2RvY19vZl9zdGF0ZSIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsImxvb3AiLCJ0ZXN0c2hpZnQiLCJzaGlmdCIsInNoaWZ0X3JlY292ZXIiLCJyZWR1Y2UiLCJSRUFEX1RPS0VOIiwiUkFJU0VfUEFSU0VfRVJST1IiLCJHUk9XX1NUQUNLU18xIiwiR1JPV19TVEFDS1NfMiIsIkNPTVBVVEVfU0VNQU5USUNfQUNUSU9OIiwiQ0FMTF9FUlJPUl9GVU5DVElPTiIsImVudl9zX3N0YWNrIiwiZW52X3Zfc3RhY2siLCJlbnZfc3ltYl9zdGFydF9zdGFjayIsImVudl9zeW1iX2VuZF9zdGFjayIsImVudl9zdGFja3NpemUiLCJlbnZfc3RhY2tiYXNlIiwiZW52X2N1cnJfY2hhciIsImVudl9sdmFsIiwiZW52X3N5bWJfc3RhcnQiLCJlbnZfc3ltYl9lbmQiLCJlbnZfYXNwIiwiZW52X3J1bGVfbGVuIiwiZW52X3J1bGVfbnVtYmVyIiwiZW52X3NwIiwiZW52X3N0YXRlIiwiZW52X2VycmZsYWciLCJ0YmxfdHJhbnNsX2NvbnN0IiwidGJsX3RyYW5zbF9ibG9jayIsInRibF9saHMiLCJ0YmxfbGVuIiwidGJsX2RlZnJlZCIsInRibF9kZ290byIsInRibF9zaW5kZXgiLCJ0YmxfcmluZGV4IiwidGJsX2dpbmRleCIsInRibF90YWJsZXNpemUiLCJ0YmxfdGFibGUiLCJ0YmxfY2hlY2siLCJuMSIsIm4yIiwic3RhdGUxIiwic3AiLCJlcnJmbGFnIiwiYXNwIiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N5c19ta2RpciIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfZ3JfbWFrZV9pbWFnZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwib3JpZ2luIiwiZXZlbnQiXSwic291cmNlcyI6WyIiLCIvVXNlcnMvYnVzYXlvYmFtaWdiYWRlLy5vcGFtLzQuMTQuMC9saWIvbGVhZmxldC9sZWFmbGV0LmpzIiwiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK2ZzX25vZGUuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rdW5peC5qcyIsIi9idWlsdGluLytzeXMuanMiLCIvYnVpbHRpbi8rZnNfZmFrZS5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytiaWdhcnJheS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytwYXJzaW5nLmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLythcnJheS5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLWNzdHJ1Y3QuanMiXSwibWFwcGluZ3MiOiI7Q0FDQyxTQUFVQTtXQUNGQzs7OztLQUNMQztPQUNFO1FBQ0M7VUFBc0JGLDhDQUVoQkc7UUFDSEM7SUFFUixTQUFTRDtNQUNQLElBQUlFLE9BQVNILFFBQVFJO01BQ3JCRCxvQkFBb0JBO2FBQ2JMLG9CQUNULENBYkQ7R0FjQ0E7OztJQ1hELFNBQVNPLEVBQUVDOzBCQUFvQkMsaUNBQTZCQztTQUFPLEVBQUVEOzhCQUE0QkUsVUFBUUE7V0FBVyxtQkFBbUJIO1dBQUcsRUFBRUQsU0FBNUk7TUFBcUpMO2VBQWNLOztRQUFnQixTQUFTSyxFQUFFTDtVQUFHLFFBQVFDLEVBQUVLLEVBQUcsSUFBSSxFQUFDRyxpQkFBaUJGLElBQUVDLEVBQUVEO1dBQUksSUFBSU4sS0FBS0ssSUFBRUcsVUFBVUYsR0FBR1AsRUFBRUMsS0FBR0ssRUFBRUw7VUFBRyxPQUFPRCxDQUFDO1FBQUMsSUFBSVUsRUFBRWpCLDBCQUF3Qk8sR0FBRyxPQUFPQyxjQUFZRCxNQUFNQyxHQUFyQztRQUF3QyxTQUFTQSxJQUFJO1FBQUMsU0FBU1UsRUFBRVgsRUFBRUM7VUFBRyxJQUFJSyxFQUFFTTtVQUFzQixHQUFHWixPQUFPLE9BQU8sYUFBYUEsRUFBRSxPQUFPUztVQUFuRSxJQUFxRkYsRUFBRSxPQUFPRTtVQUFhO1lBQWtCLE9BQU8sUUFBUVIsRUFBRU0sU0FBUyxTQUFTLE9BQU9FLFlBQVlBLFVBQWpFLENBQTRF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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1UiLCJzb3VyY2VzQ29udGVudCI6W251bGwsIi8qIEBwcmVzZXJ2ZVxuICogTGVhZmxldCAxLjcuMSwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLiBodHRwOi8vbGVhZmxldGpzLmNvbVxuICogKGMpIDIwMTAtMjAxOSBWbGFkaW1pciBBZ2Fmb25raW4sIChjKSAyMDEwLTIwMTEgQ2xvdWRNYWRlXG4gKi9cbiFmdW5jdGlvbih0LGkpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2koZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGkpOmkodC5MPXt9KX0odGhpcyxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBoKHQpe2Zvcih2YXIgaSxlLG49MSxvPWFyZ3VtZW50cy5sZW5ndGg7bjxvO24rKylmb3IoaSBpbiBlPWFyZ3VtZW50c1tuXSl0W2ldPWVbaV07cmV0dXJuIHR9dmFyIHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCl7cmV0dXJuIGkucHJvdG90eXBlPXQsbmV3IGl9O2Z1bmN0aW9uIGkoKXt9ZnVuY3Rpb24gcCh0LGkpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZTtpZih0LmJpbmQpcmV0dXJuIHQuYmluZC5hcHBseSh0LGUuY2FsbChhcmd1bWVudHMsMSkpO3ZhciBuPWUuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkoaSxuLmxlbmd0aD9uLmNvbmNhdChlLmNhbGwoYXJndW1lbnRzKSk6YXJndW1lbnRzKX19dmFyIGU9MDtmdW5jdGlvbiBtKHQpe3JldHVybiB0Ll9sZWFmbGV0X2lkPXQuX2xlYWZsZXRfaWR8fCsrZSx0Ll9sZWFmbGV0X2lkfWZ1bmN0aW9uIG4odCxpLGUpe3ZhciBuLG8scz1mdW5jdGlvbigpe249ITEsbyYmKHIuYXBwbHkoZSxvKSxvPSExKX0scj1mdW5jdGlvbigpe24/bz1hcmd1bWVudHM6KHQuYXBwbHkoZSxhcmd1bWVudHMpLHNldFRpbWVvdXQocyxpKSxuPSEwKX07cmV0dXJuIHJ9ZnVuY3Rpb24gbyh0LGksZSl7dmFyIG49aVsxXSxvPWlbMF0scz1uLW87cmV0dXJuIHQ9PT1uJiZlP3Q6KCh0LW8pJXMrcyklcytvfWZ1bmN0aW9uIGEoKXtyZXR1cm4hMX1mdW5jdGlvbiByKHQsaSl7dmFyIGU9TWF0aC5wb3coMTAsdm9pZCAwPT09aT82OmkpO3JldHVybiBNYXRoLnJvdW5kKHQqZSkvZX1mdW5jdGlvbiB1KHQpe3JldHVybiB0LnRyaW0/dC50cmltKCk6dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHUodCkuc3BsaXQoL1xccysvKX1mdW5jdGlvbiBjKHQsaSl7Zm9yKHZhciBlIGluIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwib3B0aW9uc1wiKXx8KHQub3B0aW9ucz10Lm9wdGlvbnM/cyh0Lm9wdGlvbnMpOnt9KSxpKXQub3B0aW9uc1tlXT1pW2VdO3JldHVybiB0Lm9wdGlvbnN9ZnVuY3Rpb24gXyh0LGksZSl7dmFyIG49W107Zm9yKHZhciBvIGluIHQpbi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChlP28udG9VcHBlckNhc2UoKTpvKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQodFtvXSkpO3JldHVybihpJiYtMSE9PWkuaW5kZXhPZihcIj9cIik/XCImXCI6XCI/XCIpK24uam9pbihcIiZcIil9dmFyIGQ9L1xceyAqKFtcXHdfLV0rKSAqXFx9L2c7ZnVuY3Rpb24gZih0LG4pe3JldHVybiB0LnJlcGxhY2UoZCxmdW5jdGlvbih0LGkpe3ZhciBlPW5baV07aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWx1ZSBwcm92aWRlZCBmb3IgdmFyaWFibGUgXCIrdCk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGU9ZShuKSksZX0pfXZhciBnPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX07ZnVuY3Rpb24gdih0LGkpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZV09PT1pKXJldHVybiBlO3JldHVybi0xfXZhciB5PVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBRC9BQ3dBQUFBQUFRQUJBQUFDQURzPVwiO2Z1bmN0aW9uIHgodCl7cmV0dXJuIHdpbmRvd1tcIndlYmtpdFwiK3RdfHx3aW5kb3dbXCJtb3pcIit0XXx8d2luZG93W1wibXNcIit0XX12YXIgdz0wO2Z1bmN0aW9uIFAodCl7dmFyIGk9K25ldyBEYXRlLGU9TWF0aC5tYXgoMCwxNi0oaS13KSk7cmV0dXJuIHc9aStlLHdpbmRvdy5zZXRUaW1lb3V0KHQsZSl9dmFyIGI9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8eChcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiKXx8UCxUPXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZXx8eChcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCIpfHx4KFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpfHxmdW5jdGlvbih0KXt3aW5kb3cuY2xlYXJUaW1lb3V0KHQpfTtmdW5jdGlvbiBNKHQsaSxlKXtpZighZXx8YiE9PVApcmV0dXJuIGIuY2FsbCh3aW5kb3cscCh0LGkpKTt0LmNhbGwoaSl9ZnVuY3Rpb24geih0KXt0JiZULmNhbGwod2luZG93LHQpfXZhciBDPXtleHRlbmQ6aCxjcmVhdGU6cyxiaW5kOnAsbGFzdElkOmUsc3RhbXA6bSx0aHJvdHRsZTpuLHdyYXBOdW06byxmYWxzZUZuOmEsZm9ybWF0TnVtOnIsdHJpbTp1LHNwbGl0V29yZHM6bCxzZXRPcHRpb25zOmMsZ2V0UGFyYW1TdHJpbmc6Xyx0ZW1wbGF0ZTpmLGlzQXJyYXk6ZyxpbmRleE9mOnYsZW1wdHlJbWFnZVVybDp5LHJlcXVlc3RGbjpiLGNhbmNlbEZuOlQscmVxdWVzdEFuaW1GcmFtZTpNLGNhbmNlbEFuaW1GcmFtZTp6fTtmdW5jdGlvbiBTKCl7fVMuZXh0ZW5kPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGkoKXt0aGlzLmluaXRpYWxpemUmJnRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5jYWxsSW5pdEhvb2tzKCl9dmFyIGU9aS5fX3N1cGVyX189dGhpcy5wcm90b3R5cGUsbj1zKGUpO2Zvcih2YXIgbyBpbihuLmNvbnN0cnVjdG9yPWkpLnByb3RvdHlwZT1uLHRoaXMpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsbykmJlwicHJvdG90eXBlXCIhPT1vJiZcIl9fc3VwZXJfX1wiIT09byYmKGlbb109dGhpc1tvXSk7cmV0dXJuIHQuc3RhdGljcyYmKGgoaSx0LnN0YXRpY3MpLGRlbGV0ZSB0LnN0YXRpY3MpLHQuaW5jbHVkZXMmJihmdW5jdGlvbih0KXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgTHx8IUx8fCFMLk1peGluKXJldHVybjt0PWcodCk/dDpbdF07Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspdFtpXT09PUwuTWl4aW4uRXZlbnRzJiZjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkIGluY2x1ZGUgb2YgTC5NaXhpbi5FdmVudHM6IHRoaXMgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcywgcGxlYXNlIGluaGVyaXQgZnJvbSBMLkV2ZW50ZWQgaW5zdGVhZC5cIiwobmV3IEVycm9yKS5zdGFjayl9KHQuaW5jbHVkZXMpLGguYXBwbHkobnVsbCxbbl0uY29uY2F0KHQuaW5jbHVkZXMpKSxkZWxldGUgdC5pbmNsdWRlcyksbi5vcHRpb25zJiYodC5vcHRpb25zPWgocyhuLm9wdGlvbnMpLHQub3B0aW9ucykpLGgobix0KSxuLl9pbml0SG9va3M9W10sbi5jYWxsSW5pdEhvb2tzPWZ1bmN0aW9uKCl7aWYoIXRoaXMuX2luaXRIb29rc0NhbGxlZCl7ZS5jYWxsSW5pdEhvb2tzJiZlLmNhbGxJbml0SG9va3MuY2FsbCh0aGlzKSx0aGlzLl9pbml0SG9va3NDYWxsZWQ9ITA7Zm9yKHZhciB0PTAsaT1uLl9pbml0SG9va3MubGVuZ3RoO3Q8aTt0Kyspbi5faW5pdEhvb2tzW3RdLmNhbGwodGhpcyl9fSxpfSxTLmluY2x1ZGU9ZnVuY3Rpb24odCl7cmV0dXJuIGgodGhpcy5wcm90b3R5cGUsdCksdGhpc30sUy5tZXJnZU9wdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIGgodGhpcy5wcm90b3R5cGUub3B0aW9ucyx0KSx0aGlzfSxTLmFkZEluaXRIb29rPWZ1bmN0aW9uKHQpe3ZhciBpPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxlPVwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpmdW5jdGlvbigpe3RoaXNbdF0uYXBwbHkodGhpcyxpKX07cmV0dXJuIHRoaXMucHJvdG90eXBlLl9pbml0SG9va3M9dGhpcy5wcm90b3R5cGUuX2luaXRIb29rc3x8W10sdGhpcy5wcm90b3R5cGUuX2luaXRIb29rcy5wdXNoKGUpLHRoaXN9O3ZhciBaPXtvbjpmdW5jdGlvbih0LGksZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpZm9yKHZhciBuIGluIHQpdGhpcy5fb24obix0W25dLGkpO2Vsc2UgZm9yKHZhciBvPTAscz0odD1sKHQpKS5sZW5ndGg7bzxzO28rKyl0aGlzLl9vbih0W29dLGksZSk7cmV0dXJuIHRoaXN9LG9mZjpmdW5jdGlvbih0LGksZSl7aWYodClpZihcIm9iamVjdFwiPT10eXBlb2YgdClmb3IodmFyIG4gaW4gdCl0aGlzLl9vZmYobix0W25dLGkpO2Vsc2UgZm9yKHZhciBvPTAscz0odD1sKHQpKS5sZW5ndGg7bzxzO28rKyl0aGlzLl9vZmYodFtvXSxpLGUpO2Vsc2UgZGVsZXRlIHRoaXMuX2V2ZW50cztyZXR1cm4gdGhpc30sX29uOmZ1bmN0aW9uKHQsaSxlKXt0aGlzLl9ldmVudHM9dGhpcy5fZXZlbnRzfHx7fTt2YXIgbj10aGlzLl9ldmVudHNbdF07bnx8KG49W10sdGhpcy5fZXZlbnRzW3RdPW4pLGU9PT10aGlzJiYoZT12b2lkIDApO2Zvcih2YXIgbz17Zm46aSxjdHg6ZX0scz1uLHI9MCxhPXMubGVuZ3RoO3I8YTtyKyspaWYoc1tyXS5mbj09PWkmJnNbcl0uY3R4PT09ZSlyZXR1cm47cy5wdXNoKG8pfSxfb2ZmOmZ1bmN0aW9uKHQsaSxlKXt2YXIgbixvLHM7aWYodGhpcy5fZXZlbnRzJiYobj10aGlzLl9ldmVudHNbdF0pKWlmKGkpe2lmKGU9PT10aGlzJiYoZT12b2lkIDApLG4pZm9yKG89MCxzPW4ubGVuZ3RoO288cztvKyspe3ZhciByPW5bb107aWYoci5jdHg9PT1lJiZyLmZuPT09aSlyZXR1cm4gci5mbj1hLHRoaXMuX2ZpcmluZ0NvdW50JiYodGhpcy5fZXZlbnRzW3RdPW49bi5zbGljZSgpKSx2b2lkIG4uc3BsaWNlKG8sMSl9fWVsc2V7Zm9yKG89MCxzPW4ubGVuZ3RoO288cztvKyspbltvXS5mbj1hO2RlbGV0ZSB0aGlzLl9ldmVudHNbdF19fSxmaXJlOmZ1bmN0aW9uKHQsaSxlKXtpZighdGhpcy5saXN0ZW5zKHQsZSkpcmV0dXJuIHRoaXM7dmFyIG49aCh7fSxpLHt0eXBlOnQsdGFyZ2V0OnRoaXMsc291cmNlVGFyZ2V0OmkmJmkuc291cmNlVGFyZ2V0fHx0aGlzfSk7aWYodGhpcy5fZXZlbnRzKXt2YXIgbz10aGlzLl9ldmVudHNbdF07aWYobyl7dGhpcy5fZmlyaW5nQ291bnQ9dGhpcy5fZmlyaW5nQ291bnQrMXx8MTtmb3IodmFyIHM9MCxyPW8ubGVuZ3RoO3M8cjtzKyspe3ZhciBhPW9bc107YS5mbi5jYWxsKGEuY3R4fHx0aGlzLG4pfXRoaXMuX2ZpcmluZ0NvdW50LS19fXJldHVybiBlJiZ0aGlzLl9wcm9wYWdhdGVFdmVudChuKSx0aGlzfSxsaXN0ZW5zOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5fZXZlbnRzJiZ0aGlzLl9ldmVudHNbdF07aWYoZSYmZS5sZW5ndGgpcmV0dXJuITA7aWYoaSlmb3IodmFyIG4gaW4gdGhpcy5fZXZlbnRQYXJlbnRzKWlmKHRoaXMuX2V2ZW50UGFyZW50c1tuXS5saXN0ZW5zKHQsaSkpcmV0dXJuITA7cmV0dXJuITF9LG9uY2U6ZnVuY3Rpb24odCxpLGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtmb3IodmFyIG4gaW4gdCl0aGlzLm9uY2Uobix0W25dLGkpO3JldHVybiB0aGlzfXZhciBvPXAoZnVuY3Rpb24oKXt0aGlzLm9mZih0LGksZSkub2ZmKHQsbyxlKX0sdGhpcyk7cmV0dXJuIHRoaXMub24odCxpLGUpLm9uKHQsbyxlKX0sYWRkRXZlbnRQYXJlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2V2ZW50UGFyZW50cz10aGlzLl9ldmVudFBhcmVudHN8fHt9LHRoaXMuX2V2ZW50UGFyZW50c1ttKHQpXT10LHRoaXN9LHJlbW92ZUV2ZW50UGFyZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9ldmVudFBhcmVudHMmJmRlbGV0ZSB0aGlzLl9ldmVudFBhcmVudHNbbSh0KV0sdGhpc30sX3Byb3BhZ2F0ZUV2ZW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgaSBpbiB0aGlzLl9ldmVudFBhcmVudHMpdGhpcy5fZXZlbnRQYXJlbnRzW2ldLmZpcmUodC50eXBlLGgoe2xheWVyOnQudGFyZ2V0LHByb3BhZ2F0ZWRGcm9tOnQudGFyZ2V0fSx0KSwhMCl9fTtaLmFkZEV2ZW50TGlzdGVuZXI9Wi5vbixaLnJlbW92ZUV2ZW50TGlzdGVuZXI9Wi5jbGVhckFsbEV2ZW50TGlzdGVuZXJzPVoub2ZmLFouYWRkT25lVGltZUV2ZW50TGlzdGVuZXI9Wi5vbmNlLFouZmlyZUV2ZW50PVouZmlyZSxaLmhhc0V2ZW50TGlzdGVuZXJzPVoubGlzdGVuczt2YXIgRT1TLmV4dGVuZChaKTtmdW5jdGlvbiBrKHQsaSxlKXt0aGlzLng9ZT9NYXRoLnJvdW5kKHQpOnQsdGhpcy55PWU/TWF0aC5yb3VuZChpKTppfXZhciBCPU1hdGgudHJ1bmN8fGZ1bmN0aW9uKHQpe3JldHVybiAwPHQ/TWF0aC5mbG9vcih0KTpNYXRoLmNlaWwodCl9O2Z1bmN0aW9uIEEodCxpLGUpe3JldHVybiB0IGluc3RhbmNlb2Ygaz90OmcodCk/bmV3IGsodFswXSx0WzFdKTpudWxsPT10P3Q6XCJvYmplY3RcIj09dHlwZW9mIHQmJlwieFwiaW4gdCYmXCJ5XCJpbiB0P25ldyBrKHQueCx0LnkpOm5ldyBrKHQsaSxlKX1mdW5jdGlvbiBJKHQsaSl7aWYodClmb3IodmFyIGU9aT9bdCxpXTp0LG49MCxvPWUubGVuZ3RoO248bztuKyspdGhpcy5leHRlbmQoZVtuXSl9ZnVuY3Rpb24gTyh0LGkpe3JldHVybiF0fHx0IGluc3RhbmNlb2YgST90Om5ldyBJKHQsaSl9ZnVuY3Rpb24gUih0LGkpe2lmKHQpZm9yKHZhciBlPWk/W3QsaV06dCxuPTAsbz1lLmxlbmd0aDtuPG87bisrKXRoaXMuZXh0ZW5kKGVbbl0pfWZ1bmN0aW9uIE4odCxpKXtyZXR1cm4gdCBpbnN0YW5jZW9mIFI/dDpuZXcgUih0LGkpfWZ1bmN0aW9uIEQodCxpLGUpe2lmKGlzTmFOKHQpfHxpc05hTihpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExhdExuZyBvYmplY3Q6IChcIit0K1wiLCBcIitpK1wiKVwiKTt0aGlzLmxhdD0rdCx0aGlzLmxuZz0raSx2b2lkIDAhPT1lJiYodGhpcy5hbHQ9K2UpfWZ1bmN0aW9uIGoodCxpLGUpe3JldHVybiB0IGluc3RhbmNlb2YgRD90OmcodCkmJlwib2JqZWN0XCIhPXR5cGVvZiB0WzBdPzM9PT10Lmxlbmd0aD9uZXcgRCh0WzBdLHRbMV0sdFsyXSk6Mj09PXQubGVuZ3RoP25ldyBEKHRbMF0sdFsxXSk6bnVsbDpudWxsPT10P3Q6XCJvYmplY3RcIj09dHlwZW9mIHQmJlwibGF0XCJpbiB0P25ldyBEKHQubGF0LFwibG5nXCJpbiB0P3QubG5nOnQubG9uLHQuYWx0KTp2b2lkIDA9PT1pP251bGw6bmV3IEQodCxpLGUpfWsucHJvdG90eXBlPXtjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgayh0aGlzLngsdGhpcy55KX0sYWRkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNsb25lKCkuX2FkZChBKHQpKX0sX2FkZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54Kz10LngsdGhpcy55Kz10LnksdGhpc30sc3VidHJhY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fc3VidHJhY3QoQSh0KSl9LF9zdWJ0cmFjdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54LT10LngsdGhpcy55LT10LnksdGhpc30sZGl2aWRlQnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkodCl9LF9kaXZpZGVCeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54Lz10LHRoaXMueS89dCx0aGlzfSxtdWx0aXBseUJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNsb25lKCkuX211bHRpcGx5QnkodCl9LF9tdWx0aXBseUJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLngqPXQsdGhpcy55Kj10LHRoaXN9LHNjYWxlQnk6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBrKHRoaXMueCp0LngsdGhpcy55KnQueSl9LHVuc2NhbGVCeTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGsodGhpcy54L3QueCx0aGlzLnkvdC55KX0scm91bmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpfSxfcm91bmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54PU1hdGgucm91bmQodGhpcy54KSx0aGlzLnk9TWF0aC5yb3VuZCh0aGlzLnkpLHRoaXN9LGZsb29yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fZmxvb3IoKX0sX2Zsb29yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueD1NYXRoLmZsb29yKHRoaXMueCksdGhpcy55PU1hdGguZmxvb3IodGhpcy55KSx0aGlzfSxjZWlsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fY2VpbCgpfSxfY2VpbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLng9TWF0aC5jZWlsKHRoaXMueCksdGhpcy55PU1hdGguY2VpbCh0aGlzLnkpLHRoaXN9LHRydW5jOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xvbmUoKS5fdHJ1bmMoKX0sX3RydW5jOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueD1CKHRoaXMueCksdGhpcy55PUIodGhpcy55KSx0aGlzfSxkaXN0YW5jZVRvOmZ1bmN0aW9uKHQpe3ZhciBpPSh0PUEodCkpLngtdGhpcy54LGU9dC55LXRoaXMueTtyZXR1cm4gTWF0aC5zcXJ0KGkqaStlKmUpfSxlcXVhbHM6ZnVuY3Rpb24odCl7cmV0dXJuKHQ9QSh0KSkueD09PXRoaXMueCYmdC55PT09dGhpcy55fSxjb250YWluczpmdW5jdGlvbih0KXtyZXR1cm4gdD1BKHQpLE1hdGguYWJzKHQueCk8PU1hdGguYWJzKHRoaXMueCkmJk1hdGguYWJzKHQueSk8PU1hdGguYWJzKHRoaXMueSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJQb2ludChcIityKHRoaXMueCkrXCIsIFwiK3IodGhpcy55KStcIilcIn19LEkucHJvdG90eXBlPXtleHRlbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9QSh0KSx0aGlzLm1pbnx8dGhpcy5tYXg/KHRoaXMubWluLng9TWF0aC5taW4odC54LHRoaXMubWluLngpLHRoaXMubWF4Lng9TWF0aC5tYXgodC54LHRoaXMubWF4LngpLHRoaXMubWluLnk9TWF0aC5taW4odC55LHRoaXMubWluLnkpLHRoaXMubWF4Lnk9TWF0aC5tYXgodC55LHRoaXMubWF4LnkpKToodGhpcy5taW49dC5jbG9uZSgpLHRoaXMubWF4PXQuY2xvbmUoKSksdGhpc30sZ2V0Q2VudGVyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgaygodGhpcy5taW4ueCt0aGlzLm1heC54KS8yLCh0aGlzLm1pbi55K3RoaXMubWF4LnkpLzIsdCl9LGdldEJvdHRvbUxlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGsodGhpcy5taW4ueCx0aGlzLm1heC55KX0sZ2V0VG9wUmlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGsodGhpcy5tYXgueCx0aGlzLm1pbi55KX0sZ2V0VG9wTGVmdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbn0sZ2V0Qm90dG9tUmlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LGdldFNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXguc3VidHJhY3QodGhpcy5taW4pfSxjb250YWluczpmdW5jdGlvbih0KXt2YXIgaSxlO3JldHVybih0PShcIm51bWJlclwiPT10eXBlb2YgdFswXXx8dCBpbnN0YW5jZW9mIGs/QTpPKSh0KSlpbnN0YW5jZW9mIEk/KGk9dC5taW4sZT10Lm1heCk6aT1lPXQsaS54Pj10aGlzLm1pbi54JiZlLng8PXRoaXMubWF4LngmJmkueT49dGhpcy5taW4ueSYmZS55PD10aGlzLm1heC55fSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQpe3Q9Tyh0KTt2YXIgaT10aGlzLm1pbixlPXRoaXMubWF4LG49dC5taW4sbz10Lm1heCxzPW8ueD49aS54JiZuLng8PWUueCxyPW8ueT49aS55JiZuLnk8PWUueTtyZXR1cm4gcyYmcn0sb3ZlcmxhcHM6ZnVuY3Rpb24odCl7dD1PKHQpO3ZhciBpPXRoaXMubWluLGU9dGhpcy5tYXgsbj10Lm1pbixvPXQubWF4LHM9by54PmkueCYmbi54PGUueCxyPW8ueT5pLnkmJm4ueTxlLnk7cmV0dXJuIHMmJnJ9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4hKCF0aGlzLm1pbnx8IXRoaXMubWF4KX19LFIucHJvdG90eXBlPXtleHRlbmQ6ZnVuY3Rpb24odCl7dmFyIGksZSxuPXRoaXMuX3NvdXRoV2VzdCxvPXRoaXMuX25vcnRoRWFzdDtpZih0IGluc3RhbmNlb2YgRCllPWk9dDtlbHNle2lmKCEodCBpbnN0YW5jZW9mIFIpKXJldHVybiB0P3RoaXMuZXh0ZW5kKGoodCl8fE4odCkpOnRoaXM7aWYoaT10Ll9zb3V0aFdlc3QsZT10Ll9ub3J0aEVhc3QsIWl8fCFlKXJldHVybiB0aGlzfXJldHVybiBufHxvPyhuLmxhdD1NYXRoLm1pbihpLmxhdCxuLmxhdCksbi5sbmc9TWF0aC5taW4oaS5sbmcsbi5sbmcpLG8ubGF0PU1hdGgubWF4KGUubGF0LG8ubGF0KSxvLmxuZz1NYXRoLm1heChlLmxuZyxvLmxuZykpOih0aGlzLl9zb3V0aFdlc3Q9bmV3IEQoaS5sYXQsaS5sbmcpLHRoaXMuX25vcnRoRWFzdD1uZXcgRChlLmxhdCxlLmxuZykpLHRoaXN9LHBhZDpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9zb3V0aFdlc3QsZT10aGlzLl9ub3J0aEVhc3Qsbj1NYXRoLmFicyhpLmxhdC1lLmxhdCkqdCxvPU1hdGguYWJzKGkubG5nLWUubG5nKSp0O3JldHVybiBuZXcgUihuZXcgRChpLmxhdC1uLGkubG5nLW8pLG5ldyBEKGUubGF0K24sZS5sbmcrbykpfSxnZXRDZW50ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEQoKHRoaXMuX3NvdXRoV2VzdC5sYXQrdGhpcy5fbm9ydGhFYXN0LmxhdCkvMiwodGhpcy5fc291dGhXZXN0LmxuZyt0aGlzLl9ub3J0aEVhc3QubG5nKS8yKX0sZ2V0U291dGhXZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXRoV2VzdH0sZ2V0Tm9ydGhFYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25vcnRoRWFzdH0sZ2V0Tm9ydGhXZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEKHRoaXMuZ2V0Tm9ydGgoKSx0aGlzLmdldFdlc3QoKSl9LGdldFNvdXRoRWFzdDpmdW5jdGlvbigpe3JldHVybiBuZXcgRCh0aGlzLmdldFNvdXRoKCksdGhpcy5nZXRFYXN0KCkpfSxnZXRXZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sbmd9LGdldFNvdXRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXR9LGdldEVhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxuZ30sZ2V0Tm9ydGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbm9ydGhFYXN0LmxhdH0sY29udGFpbnM6ZnVuY3Rpb24odCl7dD0oXCJudW1iZXJcIj09dHlwZW9mIHRbMF18fHQgaW5zdGFuY2VvZiBEfHxcImxhdFwiaW4gdD9qOk4pKHQpO3ZhciBpLGUsbj10aGlzLl9zb3V0aFdlc3Qsbz10aGlzLl9ub3J0aEVhc3Q7cmV0dXJuIHQgaW5zdGFuY2VvZiBSPyhpPXQuZ2V0U291dGhXZXN0KCksZT10LmdldE5vcnRoRWFzdCgpKTppPWU9dCxpLmxhdD49bi5sYXQmJmUubGF0PD1vLmxhdCYmaS5sbmc+PW4ubG5nJiZlLmxuZzw9by5sbmd9LGludGVyc2VjdHM6ZnVuY3Rpb24odCl7dD1OKHQpO3ZhciBpPXRoaXMuX3NvdXRoV2VzdCxlPXRoaXMuX25vcnRoRWFzdCxuPXQuZ2V0U291dGhXZXN0KCksbz10LmdldE5vcnRoRWFzdCgpLHM9by5sYXQ+PWkubGF0JiZuLmxhdDw9ZS5sYXQscj1vLmxuZz49aS5sbmcmJm4ubG5nPD1lLmxuZztyZXR1cm4gcyYmcn0sb3ZlcmxhcHM6ZnVuY3Rpb24odCl7dD1OKHQpO3ZhciBpPXRoaXMuX3NvdXRoV2VzdCxlPXRoaXMuX25vcnRoRWFzdCxuPXQuZ2V0U291dGhXZXN0KCksbz10LmdldE5vcnRoRWFzdCgpLHM9by5sYXQ+aS5sYXQmJm4ubGF0PGUubGF0LHI9by5sbmc+aS5sbmcmJm4ubG5nPGUubG5nO3JldHVybiBzJiZyfSx0b0JCb3hTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5nZXRXZXN0KCksdGhpcy5nZXRTb3V0aCgpLHRoaXMuZ2V0RWFzdCgpLHRoaXMuZ2V0Tm9ydGgoKV0uam9pbihcIixcIil9LGVxdWFsczpmdW5jdGlvbih0LGkpe3JldHVybiEhdCYmKHQ9Tih0KSx0aGlzLl9zb3V0aFdlc3QuZXF1YWxzKHQuZ2V0U291dGhXZXN0KCksaSkmJnRoaXMuX25vcnRoRWFzdC5lcXVhbHModC5nZXROb3J0aEVhc3QoKSxpKSl9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4hKCF0aGlzLl9zb3V0aFdlc3R8fCF0aGlzLl9ub3J0aEVhc3QpfX07dmFyIFcsSD17bGF0TG5nVG9Qb2ludDpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMucHJvamVjdGlvbi5wcm9qZWN0KHQpLG49dGhpcy5zY2FsZShpKTtyZXR1cm4gdGhpcy50cmFuc2Zvcm1hdGlvbi5fdHJhbnNmb3JtKGUsbil9LHBvaW50VG9MYXRMbmc6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLnNjYWxlKGkpLG49dGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybSh0LGUpO3JldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KG4pfSxwcm9qZWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnByb2plY3Rpb24ucHJvamVjdCh0KX0sdW5wcm9qZWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHQpfSxzY2FsZTpmdW5jdGlvbih0KXtyZXR1cm4gMjU2Kk1hdGgucG93KDIsdCl9LHpvb206ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgubG9nKHQvMjU2KS9NYXRoLkxOMn0sZ2V0UHJvamVjdGVkQm91bmRzOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaW5maW5pdGUpcmV0dXJuIG51bGw7dmFyIGk9dGhpcy5wcm9qZWN0aW9uLmJvdW5kcyxlPXRoaXMuc2NhbGUodCk7cmV0dXJuIG5ldyBJKHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGkubWluLGUpLHRoaXMudHJhbnNmb3JtYXRpb24udHJhbnNmb3JtKGkubWF4LGUpKX0saW5maW5pdGU6IShELnByb3RvdHlwZT17ZXF1YWxzOmZ1bmN0aW9uKHQsaSl7cmV0dXJuISF0JiYodD1qKHQpLE1hdGgubWF4KE1hdGguYWJzKHRoaXMubGF0LXQubGF0KSxNYXRoLmFicyh0aGlzLmxuZy10LmxuZykpPD0odm9pZCAwPT09aT8xZS05OmkpKX0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuXCJMYXRMbmcoXCIrcih0aGlzLmxhdCx0KStcIiwgXCIrcih0aGlzLmxuZyx0KStcIilcIn0sZGlzdGFuY2VUbzpmdW5jdGlvbih0KXtyZXR1cm4gRi5kaXN0YW5jZSh0aGlzLGoodCkpfSx3cmFwOmZ1bmN0aW9uKCl7cmV0dXJuIEYud3JhcExhdExuZyh0aGlzKX0sdG9Cb3VuZHM6ZnVuY3Rpb24odCl7dmFyIGk9MTgwKnQvNDAwNzUwMTcsZT1pL01hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGF0KTtyZXR1cm4gTihbdGhpcy5sYXQtaSx0aGlzLmxuZy1lXSxbdGhpcy5sYXQraSx0aGlzLmxuZytlXSl9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEKHRoaXMubGF0LHRoaXMubG5nLHRoaXMuYWx0KX19KSx3cmFwTGF0TG5nOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMud3JhcExuZz9vKHQubG5nLHRoaXMud3JhcExuZywhMCk6dC5sbmc7cmV0dXJuIG5ldyBEKHRoaXMud3JhcExhdD9vKHQubGF0LHRoaXMud3JhcExhdCwhMCk6dC5sYXQsaSx0LmFsdCl9LHdyYXBMYXRMbmdCb3VuZHM6ZnVuY3Rpb24odCl7dmFyIGk9dC5nZXRDZW50ZXIoKSxlPXRoaXMud3JhcExhdExuZyhpKSxuPWkubGF0LWUubGF0LG89aS5sbmctZS5sbmc7aWYoMD09biYmMD09bylyZXR1cm4gdDt2YXIgcz10LmdldFNvdXRoV2VzdCgpLHI9dC5nZXROb3J0aEVhc3QoKTtyZXR1cm4gbmV3IFIobmV3IEQocy5sYXQtbixzLmxuZy1vKSxuZXcgRChyLmxhdC1uLHIubG5nLW8pKX19LEY9aCh7fSxILHt3cmFwTG5nOlstMTgwLDE4MF0sUjo2MzcxZTMsZGlzdGFuY2U6ZnVuY3Rpb24odCxpKXt2YXIgZT1NYXRoLlBJLzE4MCxuPXQubGF0KmUsbz1pLmxhdCplLHM9TWF0aC5zaW4oKGkubGF0LXQubGF0KSplLzIpLHI9TWF0aC5zaW4oKGkubG5nLXQubG5nKSplLzIpLGE9cypzK01hdGguY29zKG4pKk1hdGguY29zKG8pKnIqcixoPTIqTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksTWF0aC5zcXJ0KDEtYSkpO3JldHVybiB0aGlzLlIqaH19KSxVPTYzNzgxMzcsVj17UjpVLE1BWF9MQVRJVFVERTo4NS4wNTExMjg3Nzk4LHByb2plY3Q6ZnVuY3Rpb24odCl7dmFyIGk9TWF0aC5QSS8xODAsZT10aGlzLk1BWF9MQVRJVFVERSxuPU1hdGgubWF4KE1hdGgubWluKGUsdC5sYXQpLC1lKSxvPU1hdGguc2luKG4qaSk7cmV0dXJuIG5ldyBrKHRoaXMuUip0LmxuZyppLHRoaXMuUipNYXRoLmxvZygoMStvKS8oMS1vKSkvMil9LHVucHJvamVjdDpmdW5jdGlvbih0KXt2YXIgaT0xODAvTWF0aC5QSTtyZXR1cm4gbmV3IEQoKDIqTWF0aC5hdGFuKE1hdGguZXhwKHQueS90aGlzLlIpKS1NYXRoLlBJLzIpKmksdC54KmkvdGhpcy5SKX0sYm91bmRzOm5ldyBJKFstKFc9VSpNYXRoLlBJKSwtV10sW1csV10pfTtmdW5jdGlvbiBxKHQsaSxlLG4pe2lmKGcodCkpcmV0dXJuIHRoaXMuX2E9dFswXSx0aGlzLl9iPXRbMV0sdGhpcy5fYz10WzJdLHZvaWQodGhpcy5fZD10WzNdKTt0aGlzLl9hPXQsdGhpcy5fYj1pLHRoaXMuX2M9ZSx0aGlzLl9kPW59ZnVuY3Rpb24gRyh0LGksZSxuKXtyZXR1cm4gbmV3IHEodCxpLGUsbil9cS5wcm90b3R5cGU9e3RyYW5zZm9ybTpmdW5jdGlvbih0LGkpe3JldHVybiB0aGlzLl90cmFuc2Zvcm0odC5jbG9uZSgpLGkpfSxfdHJhbnNmb3JtOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIGk9aXx8MSx0Lng9aSoodGhpcy5fYSp0LngrdGhpcy5fYiksdC55PWkqKHRoaXMuX2MqdC55K3RoaXMuX2QpLHR9LHVudHJhbnNmb3JtOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIGk9aXx8MSxuZXcgaygodC54L2ktdGhpcy5fYikvdGhpcy5fYSwodC55L2ktdGhpcy5fZCkvdGhpcy5fYyl9fTt2YXIgSyxZPWgoe30sRix7Y29kZTpcIkVQU0c6Mzg1N1wiLHByb2plY3Rpb246Vix0cmFuc2Zvcm1hdGlvbjpHKEs9LjUvKE1hdGguUEkqVi5SKSwuNSwtSywuNSl9KSxYPWgoe30sWSx7Y29kZTpcIkVQU0c6OTAwOTEzXCJ9KTtmdW5jdGlvbiBKKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHQpfWZ1bmN0aW9uICQodCxpKXtmb3IodmFyIGUsbixvLHMscj1cIlwiLGE9MCxoPXQubGVuZ3RoO2E8aDthKyspe2ZvcihlPTAsbj0obz10W2FdKS5sZW5ndGg7ZTxuO2UrKylyKz0oZT9cIkxcIjpcIk1cIikrKHM9b1tlXSkueCtcIiBcIitzLnk7cis9aT9adD9cInpcIjpcInhcIjpcIlwifXJldHVybiByfHxcIk0wIDBcIn12YXIgUT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsdHQ9XCJBY3RpdmVYT2JqZWN0XCJpbiB3aW5kb3csaXQ9dHQmJiFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLGV0PVwibXNMYXVuY2hVcmlcImluIG5hdmlnYXRvciYmIShcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQpLG50PWt0KFwid2Via2l0XCIpLG90PWt0KFwiYW5kcm9pZFwiKSxzdD1rdChcImFuZHJvaWQgMlwiKXx8a3QoXCJhbmRyb2lkIDNcIikscnQ9cGFyc2VJbnQoL1dlYktpdFxcLyhbMC05XSspfCQvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClbMV0sMTApLGF0PW90JiZrdChcIkdvb2dsZVwiKSYmcnQ8NTM3JiYhKFwiQXVkaW9Ob2RlXCJpbiB3aW5kb3cpLGh0PSEhd2luZG93Lm9wZXJhLHV0PSFldCYma3QoXCJjaHJvbWVcIiksbHQ9a3QoXCJnZWNrb1wiKSYmIW50JiYhaHQmJiF0dCxjdD0hdXQmJmt0KFwic2FmYXJpXCIpLF90PWt0KFwicGhhbnRvbVwiKSxkdD1cIk9UcmFuc2l0aW9uXCJpbiBRLHB0PTA9PT1uYXZpZ2F0b3IucGxhdGZvcm0uaW5kZXhPZihcIldpblwiKSxtdD10dCYmXCJ0cmFuc2l0aW9uXCJpbiBRLGZ0PVwiV2ViS2l0Q1NTTWF0cml4XCJpbiB3aW5kb3cmJlwibTExXCJpbiBuZXcgd2luZG93LldlYktpdENTU01hdHJpeCYmIXN0LGd0PVwiTW96UGVyc3BlY3RpdmVcImluIFEsdnQ9IXdpbmRvdy5MX0RJU0FCTEVfM0QmJihtdHx8ZnR8fGd0KSYmIWR0JiYhX3QseXQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG9yaWVudGF0aW9ufHxrdChcIm1vYmlsZVwiKSx4dD15dCYmbnQsd3Q9eXQmJmZ0LFB0PSF3aW5kb3cuUG9pbnRlckV2ZW50JiZ3aW5kb3cuTVNQb2ludGVyRXZlbnQsTHQ9ISghd2luZG93LlBvaW50ZXJFdmVudCYmIVB0KSxidD0hd2luZG93LkxfTk9fVE9VQ0gmJihMdHx8XCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8d2luZG93LkRvY3VtZW50VG91Y2gmJmRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFR0PXl0JiZodCxNdD15dCYmbHQsenQ9MTwod2luZG93LmRldmljZVBpeGVsUmF0aW98fHdpbmRvdy5zY3JlZW4uZGV2aWNlWERQSS93aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJKSxDdD1mdW5jdGlvbigpe3ZhciB0PSExO3RyeXt2YXIgaT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe3Q9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydFwiLGEsaSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZUV2ZW50U3VwcG9ydFwiLGEsaSl9Y2F0Y2godCl7fXJldHVybiB0fSgpLFN0PSEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0LFp0PSEoIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROU3x8IUooXCJzdmdcIikuY3JlYXRlU1ZHUmVjdCksRXQ9IVp0JiZmdW5jdGlvbigpe3RyeXt2YXIgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3QuaW5uZXJIVE1MPSc8djpzaGFwZSBhZGo9XCIxXCIvPic7dmFyIGk9dC5maXJzdENoaWxkO3JldHVybiBpLnN0eWxlLmJlaGF2aW9yPVwidXJsKCNkZWZhdWx0I1ZNTClcIixpJiZcIm9iamVjdFwiPT10eXBlb2YgaS5hZGp9Y2F0Y2godCl7cmV0dXJuITF9fSgpO2Z1bmN0aW9uIGt0KHQpe3JldHVybiAwPD1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0KX12YXIgQnQ9e2llOnR0LGllbHQ5Oml0LGVkZ2U6ZXQsd2Via2l0Om50LGFuZHJvaWQ6b3QsYW5kcm9pZDIzOnN0LGFuZHJvaWRTdG9jazphdCxvcGVyYTpodCxjaHJvbWU6dXQsZ2Vja286bHQsc2FmYXJpOmN0LHBoYW50b206X3Qsb3BlcmExMjpkdCx3aW46cHQsaWUzZDptdCx3ZWJraXQzZDpmdCxnZWNrbzNkOmd0LGFueTNkOnZ0LG1vYmlsZTp5dCxtb2JpbGVXZWJraXQ6eHQsbW9iaWxlV2Via2l0M2Q6d3QsbXNQb2ludGVyOlB0LHBvaW50ZXI6THQsdG91Y2g6YnQsbW9iaWxlT3BlcmE6VHQsbW9iaWxlR2Vja286TXQscmV0aW5hOnp0LHBhc3NpdmVFdmVudHM6Q3QsY2FudmFzOlN0LHN2ZzpadCx2bWw6RXR9LEF0PVB0P1wiTVNQb2ludGVyRG93blwiOlwicG9pbnRlcmRvd25cIixJdD1QdD9cIk1TUG9pbnRlck1vdmVcIjpcInBvaW50ZXJtb3ZlXCIsT3Q9UHQ/XCJNU1BvaW50ZXJVcFwiOlwicG9pbnRlcnVwXCIsUnQ9UHQ/XCJNU1BvaW50ZXJDYW5jZWxcIjpcInBvaW50ZXJjYW5jZWxcIixOdD17fSxEdD0hMTtmdW5jdGlvbiBqdCh0LGksZSxuKXtmdW5jdGlvbiBvKHQpe1V0KHQscil9dmFyIHMscixhLGgsdSxsLGMsXztmdW5jdGlvbiBkKHQpe3QucG9pbnRlclR5cGU9PT0odC5NU1BPSU5URVJfVFlQRV9NT1VTRXx8XCJtb3VzZVwiKSYmMD09PXQuYnV0dG9uc3x8VXQodCxoKX1yZXR1cm5cInRvdWNoc3RhcnRcIj09PWk/KHU9dCxsPWUsYz1uLF89cChmdW5jdGlvbih0KXt0Lk1TUE9JTlRFUl9UWVBFX1RPVUNIJiZ0LnBvaW50ZXJUeXBlPT09dC5NU1BPSU5URVJfVFlQRV9UT1VDSCYmUmkodCksVXQodCxsKX0pLHVbXCJfbGVhZmxldF90b3VjaHN0YXJ0XCIrY109Xyx1LmFkZEV2ZW50TGlzdGVuZXIoQXQsXywhMSksRHR8fChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKEF0LFd0LCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKEl0LEh0LCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKE90LEZ0LCEwKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFJ0LEZ0LCEwKSxEdD0hMCkpOlwidG91Y2htb3ZlXCI9PT1pPyhoPWUsKGE9dClbXCJfbGVhZmxldF90b3VjaG1vdmVcIituXT1kLGEuYWRkRXZlbnRMaXN0ZW5lcihJdCxkLCExKSk6XCJ0b3VjaGVuZFwiPT09aSYmKHI9ZSwocz10KVtcIl9sZWFmbGV0X3RvdWNoZW5kXCIrbl09byxzLmFkZEV2ZW50TGlzdGVuZXIoT3QsbywhMSkscy5hZGRFdmVudExpc3RlbmVyKFJ0LG8sITEpKSx0aGlzfWZ1bmN0aW9uIFd0KHQpe050W3QucG9pbnRlcklkXT10fWZ1bmN0aW9uIEh0KHQpe050W3QucG9pbnRlcklkXSYmKE50W3QucG9pbnRlcklkXT10KX1mdW5jdGlvbiBGdCh0KXtkZWxldGUgTnRbdC5wb2ludGVySWRdfWZ1bmN0aW9uIFV0KHQsaSl7Zm9yKHZhciBlIGluIHQudG91Y2hlcz1bXSxOdCl0LnRvdWNoZXMucHVzaChOdFtlXSk7dC5jaGFuZ2VkVG91Y2hlcz1bdF0saSh0KX12YXIgVnQ9UHQ/XCJNU1BvaW50ZXJEb3duXCI6THQ/XCJwb2ludGVyZG93blwiOlwidG91Y2hzdGFydFwiLHF0PVB0P1wiTVNQb2ludGVyVXBcIjpMdD9cInBvaW50ZXJ1cFwiOlwidG91Y2hlbmRcIixHdD1cIl9sZWFmbGV0X1wiO3ZhciBLdCxZdCxYdCxKdCwkdCxRdCx0aT1maShbXCJ0cmFuc2Zvcm1cIixcIndlYmtpdFRyYW5zZm9ybVwiLFwiT1RyYW5zZm9ybVwiLFwiTW96VHJhbnNmb3JtXCIsXCJtc1RyYW5zZm9ybVwiXSksaWk9ZmkoW1wid2Via2l0VHJhbnNpdGlvblwiLFwidHJhbnNpdGlvblwiLFwiT1RyYW5zaXRpb25cIixcIk1velRyYW5zaXRpb25cIixcIm1zVHJhbnNpdGlvblwiXSksZWk9XCJ3ZWJraXRUcmFuc2l0aW9uXCI9PT1paXx8XCJPVHJhbnNpdGlvblwiPT09aWk/aWkrXCJFbmRcIjpcInRyYW5zaXRpb25lbmRcIjtmdW5jdGlvbiBuaSh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD9kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0KTp0fWZ1bmN0aW9uIG9pKHQsaSl7dmFyIGUsbj10LnN0eWxlW2ldfHx0LmN1cnJlbnRTdHlsZSYmdC5jdXJyZW50U3R5bGVbaV07cmV0dXJuIG4mJlwiYXV0b1wiIT09bnx8IWRvY3VtZW50LmRlZmF1bHRWaWV3fHwobj0oZT1kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCkpP2VbaV06bnVsbCksXCJhdXRvXCI9PT1uP251bGw6bn1mdW5jdGlvbiBzaSh0LGksZSl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0KTtyZXR1cm4gbi5jbGFzc05hbWU9aXx8XCJcIixlJiZlLmFwcGVuZENoaWxkKG4pLG59ZnVuY3Rpb24gcmkodCl7dmFyIGk9dC5wYXJlbnROb2RlO2kmJmkucmVtb3ZlQ2hpbGQodCl9ZnVuY3Rpb24gYWkodCl7Zm9yKDt0LmZpcnN0Q2hpbGQ7KXQucmVtb3ZlQ2hpbGQodC5maXJzdENoaWxkKX1mdW5jdGlvbiBoaSh0KXt2YXIgaT10LnBhcmVudE5vZGU7aSYmaS5sYXN0Q2hpbGQhPT10JiZpLmFwcGVuZENoaWxkKHQpfWZ1bmN0aW9uIHVpKHQpe3ZhciBpPXQucGFyZW50Tm9kZTtpJiZpLmZpcnN0Q2hpbGQhPT10JiZpLmluc2VydEJlZm9yZSh0LGkuZmlyc3RDaGlsZCl9ZnVuY3Rpb24gbGkodCxpKXtpZih2b2lkIDAhPT10LmNsYXNzTGlzdClyZXR1cm4gdC5jbGFzc0xpc3QuY29udGFpbnMoaSk7dmFyIGU9cGkodCk7cmV0dXJuIDA8ZS5sZW5ndGgmJm5ldyBSZWdFeHAoXCIoXnxcXFxccylcIitpK1wiKFxcXFxzfCQpXCIpLnRlc3QoZSl9ZnVuY3Rpb24gY2kodCxpKXt2YXIgZTtpZih2b2lkIDAhPT10LmNsYXNzTGlzdClmb3IodmFyIG49bChpKSxvPTAscz1uLmxlbmd0aDtvPHM7bysrKXQuY2xhc3NMaXN0LmFkZChuW29dKTtlbHNlIGxpKHQsaSl8fGRpKHQsKChlPXBpKHQpKT9lK1wiIFwiOlwiXCIpK2kpfWZ1bmN0aW9uIF9pKHQsaSl7dm9pZCAwIT09dC5jbGFzc0xpc3Q/dC5jbGFzc0xpc3QucmVtb3ZlKGkpOmRpKHQsdSgoXCIgXCIrcGkodCkrXCIgXCIpLnJlcGxhY2UoXCIgXCIraStcIiBcIixcIiBcIikpKX1mdW5jdGlvbiBkaSh0LGkpe3ZvaWQgMD09PXQuY2xhc3NOYW1lLmJhc2VWYWw/dC5jbGFzc05hbWU9aTp0LmNsYXNzTmFtZS5iYXNlVmFsPWl9ZnVuY3Rpb24gcGkodCl7cmV0dXJuIHQuY29ycmVzcG9uZGluZ0VsZW1lbnQmJih0PXQuY29ycmVzcG9uZGluZ0VsZW1lbnQpLHZvaWQgMD09PXQuY2xhc3NOYW1lLmJhc2VWYWw/dC5jbGFzc05hbWU6dC5jbGFzc05hbWUuYmFzZVZhbH1mdW5jdGlvbiBtaSh0LGkpe1wib3BhY2l0eVwiaW4gdC5zdHlsZT90LnN0eWxlLm9wYWNpdHk9aTpcImZpbHRlclwiaW4gdC5zdHlsZSYmZnVuY3Rpb24odCxpKXt2YXIgZT0hMSxuPVwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGFcIjt0cnl7ZT10LmZpbHRlcnMuaXRlbShuKX1jYXRjaCh0KXtpZigxPT09aSlyZXR1cm59aT1NYXRoLnJvdW5kKDEwMCppKSxlPyhlLkVuYWJsZWQ9MTAwIT09aSxlLk9wYWNpdHk9aSk6dC5zdHlsZS5maWx0ZXIrPVwiIHByb2dpZDpcIituK1wiKG9wYWNpdHk9XCIraStcIilcIn0odCxpKX1mdW5jdGlvbiBmaSh0KXtmb3IodmFyIGk9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLGU9MDtlPHQubGVuZ3RoO2UrKylpZih0W2VdaW4gaSlyZXR1cm4gdFtlXTtyZXR1cm4hMX1mdW5jdGlvbiBnaSh0LGksZSl7dmFyIG49aXx8bmV3IGsoMCwwKTt0LnN0eWxlW3RpXT0obXQ/XCJ0cmFuc2xhdGUoXCIrbi54K1wicHgsXCIrbi55K1wicHgpXCI6XCJ0cmFuc2xhdGUzZChcIituLngrXCJweCxcIituLnkrXCJweCwwKVwiKSsoZT9cIiBzY2FsZShcIitlK1wiKVwiOlwiXCIpfWZ1bmN0aW9uIHZpKHQsaSl7dC5fbGVhZmxldF9wb3M9aSx2dD9naSh0LGkpOih0LnN0eWxlLmxlZnQ9aS54K1wicHhcIix0LnN0eWxlLnRvcD1pLnkrXCJweFwiKX1mdW5jdGlvbiB5aSh0KXtyZXR1cm4gdC5fbGVhZmxldF9wb3N8fG5ldyBrKDAsMCl9ZnVuY3Rpb24geGkoKXt6aSh3aW5kb3csXCJkcmFnc3RhcnRcIixSaSl9ZnVuY3Rpb24gd2koKXtTaSh3aW5kb3csXCJkcmFnc3RhcnRcIixSaSl9ZnVuY3Rpb24gUGkodCl7Zm9yKDstMT09PXQudGFiSW5kZXg7KXQ9dC5wYXJlbnROb2RlO3Quc3R5bGUmJihMaSgpLFF0PSgkdD10KS5zdHlsZS5vdXRsaW5lLHQuc3R5bGUub3V0bGluZT1cIm5vbmVcIix6aSh3aW5kb3csXCJrZXlkb3duXCIsTGkpKX1mdW5jdGlvbiBMaSgpeyR0JiYoJHQuc3R5bGUub3V0bGluZT1RdCxRdD0kdD12b2lkIDAsU2kod2luZG93LFwia2V5ZG93blwiLExpKSl9ZnVuY3Rpb24gYmkodCl7Zm9yKDshKCh0PXQucGFyZW50Tm9kZSkub2Zmc2V0V2lkdGgmJnQub2Zmc2V0SGVpZ2h0fHx0PT09ZG9jdW1lbnQuYm9keSk7KTtyZXR1cm4gdH1mdW5jdGlvbiBUaSh0KXt2YXIgaT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3JldHVybnt4Omkud2lkdGgvdC5vZmZzZXRXaWR0aHx8MSx5OmkuaGVpZ2h0L3Qub2Zmc2V0SGVpZ2h0fHwxLGJvdW5kaW5nQ2xpZW50UmVjdDppfX1KdD1cIm9uc2VsZWN0c3RhcnRcImluIGRvY3VtZW50PyhYdD1mdW5jdGlvbigpe3ppKHdpbmRvdyxcInNlbGVjdHN0YXJ0XCIsUmkpfSxmdW5jdGlvbigpe1NpKHdpbmRvdyxcInNlbGVjdHN0YXJ0XCIsUmkpfSk6KFl0PWZpKFtcInVzZXJTZWxlY3RcIixcIldlYmtpdFVzZXJTZWxlY3RcIixcIk9Vc2VyU2VsZWN0XCIsXCJNb3pVc2VyU2VsZWN0XCIsXCJtc1VzZXJTZWxlY3RcIl0pLFh0PWZ1bmN0aW9uKCl7dmFyIHQ7WXQmJih0PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxLdD10W1l0XSx0W1l0XT1cIm5vbmVcIil9LGZ1bmN0aW9uKCl7WXQmJihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbWXRdPUt0LEt0PXZvaWQgMCl9KTt2YXIgTWk9e1RSQU5TRk9STTp0aSxUUkFOU0lUSU9OOmlpLFRSQU5TSVRJT05fRU5EOmVpLGdldDpuaSxnZXRTdHlsZTpvaSxjcmVhdGU6c2kscmVtb3ZlOnJpLGVtcHR5OmFpLHRvRnJvbnQ6aGksdG9CYWNrOnVpLGhhc0NsYXNzOmxpLGFkZENsYXNzOmNpLHJlbW92ZUNsYXNzOl9pLHNldENsYXNzOmRpLGdldENsYXNzOnBpLHNldE9wYWNpdHk6bWksdGVzdFByb3A6Zmksc2V0VHJhbnNmb3JtOmdpLHNldFBvc2l0aW9uOnZpLGdldFBvc2l0aW9uOnlpLGRpc2FibGVUZXh0U2VsZWN0aW9uOlh0LGVuYWJsZVRleHRTZWxlY3Rpb246SnQsZGlzYWJsZUltYWdlRHJhZzp4aSxlbmFibGVJbWFnZURyYWc6d2kscHJldmVudE91dGxpbmU6UGkscmVzdG9yZU91dGxpbmU6TGksZ2V0U2l6ZWRQYXJlbnROb2RlOmJpLGdldFNjYWxlOlRpfTtmdW5jdGlvbiB6aSh0LGksZSxuKXtpZihcIm9iamVjdFwiPT10eXBlb2YgaSlmb3IodmFyIG8gaW4gaSlraSh0LG8saVtvXSxlKTtlbHNlIGZvcih2YXIgcz0wLHI9KGk9bChpKSkubGVuZ3RoO3M8cjtzKyspa2kodCxpW3NdLGUsbik7cmV0dXJuIHRoaXN9dmFyIENpPVwiX2xlYWZsZXRfZXZlbnRzXCI7ZnVuY3Rpb24gU2kodCxpLGUsbil7aWYoXCJvYmplY3RcIj09dHlwZW9mIGkpZm9yKHZhciBvIGluIGkpQmkodCxvLGlbb10sZSk7ZWxzZSBpZihpKWZvcih2YXIgcz0wLHI9KGk9bChpKSkubGVuZ3RoO3M8cjtzKyspQmkodCxpW3NdLGUsbik7ZWxzZXtmb3IodmFyIGEgaW4gdFtDaV0pQmkodCxhLHRbQ2ldW2FdKTtkZWxldGUgdFtDaV19cmV0dXJuIHRoaXN9ZnVuY3Rpb24gWmkoKXtyZXR1cm4gTHQmJighZXQmJiFjdCl9dmFyIEVpPXttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIsd2hlZWw6IShcIm9ud2hlZWxcImluIHdpbmRvdykmJlwibW91c2V3aGVlbFwifTtmdW5jdGlvbiBraShpLHQsZSxuKXt2YXIgbz10K20oZSkrKG4/XCJfXCIrbShuKTpcIlwiKTtpZihpW0NpXSYmaVtDaV1bb10pcmV0dXJuIHRoaXM7dmFyIHMscixhLGgsdSxsLGM9ZnVuY3Rpb24odCl7cmV0dXJuIGUuY2FsbChufHxpLHR8fHdpbmRvdy5ldmVudCl9LF89YztmdW5jdGlvbiBkKHQpe2lmKEx0KXtpZighdC5pc1ByaW1hcnkpcmV0dXJuO2lmKFwibW91c2VcIj09PXQucG9pbnRlclR5cGUpcmV0dXJufWVsc2UgaWYoMTx0LnRvdWNoZXMubGVuZ3RoKXJldHVybjt2YXIgaT1EYXRlLm5vdygpLGU9aS0oaHx8aSk7dT10LnRvdWNoZXM/dC50b3VjaGVzWzBdOnQsbD0wPGUmJmU8PTI1MCxoPWl9ZnVuY3Rpb24gcCh0KXtpZihsJiYhdS5jYW5jZWxCdWJibGUpe2lmKEx0KXtpZihcIm1vdXNlXCI9PT10LnBvaW50ZXJUeXBlKXJldHVybjt2YXIgaSxlLG49e307Zm9yKGUgaW4gdSlpPXVbZV0sbltlXT1pJiZpLmJpbmQ/aS5iaW5kKHUpOmk7dT1ufXUudHlwZT1cImRibGNsaWNrXCIsdS5idXR0b249MCxyKHUpLGg9bnVsbH19THQmJjA9PT10LmluZGV4T2YoXCJ0b3VjaFwiKT9qdChpLHQsYyxvKTpidCYmXCJkYmxjbGlja1wiPT09dCYmIVppKCk/KHI9YyxsPSExLChzPWkpW0d0K1Z0KyhhPW8pXT1kLHNbR3QrcXQrYV09cCxzW0d0K1wiZGJsY2xpY2tcIithXT1yLHMuYWRkRXZlbnRMaXN0ZW5lcihWdCxkLCEhQ3QmJntwYXNzaXZlOiExfSkscy5hZGRFdmVudExpc3RlbmVyKHF0LHAsISFDdCYme3Bhc3NpdmU6ITF9KSxzLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLHIsITEpKTpcImFkZEV2ZW50TGlzdGVuZXJcImluIGk/XCJ0b3VjaHN0YXJ0XCI9PT10fHxcInRvdWNobW92ZVwiPT09dHx8XCJ3aGVlbFwiPT09dHx8XCJtb3VzZXdoZWVsXCI9PT10P2kuYWRkRXZlbnRMaXN0ZW5lcihFaVt0XXx8dCxjLCEhQ3QmJntwYXNzaXZlOiExfSk6XCJtb3VzZWVudGVyXCI9PT10fHxcIm1vdXNlbGVhdmVcIj09PXQ/KGM9ZnVuY3Rpb24odCl7dD10fHx3aW5kb3cuZXZlbnQsVmkoaSx0KSYmXyh0KX0saS5hZGRFdmVudExpc3RlbmVyKEVpW3RdLGMsITEpKTppLmFkZEV2ZW50TGlzdGVuZXIodCxfLCExKTpcImF0dGFjaEV2ZW50XCJpbiBpJiZpLmF0dGFjaEV2ZW50KFwib25cIit0LGMpLGlbQ2ldPWlbQ2ldfHx7fSxpW0NpXVtvXT1jfWZ1bmN0aW9uIEJpKHQsaSxlLG4pe3ZhciBvLHMscixhLGgsdSxsLGMsXz1pK20oZSkrKG4/XCJfXCIrbShuKTpcIlwiKSxkPXRbQ2ldJiZ0W0NpXVtfXTtpZighZClyZXR1cm4gdGhpcztMdCYmMD09PWkuaW5kZXhPZihcInRvdWNoXCIpPyhjPSh1PXQpW1wiX2xlYWZsZXRfXCIrKGw9aSkrX10sXCJ0b3VjaHN0YXJ0XCI9PT1sP3UucmVtb3ZlRXZlbnRMaXN0ZW5lcihBdCxjLCExKTpcInRvdWNobW92ZVwiPT09bD91LnJlbW92ZUV2ZW50TGlzdGVuZXIoSXQsYywhMSk6XCJ0b3VjaGVuZFwiPT09bCYmKHUucmVtb3ZlRXZlbnRMaXN0ZW5lcihPdCxjLCExKSx1LnJlbW92ZUV2ZW50TGlzdGVuZXIoUnQsYywhMSkpKTpidCYmXCJkYmxjbGlja1wiPT09aSYmIVppKCk/KHI9KG89dClbR3QrVnQrKHM9XyldLGE9b1tHdCtxdCtzXSxoPW9bR3QrXCJkYmxjbGlja1wiK3NdLG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihWdCxyLCEhQ3QmJntwYXNzaXZlOiExfSksby5yZW1vdmVFdmVudExpc3RlbmVyKHF0LGEsISFDdCYme3Bhc3NpdmU6ITF9KSxvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLGgsITEpKTpcInJlbW92ZUV2ZW50TGlzdGVuZXJcImluIHQ/dC5yZW1vdmVFdmVudExpc3RlbmVyKEVpW2ldfHxpLGQsITEpOlwiZGV0YWNoRXZlbnRcImluIHQmJnQuZGV0YWNoRXZlbnQoXCJvblwiK2ksZCksdFtDaV1bX109bnVsbH1mdW5jdGlvbiBBaSh0KXtyZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24/dC5zdG9wUHJvcGFnYXRpb24oKTp0Lm9yaWdpbmFsRXZlbnQ/dC5vcmlnaW5hbEV2ZW50Ll9zdG9wcGVkPSEwOnQuY2FuY2VsQnViYmxlPSEwLFVpKHQpLHRoaXN9ZnVuY3Rpb24gSWkodCl7cmV0dXJuIGtpKHQsXCJ3aGVlbFwiLEFpKSx0aGlzfWZ1bmN0aW9uIE9pKHQpe3JldHVybiB6aSh0LFwibW91c2Vkb3duIHRvdWNoc3RhcnQgZGJsY2xpY2tcIixBaSksa2kodCxcImNsaWNrXCIsRmkpLHRoaXN9ZnVuY3Rpb24gUmkodCl7cmV0dXJuIHQucHJldmVudERlZmF1bHQ/dC5wcmV2ZW50RGVmYXVsdCgpOnQucmV0dXJuVmFsdWU9ITEsdGhpc31mdW5jdGlvbiBOaSh0KXtyZXR1cm4gUmkodCksQWkodCksdGhpc31mdW5jdGlvbiBEaSh0LGkpe2lmKCFpKXJldHVybiBuZXcgayh0LmNsaWVudFgsdC5jbGllbnRZKTt2YXIgZT1UaShpKSxuPWUuYm91bmRpbmdDbGllbnRSZWN0O3JldHVybiBuZXcgaygodC5jbGllbnRYLW4ubGVmdCkvZS54LWkuY2xpZW50TGVmdCwodC5jbGllbnRZLW4udG9wKS9lLnktaS5jbGllbnRUb3ApfXZhciBqaT1wdCYmdXQ/Mip3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzpsdD93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbzoxO2Z1bmN0aW9uIFdpKHQpe3JldHVybiBldD90LndoZWVsRGVsdGFZLzI6dC5kZWx0YVkmJjA9PT10LmRlbHRhTW9kZT8tdC5kZWx0YVkvamk6dC5kZWx0YVkmJjE9PT10LmRlbHRhTW9kZT8yMCotdC5kZWx0YVk6dC5kZWx0YVkmJjI9PT10LmRlbHRhTW9kZT82MCotdC5kZWx0YVk6dC5kZWx0YVh8fHQuZGVsdGFaPzA6dC53aGVlbERlbHRhPyh0LndoZWVsRGVsdGFZfHx0LndoZWVsRGVsdGEpLzI6dC5kZXRhaWwmJk1hdGguYWJzKHQuZGV0YWlsKTwzMjc2NT8yMCotdC5kZXRhaWw6dC5kZXRhaWw/dC5kZXRhaWwvLTMyNzY1KjYwOjB9dmFyIEhpPXt9O2Z1bmN0aW9uIEZpKHQpe0hpW3QudHlwZV09ITB9ZnVuY3Rpb24gVWkodCl7dmFyIGk9SGlbdC50eXBlXTtyZXR1cm4gSGlbdC50eXBlXT0hMSxpfWZ1bmN0aW9uIFZpKHQsaSl7dmFyIGU9aS5yZWxhdGVkVGFyZ2V0O2lmKCFlKXJldHVybiEwO3RyeXtmb3IoO2UmJmUhPT10OyllPWUucGFyZW50Tm9kZX1jYXRjaCh0KXtyZXR1cm4hMX1yZXR1cm4gZSE9PXR9dmFyIHFpPXtvbjp6aSxvZmY6U2ksc3RvcFByb3BhZ2F0aW9uOkFpLGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjpJaSxkaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbjpPaSxwcmV2ZW50RGVmYXVsdDpSaSxzdG9wOk5pLGdldE1vdXNlUG9zaXRpb246RGksZ2V0V2hlZWxEZWx0YTpXaSxmYWtlU3RvcDpGaSxza2lwcGVkOlVpLGlzRXh0ZXJuYWxUYXJnZXQ6VmksYWRkTGlzdGVuZXI6emkscmVtb3ZlTGlzdGVuZXI6U2l9LEdpPUUuZXh0ZW5kKHtydW46ZnVuY3Rpb24odCxpLGUsbil7dGhpcy5zdG9wKCksdGhpcy5fZWw9dCx0aGlzLl9pblByb2dyZXNzPSEwLHRoaXMuX2R1cmF0aW9uPWV8fC4yNSx0aGlzLl9lYXNlT3V0UG93ZXI9MS9NYXRoLm1heChufHwuNSwuMiksdGhpcy5fc3RhcnRQb3M9eWkodCksdGhpcy5fb2Zmc2V0PWkuc3VidHJhY3QodGhpcy5fc3RhcnRQb3MpLHRoaXMuX3N0YXJ0VGltZT0rbmV3IERhdGUsdGhpcy5maXJlKFwic3RhcnRcIiksdGhpcy5fYW5pbWF0ZSgpfSxzdG9wOmZ1bmN0aW9uKCl7dGhpcy5faW5Qcm9ncmVzcyYmKHRoaXMuX3N0ZXAoITApLHRoaXMuX2NvbXBsZXRlKCkpfSxfYW5pbWF0ZTpmdW5jdGlvbigpe3RoaXMuX2FuaW1JZD1NKHRoaXMuX2FuaW1hdGUsdGhpcyksdGhpcy5fc3RlcCgpfSxfc3RlcDpmdW5jdGlvbih0KXt2YXIgaT1uZXcgRGF0ZS10aGlzLl9zdGFydFRpbWUsZT0xZTMqdGhpcy5fZHVyYXRpb247aTxlP3RoaXMuX3J1bkZyYW1lKHRoaXMuX2Vhc2VPdXQoaS9lKSx0KToodGhpcy5fcnVuRnJhbWUoMSksdGhpcy5fY29tcGxldGUoKSl9LF9ydW5GcmFtZTpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuX3N0YXJ0UG9zLmFkZCh0aGlzLl9vZmZzZXQubXVsdGlwbHlCeSh0KSk7aSYmZS5fcm91bmQoKSx2aSh0aGlzLl9lbCxlKSx0aGlzLmZpcmUoXCJzdGVwXCIpfSxfY29tcGxldGU6ZnVuY3Rpb24oKXt6KHRoaXMuX2FuaW1JZCksdGhpcy5faW5Qcm9ncmVzcz0hMSx0aGlzLmZpcmUoXCJlbmRcIil9LF9lYXNlT3V0OmZ1bmN0aW9uKHQpe3JldHVybiAxLU1hdGgucG93KDEtdCx0aGlzLl9lYXNlT3V0UG93ZXIpfX0pLEtpPUUuZXh0ZW5kKHtvcHRpb25zOntjcnM6WSxjZW50ZXI6dm9pZCAwLHpvb206dm9pZCAwLG1pblpvb206dm9pZCAwLG1heFpvb206dm9pZCAwLGxheWVyczpbXSxtYXhCb3VuZHM6dm9pZCAwLHJlbmRlcmVyOnZvaWQgMCx6b29tQW5pbWF0aW9uOiEwLHpvb21BbmltYXRpb25UaHJlc2hvbGQ6NCxmYWRlQW5pbWF0aW9uOiEwLG1hcmtlclpvb21BbmltYXRpb246ITAsdHJhbnNmb3JtM0RMaW1pdDo4Mzg4NjA4LHpvb21TbmFwOjEsem9vbURlbHRhOjEsdHJhY2tSZXNpemU6ITB9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxpKXtpPWModGhpcyxpKSx0aGlzLl9oYW5kbGVycz1bXSx0aGlzLl9sYXllcnM9e30sdGhpcy5fem9vbUJvdW5kTGF5ZXJzPXt9LHRoaXMuX3NpemVDaGFuZ2VkPSEwLHRoaXMuX2luaXRDb250YWluZXIodCksdGhpcy5faW5pdExheW91dCgpLHRoaXMuX29uUmVzaXplPXAodGhpcy5fb25SZXNpemUsdGhpcyksdGhpcy5faW5pdEV2ZW50cygpLGkubWF4Qm91bmRzJiZ0aGlzLnNldE1heEJvdW5kcyhpLm1heEJvdW5kcyksdm9pZCAwIT09aS56b29tJiYodGhpcy5fem9vbT10aGlzLl9saW1pdFpvb20oaS56b29tKSksaS5jZW50ZXImJnZvaWQgMCE9PWkuem9vbSYmdGhpcy5zZXRWaWV3KGooaS5jZW50ZXIpLGkuem9vbSx7cmVzZXQ6ITB9KSx0aGlzLmNhbGxJbml0SG9va3MoKSx0aGlzLl96b29tQW5pbWF0ZWQ9aWkmJnZ0JiYhVHQmJnRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uLHRoaXMuX3pvb21BbmltYXRlZCYmKHRoaXMuX2NyZWF0ZUFuaW1Qcm94eSgpLHppKHRoaXMuX3Byb3h5LGVpLHRoaXMuX2NhdGNoVHJhbnNpdGlvbkVuZCx0aGlzKSksdGhpcy5fYWRkTGF5ZXJzKHRoaXMub3B0aW9ucy5sYXllcnMpfSxzZXRWaWV3OmZ1bmN0aW9uKHQsaSxlKXtpZigoaT12b2lkIDA9PT1pP3RoaXMuX3pvb206dGhpcy5fbGltaXRab29tKGkpLHQ9dGhpcy5fbGltaXRDZW50ZXIoaih0KSxpLHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpLGU9ZXx8e30sdGhpcy5fc3RvcCgpLHRoaXMuX2xvYWRlZCYmIWUucmVzZXQmJiEwIT09ZSkmJih2b2lkIDAhPT1lLmFuaW1hdGUmJihlLnpvb209aCh7YW5pbWF0ZTplLmFuaW1hdGV9LGUuem9vbSksZS5wYW49aCh7YW5pbWF0ZTplLmFuaW1hdGUsZHVyYXRpb246ZS5kdXJhdGlvbn0sZS5wYW4pKSx0aGlzLl96b29tIT09aT90aGlzLl90cnlBbmltYXRlZFpvb20mJnRoaXMuX3RyeUFuaW1hdGVkWm9vbSh0LGksZS56b29tKTp0aGlzLl90cnlBbmltYXRlZFBhbih0LGUucGFuKSkpcmV0dXJuIGNsZWFyVGltZW91dCh0aGlzLl9zaXplVGltZXIpLHRoaXM7cmV0dXJuIHRoaXMuX3Jlc2V0Vmlldyh0LGkpLHRoaXN9LHNldFpvb206ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5fbG9hZGVkP3RoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLHQse3pvb206aX0pOih0aGlzLl96b29tPXQsdGhpcyl9LHpvb21JbjpmdW5jdGlvbih0LGkpe3JldHVybiB0PXR8fCh2dD90aGlzLm9wdGlvbnMuem9vbURlbHRhOjEpLHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tK3QsaSl9LHpvb21PdXQ6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdD10fHwodnQ/dGhpcy5vcHRpb25zLnpvb21EZWx0YToxKSx0aGlzLnNldFpvb20odGhpcy5fem9vbS10LGkpfSxzZXRab29tQXJvdW5kOmZ1bmN0aW9uKHQsaSxlKXt2YXIgbj10aGlzLmdldFpvb21TY2FsZShpKSxvPXRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLHM9KHQgaW5zdGFuY2VvZiBrP3Q6dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHQpKS5zdWJ0cmFjdChvKS5tdWx0aXBseUJ5KDEtMS9uKSxyPXRoaXMuY29udGFpbmVyUG9pbnRUb0xhdExuZyhvLmFkZChzKSk7cmV0dXJuIHRoaXMuc2V0VmlldyhyLGkse3pvb206ZX0pfSxfZ2V0Qm91bmRzQ2VudGVyWm9vbTpmdW5jdGlvbih0LGkpe2k9aXx8e30sdD10LmdldEJvdW5kcz90LmdldEJvdW5kcygpOk4odCk7dmFyIGU9QShpLnBhZGRpbmdUb3BMZWZ0fHxpLnBhZGRpbmd8fFswLDBdKSxuPUEoaS5wYWRkaW5nQm90dG9tUmlnaHR8fGkucGFkZGluZ3x8WzAsMF0pLG89dGhpcy5nZXRCb3VuZHNab29tKHQsITEsZS5hZGQobikpO2lmKChvPVwibnVtYmVyXCI9PXR5cGVvZiBpLm1heFpvb20/TWF0aC5taW4oaS5tYXhab29tLG8pOm8pPT09MS8wKXJldHVybntjZW50ZXI6dC5nZXRDZW50ZXIoKSx6b29tOm99O3ZhciBzPW4uc3VidHJhY3QoZSkuZGl2aWRlQnkoMikscj10aGlzLnByb2plY3QodC5nZXRTb3V0aFdlc3QoKSxvKSxhPXRoaXMucHJvamVjdCh0LmdldE5vcnRoRWFzdCgpLG8pO3JldHVybntjZW50ZXI6dGhpcy51bnByb2plY3Qoci5hZGQoYSkuZGl2aWRlQnkoMikuYWRkKHMpLG8pLHpvb206b319LGZpdEJvdW5kczpmdW5jdGlvbih0LGkpe2lmKCEodD1OKHQpKS5pc1ZhbGlkKCkpdGhyb3cgbmV3IEVycm9yKFwiQm91bmRzIGFyZSBub3QgdmFsaWQuXCIpO3ZhciBlPXRoaXMuX2dldEJvdW5kc0NlbnRlclpvb20odCxpKTtyZXR1cm4gdGhpcy5zZXRWaWV3KGUuY2VudGVyLGUuem9vbSxpKX0sZml0V29ybGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLC0xODBdLFs5MCwxODBdXSx0KX0scGFuVG86ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5zZXRWaWV3KHQsdGhpcy5fem9vbSx7cGFuOml9KX0scGFuQnk6ZnVuY3Rpb24odCxpKXtyZXR1cm4gaT1pfHx7fSwodD1BKHQpLnJvdW5kKCkpLnh8fHQueT8oITA9PT1pLmFuaW1hdGV8fHRoaXMuZ2V0U2l6ZSgpLmNvbnRhaW5zKHQpPyh0aGlzLl9wYW5BbmltfHwodGhpcy5fcGFuQW5pbT1uZXcgR2ksdGhpcy5fcGFuQW5pbS5vbih7c3RlcDp0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLGVuZDp0aGlzLl9vblBhblRyYW5zaXRpb25FbmR9LHRoaXMpKSxpLm5vTW92ZVN0YXJ0fHx0aGlzLmZpcmUoXCJtb3Zlc3RhcnRcIiksITEhPT1pLmFuaW1hdGU/KGNpKHRoaXMuX21hcFBhbmUsXCJsZWFmbGV0LXBhbi1hbmltXCIpLGU9dGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KHQpLnJvdW5kKCksdGhpcy5fcGFuQW5pbS5ydW4odGhpcy5fbWFwUGFuZSxlLGkuZHVyYXRpb258fC4yNSxpLmVhc2VMaW5lYXJpdHkpKToodGhpcy5fcmF3UGFuQnkodCksdGhpcy5maXJlKFwibW92ZVwiKS5maXJlKFwibW92ZWVuZFwiKSkpOnRoaXMuX3Jlc2V0Vmlldyh0aGlzLnVucHJvamVjdCh0aGlzLnByb2plY3QodGhpcy5nZXRDZW50ZXIoKSkuYWRkKHQpKSx0aGlzLmdldFpvb20oKSksdGhpcyk6dGhpcy5maXJlKFwibW92ZWVuZFwiKTt2YXIgZX0sZmx5VG86ZnVuY3Rpb24ocyxyLHQpe2lmKCExPT09KHQ9dHx8e30pLmFuaW1hdGV8fCF2dClyZXR1cm4gdGhpcy5zZXRWaWV3KHMscix0KTt0aGlzLl9zdG9wKCk7dmFyIGE9dGhpcy5wcm9qZWN0KHRoaXMuZ2V0Q2VudGVyKCkpLGg9dGhpcy5wcm9qZWN0KHMpLGk9dGhpcy5nZXRTaXplKCksdT10aGlzLl96b29tO3M9aihzKSxyPXZvaWQgMD09PXI/dTpyO3ZhciBsPU1hdGgubWF4KGkueCxpLnkpLG49bCp0aGlzLmdldFpvb21TY2FsZSh1LHIpLGM9aC5kaXN0YW5jZVRvKGEpfHwxLF89MS40MixvPV8qXztmdW5jdGlvbiBlKHQpe3ZhciBpPShuKm4tbCpsKyh0Py0xOjEpKm8qbypjKmMpLygyKih0P246bCkqbypjKSxlPU1hdGguc3FydChpKmkrMSktaTtyZXR1cm4gZTwxZS05Py0xODpNYXRoLmxvZyhlKX1mdW5jdGlvbiBkKHQpe3JldHVybihNYXRoLmV4cCh0KS1NYXRoLmV4cCgtdCkpLzJ9ZnVuY3Rpb24gcCh0KXtyZXR1cm4oTWF0aC5leHAodCkrTWF0aC5leHAoLXQpKS8yfXZhciBtPWUoMCk7ZnVuY3Rpb24gZih0KXtyZXR1cm4gbCoocChtKSooZChpPW0rXyp0KS9wKGkpKS1kKG0pKS9vO3ZhciBpfXZhciBnPURhdGUubm93KCksdj0oZSgxKS1tKS9fLHk9dC5kdXJhdGlvbj8xZTMqdC5kdXJhdGlvbjoxZTMqdiouODtyZXR1cm4gdGhpcy5fbW92ZVN0YXJ0KCEwLHQubm9Nb3ZlU3RhcnQpLGZ1bmN0aW9uIHQoKXt2YXIgaSxlLG49KERhdGUubm93KCktZykveSxvPShpPW4sKDEtTWF0aC5wb3coMS1pLDEuNSkpKnYpO248PTE/KHRoaXMuX2ZseVRvRnJhbWU9TSh0LHRoaXMpLHRoaXMuX21vdmUodGhpcy51bnByb2plY3QoYS5hZGQoaC5zdWJ0cmFjdChhKS5tdWx0aXBseUJ5KGYobykvYykpLHUpLHRoaXMuZ2V0U2NhbGVab29tKGwvKGU9byxsKihwKG0pL3AobStfKmUpKSksdSkse2ZseVRvOiEwfSkpOnRoaXMuX21vdmUocyxyKS5fbW92ZUVuZCghMCl9LmNhbGwodGhpcyksdGhpc30sZmx5VG9Cb3VuZHM6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLl9nZXRCb3VuZHNDZW50ZXJab29tKHQsaSk7cmV0dXJuIHRoaXMuZmx5VG8oZS5jZW50ZXIsZS56b29tLGkpfSxzZXRNYXhCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuKHQ9Tih0KSkuaXNWYWxpZCgpPyh0aGlzLm9wdGlvbnMubWF4Qm91bmRzJiZ0aGlzLm9mZihcIm1vdmVlbmRcIix0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpLHRoaXMub3B0aW9ucy5tYXhCb3VuZHM9dCx0aGlzLl9sb2FkZWQmJnRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpLHRoaXMub24oXCJtb3ZlZW5kXCIsdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzKSk6KHRoaXMub3B0aW9ucy5tYXhCb3VuZHM9bnVsbCx0aGlzLm9mZihcIm1vdmVlbmRcIix0aGlzLl9wYW5JbnNpZGVNYXhCb3VuZHMpKX0sc2V0TWluWm9vbTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLm9wdGlvbnMubWluWm9vbTtyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb209dCx0aGlzLl9sb2FkZWQmJmkhPT10JiYodGhpcy5maXJlKFwiem9vbWxldmVsc2NoYW5nZVwiKSx0aGlzLmdldFpvb20oKTx0aGlzLm9wdGlvbnMubWluWm9vbSk/dGhpcy5zZXRab29tKHQpOnRoaXN9LHNldE1heFpvb206ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5vcHRpb25zLm1heFpvb207cmV0dXJuIHRoaXMub3B0aW9ucy5tYXhab29tPXQsdGhpcy5fbG9hZGVkJiZpIT09dCYmKHRoaXMuZmlyZShcInpvb21sZXZlbHNjaGFuZ2VcIiksdGhpcy5nZXRab29tKCk+dGhpcy5vcHRpb25zLm1heFpvb20pP3RoaXMuc2V0Wm9vbSh0KTp0aGlzfSxwYW5JbnNpZGVCb3VuZHM6ZnVuY3Rpb24odCxpKXt0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITA7dmFyIGU9dGhpcy5nZXRDZW50ZXIoKSxuPXRoaXMuX2xpbWl0Q2VudGVyKGUsdGhpcy5fem9vbSxOKHQpKTtyZXR1cm4gZS5lcXVhbHMobil8fHRoaXMucGFuVG8obixpKSx0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITEsdGhpc30scGFuSW5zaWRlOmZ1bmN0aW9uKHQsaSl7dmFyIGUsbixvPUEoKGk9aXx8e30pLnBhZGRpbmdUb3BMZWZ0fHxpLnBhZGRpbmd8fFswLDBdKSxzPUEoaS5wYWRkaW5nQm90dG9tUmlnaHR8fGkucGFkZGluZ3x8WzAsMF0pLHI9dGhpcy5nZXRDZW50ZXIoKSxhPXRoaXMucHJvamVjdChyKSxoPXRoaXMucHJvamVjdCh0KSx1PXRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxsPXUuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLGM9TyhbdS5taW4uYWRkKG8pLHUubWF4LnN1YnRyYWN0KHMpXSk7cmV0dXJuIGMuY29udGFpbnMoaCl8fCh0aGlzLl9lbmZvcmNpbmdCb3VuZHM9ITAsZT1hLnN1YnRyYWN0KGgpLG49QShoLngrZS54LGgueStlLnkpLChoLng8Yy5taW4ueHx8aC54PmMubWF4LngpJiYobi54PWEueC1lLngsMDxlLng/bi54Kz1sLngtby54Om4ueC09bC54LXMueCksKGgueTxjLm1pbi55fHxoLnk+Yy5tYXgueSkmJihuLnk9YS55LWUueSwwPGUueT9uLnkrPWwueS1vLnk6bi55LT1sLnktcy55KSx0aGlzLnBhblRvKHRoaXMudW5wcm9qZWN0KG4pLGkpLHRoaXMuX2VuZm9yY2luZ0JvdW5kcz0hMSksdGhpc30saW52YWxpZGF0ZVNpemU6ZnVuY3Rpb24odCl7aWYoIXRoaXMuX2xvYWRlZClyZXR1cm4gdGhpczt0PWgoe2FuaW1hdGU6ITEscGFuOiEwfSwhMD09PXQ/e2FuaW1hdGU6ITB9OnQpO3ZhciBpPXRoaXMuZ2V0U2l6ZSgpO3RoaXMuX3NpemVDaGFuZ2VkPSEwLHRoaXMuX2xhc3RDZW50ZXI9bnVsbDt2YXIgZT10aGlzLmdldFNpemUoKSxuPWkuZGl2aWRlQnkoMikucm91bmQoKSxvPWUuZGl2aWRlQnkoMikucm91bmQoKSxzPW4uc3VidHJhY3Qobyk7cmV0dXJuIHMueHx8cy55Pyh0LmFuaW1hdGUmJnQucGFuP3RoaXMucGFuQnkocyk6KHQucGFuJiZ0aGlzLl9yYXdQYW5CeShzKSx0aGlzLmZpcmUoXCJtb3ZlXCIpLHQuZGVib3VuY2VNb3ZlZW5kPyhjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKSx0aGlzLl9zaXplVGltZXI9c2V0VGltZW91dChwKHRoaXMuZmlyZSx0aGlzLFwibW92ZWVuZFwiKSwyMDApKTp0aGlzLmZpcmUoXCJtb3ZlZW5kXCIpKSx0aGlzLmZpcmUoXCJyZXNpemVcIix7b2xkU2l6ZTppLG5ld1NpemU6ZX0pKTp0aGlzfSxzdG9wOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl9saW1pdFpvb20odGhpcy5fem9vbSkpLHRoaXMub3B0aW9ucy56b29tU25hcHx8dGhpcy5maXJlKFwidmlld3Jlc2V0XCIpLHRoaXMuX3N0b3AoKX0sbG9jYXRlOmZ1bmN0aW9uKHQpe2lmKHQ9dGhpcy5fbG9jYXRlT3B0aW9ucz1oKHt0aW1lb3V0OjFlNCx3YXRjaDohMX0sdCksIShcImdlb2xvY2F0aW9uXCJpbiBuYXZpZ2F0b3IpKXJldHVybiB0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtjb2RlOjAsbWVzc2FnZTpcIkdlb2xvY2F0aW9uIG5vdCBzdXBwb3J0ZWQuXCJ9KSx0aGlzO3ZhciBpPXAodGhpcy5faGFuZGxlR2VvbG9jYXRpb25SZXNwb25zZSx0aGlzKSxlPXAodGhpcy5faGFuZGxlR2VvbG9jYXRpb25FcnJvcix0aGlzKTtyZXR1cm4gdC53YXRjaD90aGlzLl9sb2NhdGlvbldhdGNoSWQ9bmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24oaSxlLHQpOm5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oaSxlLHQpLHRoaXN9LHN0b3BMb2NhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gbmF2aWdhdG9yLmdlb2xvY2F0aW9uJiZuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCYmbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2godGhpcy5fbG9jYXRpb25XYXRjaElkKSx0aGlzLl9sb2NhdGVPcHRpb25zJiYodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3PSExKSx0aGlzfSxfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjpmdW5jdGlvbih0KXt2YXIgaT10LmNvZGUsZT10Lm1lc3NhZ2V8fCgxPT09aT9cInBlcm1pc3Npb24gZGVuaWVkXCI6Mj09PWk/XCJwb3NpdGlvbiB1bmF2YWlsYWJsZVwiOlwidGltZW91dFwiKTt0aGlzLl9sb2NhdGVPcHRpb25zLnNldFZpZXcmJiF0aGlzLl9sb2FkZWQmJnRoaXMuZml0V29ybGQoKSx0aGlzLmZpcmUoXCJsb2NhdGlvbmVycm9yXCIse2NvZGU6aSxtZXNzYWdlOlwiR2VvbG9jYXRpb24gZXJyb3I6IFwiK2UrXCIuXCJ9KX0sX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6ZnVuY3Rpb24odCl7dmFyIGksZT1uZXcgRCh0LmNvb3Jkcy5sYXRpdHVkZSx0LmNvb3Jkcy5sb25naXR1ZGUpLG49ZS50b0JvdW5kcygyKnQuY29vcmRzLmFjY3VyYWN5KSxvPXRoaXMuX2xvY2F0ZU9wdGlvbnM7by5zZXRWaWV3JiYoaT10aGlzLmdldEJvdW5kc1pvb20obiksdGhpcy5zZXRWaWV3KGUsby5tYXhab29tP01hdGgubWluKGksby5tYXhab29tKTppKSk7dmFyIHM9e2xhdGxuZzplLGJvdW5kczpuLHRpbWVzdGFtcDp0LnRpbWVzdGFtcH07Zm9yKHZhciByIGluIHQuY29vcmRzKVwibnVtYmVyXCI9PXR5cGVvZiB0LmNvb3Jkc1tyXSYmKHNbcl09dC5jb29yZHNbcl0pO3RoaXMuZmlyZShcImxvY2F0aW9uZm91bmRcIixzKX0sYWRkSGFuZGxlcjpmdW5jdGlvbih0LGkpe2lmKCFpKXJldHVybiB0aGlzO3ZhciBlPXRoaXNbdF09bmV3IGkodGhpcyk7cmV0dXJuIHRoaXMuX2hhbmRsZXJzLnB1c2goZSksdGhpcy5vcHRpb25zW3RdJiZlLmVuYWJsZSgpLHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe2lmKHRoaXMuX2luaXRFdmVudHMoITApLHRoaXMub2ZmKFwibW92ZWVuZFwiLHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcyksdGhpcy5fY29udGFpbmVySWQhPT10aGlzLl9jb250YWluZXIuX2xlYWZsZXRfaWQpdGhyb3cgbmV3IEVycm9yKFwiTWFwIGNvbnRhaW5lciBpcyBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBpbnN0YW5jZVwiKTt0cnl7ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldF9pZCxkZWxldGUgdGhpcy5fY29udGFpbmVySWR9Y2F0Y2godCl7dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0X2lkPXZvaWQgMCx0aGlzLl9jb250YWluZXJJZD12b2lkIDB9dmFyIHQ7Zm9yKHQgaW4gdm9pZCAwIT09dGhpcy5fbG9jYXRpb25XYXRjaElkJiZ0aGlzLnN0b3BMb2NhdGUoKSx0aGlzLl9zdG9wKCkscmkodGhpcy5fbWFwUGFuZSksdGhpcy5fY2xlYXJDb250cm9sUG9zJiZ0aGlzLl9jbGVhckNvbnRyb2xQb3MoKSx0aGlzLl9yZXNpemVSZXF1ZXN0JiYoeih0aGlzLl9yZXNpemVSZXF1ZXN0KSx0aGlzLl9yZXNpemVSZXF1ZXN0PW51bGwpLHRoaXMuX2NsZWFySGFuZGxlcnMoKSx0aGlzLl9sb2FkZWQmJnRoaXMuZmlyZShcInVubG9hZFwiKSx0aGlzLl9sYXllcnMpdGhpcy5fbGF5ZXJzW3RdLnJlbW92ZSgpO2Zvcih0IGluIHRoaXMuX3BhbmVzKXJpKHRoaXMuX3BhbmVzW3RdKTtyZXR1cm4gdGhpcy5fbGF5ZXJzPVtdLHRoaXMuX3BhbmVzPVtdLGRlbGV0ZSB0aGlzLl9tYXBQYW5lLGRlbGV0ZSB0aGlzLl9yZW5kZXJlcix0aGlzfSxjcmVhdGVQYW5lOmZ1bmN0aW9uKHQsaSl7dmFyIGU9c2koXCJkaXZcIixcImxlYWZsZXQtcGFuZVwiKyh0P1wiIGxlYWZsZXQtXCIrdC5yZXBsYWNlKFwiUGFuZVwiLFwiXCIpK1wiLXBhbmVcIjpcIlwiKSxpfHx0aGlzLl9tYXBQYW5lKTtyZXR1cm4gdCYmKHRoaXMuX3BhbmVzW3RdPWUpLGV9LGdldENlbnRlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jaGVja0lmTG9hZGVkKCksdGhpcy5fbGFzdENlbnRlciYmIXRoaXMuX21vdmVkKCk/dGhpcy5fbGFzdENlbnRlcjp0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpfSxnZXRab29tOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3pvb219LGdldEJvdW5kczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0UGl4ZWxCb3VuZHMoKTtyZXR1cm4gbmV3IFIodGhpcy51bnByb2plY3QodC5nZXRCb3R0b21MZWZ0KCkpLHRoaXMudW5wcm9qZWN0KHQuZ2V0VG9wUmlnaHQoKSkpfSxnZXRNaW5ab29tOmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMub3B0aW9ucy5taW5ab29tP3RoaXMuX2xheWVyc01pblpvb218fDA6dGhpcy5vcHRpb25zLm1pblpvb219LGdldE1heFpvb206ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5vcHRpb25zLm1heFpvb20/dm9pZCAwPT09dGhpcy5fbGF5ZXJzTWF4Wm9vbT8xLzA6dGhpcy5fbGF5ZXJzTWF4Wm9vbTp0aGlzLm9wdGlvbnMubWF4Wm9vbX0sZ2V0Qm91bmRzWm9vbTpmdW5jdGlvbih0LGksZSl7dD1OKHQpLGU9QShlfHxbMCwwXSk7dmFyIG49dGhpcy5nZXRab29tKCl8fDAsbz10aGlzLmdldE1pblpvb20oKSxzPXRoaXMuZ2V0TWF4Wm9vbSgpLHI9dC5nZXROb3J0aFdlc3QoKSxhPXQuZ2V0U291dGhFYXN0KCksaD10aGlzLmdldFNpemUoKS5zdWJ0cmFjdChlKSx1PU8odGhpcy5wcm9qZWN0KGEsbiksdGhpcy5wcm9qZWN0KHIsbikpLmdldFNpemUoKSxsPXZ0P3RoaXMub3B0aW9ucy56b29tU25hcDoxLGM9aC54L3UueCxfPWgueS91LnksZD1pP01hdGgubWF4KGMsXyk6TWF0aC5taW4oYyxfKSxuPXRoaXMuZ2V0U2NhbGVab29tKGQsbik7cmV0dXJuIGwmJihuPU1hdGgucm91bmQobi8obC8xMDApKSoobC8xMDApLG49aT9NYXRoLmNlaWwobi9sKSpsOk1hdGguZmxvb3Iobi9sKSpsKSxNYXRoLm1heChvLE1hdGgubWluKHMsbikpfSxnZXRTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NpemUmJiF0aGlzLl9zaXplQ2hhbmdlZHx8KHRoaXMuX3NpemU9bmV3IGsodGhpcy5fY29udGFpbmVyLmNsaWVudFdpZHRofHwwLHRoaXMuX2NvbnRhaW5lci5jbGllbnRIZWlnaHR8fDApLHRoaXMuX3NpemVDaGFuZ2VkPSExKSx0aGlzLl9zaXplLmNsb25lKCl9LGdldFBpeGVsQm91bmRzOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5fZ2V0VG9wTGVmdFBvaW50KHQsaSk7cmV0dXJuIG5ldyBJKGUsZS5hZGQodGhpcy5nZXRTaXplKCkpKX0sZ2V0UGl4ZWxPcmlnaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY2hlY2tJZkxvYWRlZCgpLHRoaXMuX3BpeGVsT3JpZ2lufSxnZXRQaXhlbFdvcmxkQm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuY3JzLmdldFByb2plY3RlZEJvdW5kcyh2b2lkIDA9PT10P3RoaXMuZ2V0Wm9vbSgpOnQpfSxnZXRQYW5lOmZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P3RoaXMuX3BhbmVzW3RdOnR9LGdldFBhbmVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhbmVzfSxnZXRDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbmVyfSxnZXRab29tU2NhbGU6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLm9wdGlvbnMuY3JzO3JldHVybiBpPXZvaWQgMD09PWk/dGhpcy5fem9vbTppLGUuc2NhbGUodCkvZS5zY2FsZShpKX0sZ2V0U2NhbGVab29tOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5vcHRpb25zLmNycztpPXZvaWQgMD09PWk/dGhpcy5fem9vbTppO3ZhciBuPWUuem9vbSh0KmUuc2NhbGUoaSkpO3JldHVybiBpc05hTihuKT8xLzA6bn0scHJvamVjdDpmdW5jdGlvbih0LGkpe3JldHVybiBpPXZvaWQgMD09PWk/dGhpcy5fem9vbTppLHRoaXMub3B0aW9ucy5jcnMubGF0TG5nVG9Qb2ludChqKHQpLGkpfSx1bnByb2plY3Q6ZnVuY3Rpb24odCxpKXtyZXR1cm4gaT12b2lkIDA9PT1pP3RoaXMuX3pvb206aSx0aGlzLm9wdGlvbnMuY3JzLnBvaW50VG9MYXRMbmcoQSh0KSxpKX0sbGF5ZXJQb2ludFRvTGF0TG5nOmZ1bmN0aW9uKHQpe3ZhciBpPUEodCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7cmV0dXJuIHRoaXMudW5wcm9qZWN0KGkpfSxsYXRMbmdUb0xheWVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHJvamVjdChqKHQpKS5fcm91bmQoKS5fc3VidHJhY3QodGhpcy5nZXRQaXhlbE9yaWdpbigpKX0sd3JhcExhdExuZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLmNycy53cmFwTGF0TG5nKGoodCkpfSx3cmFwTGF0TG5nQm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuY3JzLndyYXBMYXRMbmdCb3VuZHMoTih0KSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMuZGlzdGFuY2Uoaih0KSxqKGkpKX0sY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIEEodCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKX0sbGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIEEodCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSl9LGNvbnRhaW5lclBvaW50VG9MYXRMbmc6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChBKHQpKTtyZXR1cm4gdGhpcy5sYXllclBvaW50VG9MYXRMbmcoaSl9LGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQodGhpcy5sYXRMbmdUb0xheWVyUG9pbnQoaih0KSkpfSxtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gRGkodCx0aGlzLl9jb250YWluZXIpfSxtb3VzZUV2ZW50VG9MYXllclBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KHRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCkpfSxtb3VzZUV2ZW50VG9MYXRMbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludCh0KSl9LF9pbml0Q29udGFpbmVyOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX2NvbnRhaW5lcj1uaSh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoXCJNYXAgY29udGFpbmVyIG5vdCBmb3VuZC5cIik7aWYoaS5fbGVhZmxldF9pZCl0aHJvdyBuZXcgRXJyb3IoXCJNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO3ppKGksXCJzY3JvbGxcIix0aGlzLl9vblNjcm9sbCx0aGlzKSx0aGlzLl9jb250YWluZXJJZD1tKGkpfSxfaW5pdExheW91dDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NvbnRhaW5lcjt0aGlzLl9mYWRlQW5pbWF0ZWQ9dGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24mJnZ0LGNpKHQsXCJsZWFmbGV0LWNvbnRhaW5lclwiKyhidD9cIiBsZWFmbGV0LXRvdWNoXCI6XCJcIikrKHp0P1wiIGxlYWZsZXQtcmV0aW5hXCI6XCJcIikrKGl0P1wiIGxlYWZsZXQtb2xkaWVcIjpcIlwiKSsoY3Q/XCIgbGVhZmxldC1zYWZhcmlcIjpcIlwiKSsodGhpcy5fZmFkZUFuaW1hdGVkP1wiIGxlYWZsZXQtZmFkZS1hbmltXCI6XCJcIikpO3ZhciBpPW9pKHQsXCJwb3NpdGlvblwiKTtcImFic29sdXRlXCIhPT1pJiZcInJlbGF0aXZlXCIhPT1pJiZcImZpeGVkXCIhPT1pJiYodC5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpLHRoaXMuX2luaXRQYW5lcygpLHRoaXMuX2luaXRDb250cm9sUG9zJiZ0aGlzLl9pbml0Q29udHJvbFBvcygpfSxfaW5pdFBhbmVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcGFuZXM9e307dGhpcy5fcGFuZVJlbmRlcmVycz17fSx0aGlzLl9tYXBQYW5lPXRoaXMuY3JlYXRlUGFuZShcIm1hcFBhbmVcIix0aGlzLl9jb250YWluZXIpLHZpKHRoaXMuX21hcFBhbmUsbmV3IGsoMCwwKSksdGhpcy5jcmVhdGVQYW5lKFwidGlsZVBhbmVcIiksdGhpcy5jcmVhdGVQYW5lKFwic2hhZG93UGFuZVwiKSx0aGlzLmNyZWF0ZVBhbmUoXCJvdmVybGF5UGFuZVwiKSx0aGlzLmNyZWF0ZVBhbmUoXCJtYXJrZXJQYW5lXCIpLHRoaXMuY3JlYXRlUGFuZShcInRvb2x0aXBQYW5lXCIpLHRoaXMuY3JlYXRlUGFuZShcInBvcHVwUGFuZVwiKSx0aGlzLm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbnx8KGNpKHQubWFya2VyUGFuZSxcImxlYWZsZXQtem9vbS1oaWRlXCIpLGNpKHQuc2hhZG93UGFuZSxcImxlYWZsZXQtem9vbS1oaWRlXCIpKX0sX3Jlc2V0VmlldzpmdW5jdGlvbih0LGkpe3ZpKHRoaXMuX21hcFBhbmUsbmV3IGsoMCwwKSk7dmFyIGU9IXRoaXMuX2xvYWRlZDt0aGlzLl9sb2FkZWQ9ITAsaT10aGlzLl9saW1pdFpvb20oaSksdGhpcy5maXJlKFwidmlld3ByZXJlc2V0XCIpO3ZhciBuPXRoaXMuX3pvb20hPT1pO3RoaXMuX21vdmVTdGFydChuLCExKS5fbW92ZSh0LGkpLl9tb3ZlRW5kKG4pLHRoaXMuZmlyZShcInZpZXdyZXNldFwiKSxlJiZ0aGlzLmZpcmUoXCJsb2FkXCIpfSxfbW92ZVN0YXJ0OmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQmJnRoaXMuZmlyZShcInpvb21zdGFydFwiKSxpfHx0aGlzLmZpcmUoXCJtb3Zlc3RhcnRcIiksdGhpc30sX21vdmU6ZnVuY3Rpb24odCxpLGUpe3ZvaWQgMD09PWkmJihpPXRoaXMuX3pvb20pO3ZhciBuPXRoaXMuX3pvb20hPT1pO3JldHVybiB0aGlzLl96b29tPWksdGhpcy5fbGFzdENlbnRlcj10LHRoaXMuX3BpeGVsT3JpZ2luPXRoaXMuX2dldE5ld1BpeGVsT3JpZ2luKHQpLChufHxlJiZlLnBpbmNoKSYmdGhpcy5maXJlKFwiem9vbVwiLGUpLHRoaXMuZmlyZShcIm1vdmVcIixlKX0sX21vdmVFbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuZmlyZShcInpvb21lbmRcIiksdGhpcy5maXJlKFwibW92ZWVuZFwiKX0sX3N0b3A6ZnVuY3Rpb24oKXtyZXR1cm4geih0aGlzLl9mbHlUb0ZyYW1lKSx0aGlzLl9wYW5BbmltJiZ0aGlzLl9wYW5BbmltLnN0b3AoKSx0aGlzfSxfcmF3UGFuQnk6ZnVuY3Rpb24odCl7dmkodGhpcy5fbWFwUGFuZSx0aGlzLl9nZXRNYXBQYW5lUG9zKCkuc3VidHJhY3QodCkpfSxfZ2V0Wm9vbVNwYW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRNYXhab29tKCktdGhpcy5nZXRNaW5ab29tKCl9LF9wYW5JbnNpZGVNYXhCb3VuZHM6ZnVuY3Rpb24oKXt0aGlzLl9lbmZvcmNpbmdCb3VuZHN8fHRoaXMucGFuSW5zaWRlQm91bmRzKHRoaXMub3B0aW9ucy5tYXhCb3VuZHMpfSxfY2hlY2tJZkxvYWRlZDpmdW5jdGlvbigpe2lmKCF0aGlzLl9sb2FkZWQpdGhyb3cgbmV3IEVycm9yKFwiU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuXCIpfSxfaW5pdEV2ZW50czpmdW5jdGlvbih0KXt0aGlzLl90YXJnZXRzPXt9O3ZhciBpPXQ/U2k6emk7aSgodGhpcy5fdGFyZ2V0c1ttKHRoaXMuX2NvbnRhaW5lcildPXRoaXMpLl9jb250YWluZXIsXCJjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2Vtb3ZlIGNvbnRleHRtZW51IGtleXByZXNzIGtleWRvd24ga2V5dXBcIix0aGlzLl9oYW5kbGVET01FdmVudCx0aGlzKSx0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUmJmkod2luZG93LFwicmVzaXplXCIsdGhpcy5fb25SZXNpemUsdGhpcyksdnQmJnRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0JiYodD90aGlzLm9mZjp0aGlzLm9uKS5jYWxsKHRoaXMsXCJtb3ZlZW5kXCIsdGhpcy5fb25Nb3ZlRW5kKX0sX29uUmVzaXplOmZ1bmN0aW9uKCl7eih0aGlzLl9yZXNpemVSZXF1ZXN0KSx0aGlzLl9yZXNpemVSZXF1ZXN0PU0oZnVuY3Rpb24oKXt0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6ITB9KX0sdGhpcyl9LF9vblNjcm9sbDpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3A9MCx0aGlzLl9jb250YWluZXIuc2Nyb2xsTGVmdD0wfSxfb25Nb3ZlRW5kOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZ2V0TWFwUGFuZVBvcygpO01hdGgubWF4KE1hdGguYWJzKHQueCksTWF0aC5hYnModC55KSk+PXRoaXMub3B0aW9ucy50cmFuc2Zvcm0zRExpbWl0JiZ0aGlzLl9yZXNldFZpZXcodGhpcy5nZXRDZW50ZXIoKSx0aGlzLmdldFpvb20oKSl9LF9maW5kRXZlbnRUYXJnZXRzOmZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBlLG49W10sbz1cIm1vdXNlb3V0XCI9PT1pfHxcIm1vdXNlb3ZlclwiPT09aSxzPXQudGFyZ2V0fHx0LnNyY0VsZW1lbnQscj0hMTtzOyl7aWYoKGU9dGhpcy5fdGFyZ2V0c1ttKHMpXSkmJihcImNsaWNrXCI9PT1pfHxcInByZWNsaWNrXCI9PT1pKSYmIXQuX3NpbXVsYXRlZCYmdGhpcy5fZHJhZ2dhYmxlTW92ZWQoZSkpe3I9ITA7YnJlYWt9aWYoZSYmZS5saXN0ZW5zKGksITApKXtpZihvJiYhVmkocyx0KSlicmVhaztpZihuLnB1c2goZSksbylicmVha31pZihzPT09dGhpcy5fY29udGFpbmVyKWJyZWFrO3M9cy5wYXJlbnROb2RlfXJldHVybiBuLmxlbmd0aHx8cnx8b3x8IVZpKHMsdCl8fChuPVt0aGlzXSksbn0sX2hhbmRsZURPTUV2ZW50OmZ1bmN0aW9uKHQpe3ZhciBpO3RoaXMuX2xvYWRlZCYmIVVpKHQpJiYoXCJtb3VzZWRvd25cIiE9PShpPXQudHlwZSkmJlwia2V5cHJlc3NcIiE9PWkmJlwia2V5dXBcIiE9PWkmJlwia2V5ZG93blwiIT09aXx8UGkodC50YXJnZXR8fHQuc3JjRWxlbWVudCksdGhpcy5fZmlyZURPTUV2ZW50KHQsaSkpfSxfbW91c2VFdmVudHM6W1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZW92ZXJcIixcIm1vdXNlb3V0XCIsXCJjb250ZXh0bWVudVwiXSxfZmlyZURPTUV2ZW50OmZ1bmN0aW9uKHQsaSxlKXt2YXIgbjtpZihcImNsaWNrXCI9PT10LnR5cGUmJigobj1oKHt9LHQpKS50eXBlPVwicHJlY2xpY2tcIix0aGlzLl9maXJlRE9NRXZlbnQobixuLnR5cGUsZSkpLCF0Ll9zdG9wcGVkJiYoZT0oZXx8W10pLmNvbmNhdCh0aGlzLl9maW5kRXZlbnRUYXJnZXRzKHQsaSkpKS5sZW5ndGgpe3ZhciBvPWVbMF07XCJjb250ZXh0bWVudVwiPT09aSYmby5saXN0ZW5zKGksITApJiZSaSh0KTt2YXIgcyxyPXtvcmlnaW5hbEV2ZW50OnR9O1wia2V5cHJlc3NcIiE9PXQudHlwZSYmXCJrZXlkb3duXCIhPT10LnR5cGUmJlwia2V5dXBcIiE9PXQudHlwZSYmKHM9by5nZXRMYXRMbmcmJighby5fcmFkaXVzfHxvLl9yYWRpdXM8PTEwKSxyLmNvbnRhaW5lclBvaW50PXM/dGhpcy5sYXRMbmdUb0NvbnRhaW5lclBvaW50KG8uZ2V0TGF0TG5nKCkpOnRoaXMubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCksci5sYXllclBvaW50PXRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoci5jb250YWluZXJQb2ludCksci5sYXRsbmc9cz9vLmdldExhdExuZygpOnRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHIubGF5ZXJQb2ludCkpO2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7YSsrKWlmKGVbYV0uZmlyZShpLHIsITApLHIub3JpZ2luYWxFdmVudC5fc3RvcHBlZHx8ITE9PT1lW2FdLm9wdGlvbnMuYnViYmxpbmdNb3VzZUV2ZW50cyYmLTEhPT12KHRoaXMuX21vdXNlRXZlbnRzLGkpKXJldHVybn19LF9kcmFnZ2FibGVNb3ZlZDpmdW5jdGlvbih0KXtyZXR1cm4odD10LmRyYWdnaW5nJiZ0LmRyYWdnaW5nLmVuYWJsZWQoKT90OnRoaXMpLmRyYWdnaW5nJiZ0LmRyYWdnaW5nLm1vdmVkKCl8fHRoaXMuYm94Wm9vbSYmdGhpcy5ib3hab29tLm1vdmVkKCl9LF9jbGVhckhhbmRsZXJzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsaT10aGlzLl9oYW5kbGVycy5sZW5ndGg7dDxpO3QrKyl0aGlzLl9oYW5kbGVyc1t0XS5kaXNhYmxlKCl9LHdoZW5SZWFkeTpmdW5jdGlvbih0LGkpe3JldHVybiB0aGlzLl9sb2FkZWQ/dC5jYWxsKGl8fHRoaXMse3RhcmdldDp0aGlzfSk6dGhpcy5vbihcImxvYWRcIix0LGkpLHRoaXN9LF9nZXRNYXBQYW5lUG9zOmZ1bmN0aW9uKCl7cmV0dXJuIHlpKHRoaXMuX21hcFBhbmUpfHxuZXcgaygwLDApfSxfbW92ZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9nZXRNYXBQYW5lUG9zKCk7cmV0dXJuIHQmJiF0LmVxdWFscyhbMCwwXSl9LF9nZXRUb3BMZWZ0UG9pbnQ6ZnVuY3Rpb24odCxpKXtyZXR1cm4odCYmdm9pZCAwIT09aT90aGlzLl9nZXROZXdQaXhlbE9yaWdpbih0LGkpOnRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKX0sX2dldE5ld1BpeGVsT3JpZ2luOmZ1bmN0aW9uKHQsaSl7dmFyIGU9dGhpcy5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpO3JldHVybiB0aGlzLnByb2plY3QodCxpKS5fc3VidHJhY3QoZSkuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpLl9yb3VuZCgpfSxfbGF0TG5nVG9OZXdMYXllclBvaW50OmZ1bmN0aW9uKHQsaSxlKXt2YXIgbj10aGlzLl9nZXROZXdQaXhlbE9yaWdpbihlLGkpO3JldHVybiB0aGlzLnByb2plY3QodCxpKS5fc3VidHJhY3Qobil9LF9sYXRMbmdCb3VuZHNUb05ld0xheWVyQm91bmRzOmZ1bmN0aW9uKHQsaSxlKXt2YXIgbj10aGlzLl9nZXROZXdQaXhlbE9yaWdpbihlLGkpO3JldHVybiBPKFt0aGlzLnByb2plY3QodC5nZXRTb3V0aFdlc3QoKSxpKS5fc3VidHJhY3QobiksdGhpcy5wcm9qZWN0KHQuZ2V0Tm9ydGhXZXN0KCksaSkuX3N1YnRyYWN0KG4pLHRoaXMucHJvamVjdCh0LmdldFNvdXRoRWFzdCgpLGkpLl9zdWJ0cmFjdChuKSx0aGlzLnByb2plY3QodC5nZXROb3J0aEVhc3QoKSxpKS5fc3VidHJhY3QobildKX0sX2dldENlbnRlckxheWVyUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpfSxfZ2V0Q2VudGVyT2Zmc2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxhdExuZ1RvTGF5ZXJQb2ludCh0KS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpfSxfbGltaXRDZW50ZXI6ZnVuY3Rpb24odCxpLGUpe2lmKCFlKXJldHVybiB0O3ZhciBuPXRoaXMucHJvamVjdCh0LGkpLG89dGhpcy5nZXRTaXplKCkuZGl2aWRlQnkoMikscz1uZXcgSShuLnN1YnRyYWN0KG8pLG4uYWRkKG8pKSxyPXRoaXMuX2dldEJvdW5kc09mZnNldChzLGUsaSk7cmV0dXJuIHIucm91bmQoKS5lcXVhbHMoWzAsMF0pP3Q6dGhpcy51bnByb2plY3Qobi5hZGQociksaSl9LF9saW1pdE9mZnNldDpmdW5jdGlvbih0LGkpe2lmKCFpKXJldHVybiB0O3ZhciBlPXRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxuPW5ldyBJKGUubWluLmFkZCh0KSxlLm1heC5hZGQodCkpO3JldHVybiB0LmFkZCh0aGlzLl9nZXRCb3VuZHNPZmZzZXQobixpKSl9LF9nZXRCb3VuZHNPZmZzZXQ6ZnVuY3Rpb24odCxpLGUpe3ZhciBuPU8odGhpcy5wcm9qZWN0KGkuZ2V0Tm9ydGhFYXN0KCksZSksdGhpcy5wcm9qZWN0KGkuZ2V0U291dGhXZXN0KCksZSkpLG89bi5taW4uc3VidHJhY3QodC5taW4pLHM9bi5tYXguc3VidHJhY3QodC5tYXgpO3JldHVybiBuZXcgayh0aGlzLl9yZWJvdW5kKG8ueCwtcy54KSx0aGlzLl9yZWJvdW5kKG8ueSwtcy55KSl9LF9yZWJvdW5kOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIDA8dCtpP01hdGgucm91bmQodC1pKS8yOk1hdGgubWF4KDAsTWF0aC5jZWlsKHQpKS1NYXRoLm1heCgwLE1hdGguZmxvb3IoaSkpfSxfbGltaXRab29tOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZ2V0TWluWm9vbSgpLGU9dGhpcy5nZXRNYXhab29tKCksbj12dD90aGlzLm9wdGlvbnMuem9vbVNuYXA6MTtyZXR1cm4gbiYmKHQ9TWF0aC5yb3VuZCh0L24pKm4pLE1hdGgubWF4KGksTWF0aC5taW4oZSx0KSl9LF9vblBhblRyYW5zaXRpb25TdGVwOmZ1bmN0aW9uKCl7dGhpcy5maXJlKFwibW92ZVwiKX0sX29uUGFuVHJhbnNpdGlvbkVuZDpmdW5jdGlvbigpe19pKHRoaXMuX21hcFBhbmUsXCJsZWFmbGV0LXBhbi1hbmltXCIpLHRoaXMuZmlyZShcIm1vdmVlbmRcIil9LF90cnlBbmltYXRlZFBhbjpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuX2dldENlbnRlck9mZnNldCh0KS5fdHJ1bmMoKTtyZXR1cm4hKCEwIT09KGkmJmkuYW5pbWF0ZSkmJiF0aGlzLmdldFNpemUoKS5jb250YWlucyhlKSkmJih0aGlzLnBhbkJ5KGUsaSksITApfSxfY3JlYXRlQW5pbVByb3h5OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcHJveHk9c2koXCJkaXZcIixcImxlYWZsZXQtcHJveHkgbGVhZmxldC16b29tLWFuaW1hdGVkXCIpO3RoaXMuX3BhbmVzLm1hcFBhbmUuYXBwZW5kQ2hpbGQodCksdGhpcy5vbihcInpvb21hbmltXCIsZnVuY3Rpb24odCl7dmFyIGk9dGksZT10aGlzLl9wcm94eS5zdHlsZVtpXTtnaSh0aGlzLl9wcm94eSx0aGlzLnByb2plY3QodC5jZW50ZXIsdC56b29tKSx0aGlzLmdldFpvb21TY2FsZSh0Lnpvb20sMSkpLGU9PT10aGlzLl9wcm94eS5zdHlsZVtpXSYmdGhpcy5fYW5pbWF0aW5nWm9vbSYmdGhpcy5fb25ab29tVHJhbnNpdGlvbkVuZCgpfSx0aGlzKSx0aGlzLm9uKFwibG9hZCBtb3ZlZW5kXCIsdGhpcy5fYW5pbU1vdmVFbmQsdGhpcyksdGhpcy5fb24oXCJ1bmxvYWRcIix0aGlzLl9kZXN0cm95QW5pbVByb3h5LHRoaXMpfSxfZGVzdHJveUFuaW1Qcm94eTpmdW5jdGlvbigpe3JpKHRoaXMuX3Byb3h5KSx0aGlzLm9mZihcImxvYWQgbW92ZWVuZFwiLHRoaXMuX2FuaW1Nb3ZlRW5kLHRoaXMpLGRlbGV0ZSB0aGlzLl9wcm94eX0sX2FuaW1Nb3ZlRW5kOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRDZW50ZXIoKSxpPXRoaXMuZ2V0Wm9vbSgpO2dpKHRoaXMuX3Byb3h5LHRoaXMucHJvamVjdCh0LGkpLHRoaXMuZ2V0Wm9vbVNjYWxlKGksMSkpfSxfY2F0Y2hUcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKHQpe3RoaXMuX2FuaW1hdGluZ1pvb20mJjA8PXQucHJvcGVydHlOYW1lLmluZGV4T2YoXCJ0cmFuc2Zvcm1cIikmJnRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQoKX0sX25vdGhpbmdUb0FuaW1hdGU6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJsZWFmbGV0LXpvb20tYW5pbWF0ZWRcIikubGVuZ3RofSxfdHJ5QW5pbWF0ZWRab29tOmZ1bmN0aW9uKHQsaSxlKXtpZih0aGlzLl9hbmltYXRpbmdab29tKXJldHVybiEwO2lmKGU9ZXx8e30sIXRoaXMuX3pvb21BbmltYXRlZHx8ITE9PT1lLmFuaW1hdGV8fHRoaXMuX25vdGhpbmdUb0FuaW1hdGUoKXx8TWF0aC5hYnMoaS10aGlzLl96b29tKT50aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvblRocmVzaG9sZClyZXR1cm4hMTt2YXIgbj10aGlzLmdldFpvb21TY2FsZShpKSxvPXRoaXMuX2dldENlbnRlck9mZnNldCh0KS5fZGl2aWRlQnkoMS0xL24pO3JldHVybiEoITAhPT1lLmFuaW1hdGUmJiF0aGlzLmdldFNpemUoKS5jb250YWlucyhvKSkmJihNKGZ1bmN0aW9uKCl7dGhpcy5fbW92ZVN0YXJ0KCEwLCExKS5fYW5pbWF0ZVpvb20odCxpLCEwKX0sdGhpcyksITApfSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24odCxpLGUsbil7dGhpcy5fbWFwUGFuZSYmKGUmJih0aGlzLl9hbmltYXRpbmdab29tPSEwLHRoaXMuX2FuaW1hdGVUb0NlbnRlcj10LHRoaXMuX2FuaW1hdGVUb1pvb209aSxjaSh0aGlzLl9tYXBQYW5lLFwibGVhZmxldC16b29tLWFuaW1cIikpLHRoaXMuZmlyZShcInpvb21hbmltXCIse2NlbnRlcjp0LHpvb206aSxub1VwZGF0ZTpufSksc2V0VGltZW91dChwKHRoaXMuX29uWm9vbVRyYW5zaXRpb25FbmQsdGhpcyksMjUwKSl9LF9vblpvb21UcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKCl7dGhpcy5fYW5pbWF0aW5nWm9vbSYmKHRoaXMuX21hcFBhbmUmJl9pKHRoaXMuX21hcFBhbmUsXCJsZWFmbGV0LXpvb20tYW5pbVwiKSx0aGlzLl9hbmltYXRpbmdab29tPSExLHRoaXMuX21vdmUodGhpcy5fYW5pbWF0ZVRvQ2VudGVyLHRoaXMuX2FuaW1hdGVUb1pvb20pLE0oZnVuY3Rpb24oKXt0aGlzLl9tb3ZlRW5kKCEwKX0sdGhpcykpfX0pO2Z1bmN0aW9uIFlpKHQpe3JldHVybiBuZXcgWGkodCl9dmFyIFhpPVMuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcInRvcHJpZ2h0XCJ9LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7Yyh0aGlzLHQpfSxnZXRQb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb259LHNldFBvc2l0aW9uOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcDtyZXR1cm4gaSYmaS5yZW1vdmVDb250cm9sKHRoaXMpLHRoaXMub3B0aW9ucy5wb3NpdGlvbj10LGkmJmkuYWRkQ29udHJvbCh0aGlzKSx0aGlzfSxnZXRDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbmVyfSxhZGRUbzpmdW5jdGlvbih0KXt0aGlzLnJlbW92ZSgpLHRoaXMuX21hcD10O3ZhciBpPXRoaXMuX2NvbnRhaW5lcj10aGlzLm9uQWRkKHQpLGU9dGhpcy5nZXRQb3NpdGlvbigpLG49dC5fY29udHJvbENvcm5lcnNbZV07cmV0dXJuIGNpKGksXCJsZWFmbGV0LWNvbnRyb2xcIiksLTEhPT1lLmluZGV4T2YoXCJib3R0b21cIik/bi5pbnNlcnRCZWZvcmUoaSxuLmZpcnN0Q2hpbGQpOm4uYXBwZW5kQ2hpbGQoaSksdGhpcy5fbWFwLm9uKFwidW5sb2FkXCIsdGhpcy5yZW1vdmUsdGhpcyksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmKHJpKHRoaXMuX2NvbnRhaW5lciksdGhpcy5vblJlbW92ZSYmdGhpcy5vblJlbW92ZSh0aGlzLl9tYXApLHRoaXMuX21hcC5vZmYoXCJ1bmxvYWRcIix0aGlzLnJlbW92ZSx0aGlzKSx0aGlzLl9tYXA9bnVsbCksdGhpc30sX3JlZm9jdXNPbk1hcDpmdW5jdGlvbih0KXt0aGlzLl9tYXAmJnQmJjA8dC5zY3JlZW5YJiYwPHQuc2NyZWVuWSYmdGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCl9fSk7S2kuaW5jbHVkZSh7YWRkQ29udHJvbDpmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGRUbyh0aGlzKSx0aGlzfSxyZW1vdmVDb250cm9sOmZ1bmN0aW9uKHQpe3JldHVybiB0LnJlbW92ZSgpLHRoaXN9LF9pbml0Q29udHJvbFBvczpmdW5jdGlvbigpe3ZhciBuPXRoaXMuX2NvbnRyb2xDb3JuZXJzPXt9LG89XCJsZWFmbGV0LVwiLHM9dGhpcy5fY29udHJvbENvbnRhaW5lcj1zaShcImRpdlwiLG8rXCJjb250cm9sLWNvbnRhaW5lclwiLHRoaXMuX2NvbnRhaW5lcik7ZnVuY3Rpb24gdCh0LGkpe3ZhciBlPW8rdCtcIiBcIitvK2k7blt0K2ldPXNpKFwiZGl2XCIsZSxzKX10KFwidG9wXCIsXCJsZWZ0XCIpLHQoXCJ0b3BcIixcInJpZ2h0XCIpLHQoXCJib3R0b21cIixcImxlZnRcIiksdChcImJvdHRvbVwiLFwicmlnaHRcIil9LF9jbGVhckNvbnRyb2xQb3M6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fY29udHJvbENvcm5lcnMpcmkodGhpcy5fY29udHJvbENvcm5lcnNbdF0pO3JpKHRoaXMuX2NvbnRyb2xDb250YWluZXIpLGRlbGV0ZSB0aGlzLl9jb250cm9sQ29ybmVycyxkZWxldGUgdGhpcy5fY29udHJvbENvbnRhaW5lcn19KTt2YXIgSmk9WGkuZXh0ZW5kKHtvcHRpb25zOntjb2xsYXBzZWQ6ITAscG9zaXRpb246XCJ0b3ByaWdodFwiLGF1dG9aSW5kZXg6ITAsaGlkZVNpbmdsZUJhc2U6ITEsc29ydExheWVyczohMSxzb3J0RnVuY3Rpb246ZnVuY3Rpb24odCxpLGUsbil7cmV0dXJuIGU8bj8tMTpuPGU/MTowfX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGksZSl7Zm9yKHZhciBuIGluIGModGhpcyxlKSx0aGlzLl9sYXllckNvbnRyb2xJbnB1dHM9W10sdGhpcy5fbGF5ZXJzPVtdLHRoaXMuX2xhc3RaSW5kZXg9MCx0aGlzLl9oYW5kbGluZ0NsaWNrPSExLHQpdGhpcy5fYWRkTGF5ZXIodFtuXSxuKTtmb3IobiBpbiBpKXRoaXMuX2FkZExheWVyKGlbbl0sbiwhMCl9LG9uQWRkOmZ1bmN0aW9uKHQpe3RoaXMuX2luaXRMYXlvdXQoKSx0aGlzLl91cGRhdGUoKSwodGhpcy5fbWFwPXQpLm9uKFwiem9vbWVuZFwiLHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMsdGhpcyk7Zm9yKHZhciBpPTA7aTx0aGlzLl9sYXllcnMubGVuZ3RoO2krKyl0aGlzLl9sYXllcnNbaV0ubGF5ZXIub24oXCJhZGQgcmVtb3ZlXCIsdGhpcy5fb25MYXllckNoYW5nZSx0aGlzKTtyZXR1cm4gdGhpcy5fY29udGFpbmVyfSxhZGRUbzpmdW5jdGlvbih0KXtyZXR1cm4gWGkucHJvdG90eXBlLmFkZFRvLmNhbGwodGhpcyx0KSx0aGlzLl9leHBhbmRJZk5vdENvbGxhcHNlZCgpfSxvblJlbW92ZTpmdW5jdGlvbigpe3RoaXMuX21hcC5vZmYoXCJ6b29tZW5kXCIsdGhpcy5fY2hlY2tEaXNhYmxlZExheWVycyx0aGlzKTtmb3IodmFyIHQ9MDt0PHRoaXMuX2xheWVycy5sZW5ndGg7dCsrKXRoaXMuX2xheWVyc1t0XS5sYXllci5vZmYoXCJhZGQgcmVtb3ZlXCIsdGhpcy5fb25MYXllckNoYW5nZSx0aGlzKX0sYWRkQmFzZUxheWVyOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMuX2FkZExheWVyKHQsaSksdGhpcy5fbWFwP3RoaXMuX3VwZGF0ZSgpOnRoaXN9LGFkZE92ZXJsYXk6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5fYWRkTGF5ZXIodCxpLCEwKSx0aGlzLl9tYXA/dGhpcy5fdXBkYXRlKCk6dGhpc30scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dC5vZmYoXCJhZGQgcmVtb3ZlXCIsdGhpcy5fb25MYXllckNoYW5nZSx0aGlzKTt2YXIgaT10aGlzLl9nZXRMYXllcihtKHQpKTtyZXR1cm4gaSYmdGhpcy5fbGF5ZXJzLnNwbGljZSh0aGlzLl9sYXllcnMuaW5kZXhPZihpKSwxKSx0aGlzLl9tYXA/dGhpcy5fdXBkYXRlKCk6dGhpc30sZXhwYW5kOmZ1bmN0aW9uKCl7Y2kodGhpcy5fY29udGFpbmVyLFwibGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZFwiKSx0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodD1udWxsO3ZhciB0PXRoaXMuX21hcC5nZXRTaXplKCkueS0odGhpcy5fY29udGFpbmVyLm9mZnNldFRvcCs1MCk7cmV0dXJuIHQ8dGhpcy5fc2VjdGlvbi5jbGllbnRIZWlnaHQ/KGNpKHRoaXMuX3NlY3Rpb24sXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNjcm9sbGJhclwiKSx0aGlzLl9zZWN0aW9uLnN0eWxlLmhlaWdodD10K1wicHhcIik6X2kodGhpcy5fc2VjdGlvbixcImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2Nyb2xsYmFyXCIpLHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKSx0aGlzfSxjb2xsYXBzZTpmdW5jdGlvbigpe3JldHVybiBfaSh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkXCIpLHRoaXN9LF9pbml0TGF5b3V0OmZ1bmN0aW9uKCl7dmFyIHQ9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzXCIsaT10aGlzLl9jb250YWluZXI9c2koXCJkaXZcIix0KSxlPXRoaXMub3B0aW9ucy5jb2xsYXBzZWQ7aS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsITApLE9pKGkpLElpKGkpO3ZhciBuPXRoaXMuX3NlY3Rpb249c2koXCJzZWN0aW9uXCIsdCtcIi1saXN0XCIpO2UmJih0aGlzLl9tYXAub24oXCJjbGlja1wiLHRoaXMuY29sbGFwc2UsdGhpcyksb3R8fHppKGkse21vdXNlZW50ZXI6dGhpcy5leHBhbmQsbW91c2VsZWF2ZTp0aGlzLmNvbGxhcHNlfSx0aGlzKSk7dmFyIG89dGhpcy5fbGF5ZXJzTGluaz1zaShcImFcIix0K1wiLXRvZ2dsZVwiLGkpO28uaHJlZj1cIiNcIixvLnRpdGxlPVwiTGF5ZXJzXCIsYnQ/KHppKG8sXCJjbGlja1wiLE5pKSx6aShvLFwiY2xpY2tcIix0aGlzLmV4cGFuZCx0aGlzKSk6emkobyxcImZvY3VzXCIsdGhpcy5leHBhbmQsdGhpcyksZXx8dGhpcy5leHBhbmQoKSx0aGlzLl9iYXNlTGF5ZXJzTGlzdD1zaShcImRpdlwiLHQrXCItYmFzZVwiLG4pLHRoaXMuX3NlcGFyYXRvcj1zaShcImRpdlwiLHQrXCItc2VwYXJhdG9yXCIsbiksdGhpcy5fb3ZlcmxheXNMaXN0PXNpKFwiZGl2XCIsdCtcIi1vdmVybGF5c1wiLG4pLGkuYXBwZW5kQ2hpbGQobil9LF9nZXRMYXllcjpmdW5jdGlvbih0KXtmb3IodmFyIGk9MDtpPHRoaXMuX2xheWVycy5sZW5ndGg7aSsrKWlmKHRoaXMuX2xheWVyc1tpXSYmbSh0aGlzLl9sYXllcnNbaV0ubGF5ZXIpPT09dClyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldfSxfYWRkTGF5ZXI6ZnVuY3Rpb24odCxpLGUpe3RoaXMuX21hcCYmdC5vbihcImFkZCByZW1vdmVcIix0aGlzLl9vbkxheWVyQ2hhbmdlLHRoaXMpLHRoaXMuX2xheWVycy5wdXNoKHtsYXllcjp0LG5hbWU6aSxvdmVybGF5OmV9KSx0aGlzLm9wdGlvbnMuc29ydExheWVycyYmdGhpcy5fbGF5ZXJzLnNvcnQocChmdW5jdGlvbih0LGkpe3JldHVybiB0aGlzLm9wdGlvbnMuc29ydEZ1bmN0aW9uKHQubGF5ZXIsaS5sYXllcix0Lm5hbWUsaS5uYW1lKX0sdGhpcykpLHRoaXMub3B0aW9ucy5hdXRvWkluZGV4JiZ0LnNldFpJbmRleCYmKHRoaXMuX2xhc3RaSW5kZXgrKyx0LnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KSksdGhpcy5fZXhwYW5kSWZOb3RDb2xsYXBzZWQoKX0sX3VwZGF0ZTpmdW5jdGlvbigpe2lmKCF0aGlzLl9jb250YWluZXIpcmV0dXJuIHRoaXM7YWkodGhpcy5fYmFzZUxheWVyc0xpc3QpLGFpKHRoaXMuX292ZXJsYXlzTGlzdCksdGhpcy5fbGF5ZXJDb250cm9sSW5wdXRzPVtdO2Zvcih2YXIgdCxpLGUsbj0wLG89MDtvPHRoaXMuX2xheWVycy5sZW5ndGg7bysrKWU9dGhpcy5fbGF5ZXJzW29dLHRoaXMuX2FkZEl0ZW0oZSksaT1pfHxlLm92ZXJsYXksdD10fHwhZS5vdmVybGF5LG4rPWUub3ZlcmxheT8wOjE7cmV0dXJuIHRoaXMub3B0aW9ucy5oaWRlU2luZ2xlQmFzZSYmKHQ9dCYmMTxuLHRoaXMuX2Jhc2VMYXllcnNMaXN0LnN0eWxlLmRpc3BsYXk9dD9cIlwiOlwibm9uZVwiKSx0aGlzLl9zZXBhcmF0b3Iuc3R5bGUuZGlzcGxheT1pJiZ0P1wiXCI6XCJub25lXCIsdGhpc30sX29uTGF5ZXJDaGFuZ2U6ZnVuY3Rpb24odCl7dGhpcy5faGFuZGxpbmdDbGlja3x8dGhpcy5fdXBkYXRlKCk7dmFyIGk9dGhpcy5fZ2V0TGF5ZXIobSh0LnRhcmdldCkpLGU9aS5vdmVybGF5P1wiYWRkXCI9PT10LnR5cGU/XCJvdmVybGF5YWRkXCI6XCJvdmVybGF5cmVtb3ZlXCI6XCJhZGRcIj09PXQudHlwZT9cImJhc2VsYXllcmNoYW5nZVwiOm51bGw7ZSYmdGhpcy5fbWFwLmZpcmUoZSxpKX0sX2NyZWF0ZVJhZGlvRWxlbWVudDpmdW5jdGlvbih0LGkpe3ZhciBlPSc8aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXNlbGVjdG9yXCIgbmFtZT1cIicrdCsnXCInKyhpPycgY2hlY2tlZD1cImNoZWNrZWRcIic6XCJcIikrXCIvPlwiLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gbi5pbm5lckhUTUw9ZSxuLmZpcnN0Q2hpbGR9LF9hZGRJdGVtOmZ1bmN0aW9uKHQpe3ZhciBpLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpLG49dGhpcy5fbWFwLmhhc0xheWVyKHQubGF5ZXIpO3Qub3ZlcmxheT8oKGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS50eXBlPVwiY2hlY2tib3hcIixpLmNsYXNzTmFtZT1cImxlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3JcIixpLmRlZmF1bHRDaGVja2VkPW4pOmk9dGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KFwibGVhZmxldC1iYXNlLWxheWVyc19cIittKHRoaXMpLG4pLHRoaXMuX2xheWVyQ29udHJvbElucHV0cy5wdXNoKGkpLGkubGF5ZXJJZD1tKHQubGF5ZXIpLHppKGksXCJjbGlja1wiLHRoaXMuX29uSW5wdXRDbGljayx0aGlzKTt2YXIgbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtvLmlubmVySFRNTD1cIiBcIit0Lm5hbWU7dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZS5hcHBlbmRDaGlsZChzKSxzLmFwcGVuZENoaWxkKGkpLHMuYXBwZW5kQ2hpbGQobyksKHQub3ZlcmxheT90aGlzLl9vdmVybGF5c0xpc3Q6dGhpcy5fYmFzZUxheWVyc0xpc3QpLmFwcGVuZENoaWxkKGUpLHRoaXMuX2NoZWNrRGlzYWJsZWRMYXllcnMoKSxlfSxfb25JbnB1dENsaWNrOmZ1bmN0aW9uKCl7dmFyIHQsaSxlPXRoaXMuX2xheWVyQ29udHJvbElucHV0cyxuPVtdLG89W107dGhpcy5faGFuZGxpbmdDbGljaz0hMDtmb3IodmFyIHM9ZS5sZW5ndGgtMTswPD1zO3MtLSl0PWVbc10saT10aGlzLl9nZXRMYXllcih0LmxheWVySWQpLmxheWVyLHQuY2hlY2tlZD9uLnB1c2goaSk6dC5jaGVja2VkfHxvLnB1c2goaSk7Zm9yKHM9MDtzPG8ubGVuZ3RoO3MrKyl0aGlzLl9tYXAuaGFzTGF5ZXIob1tzXSkmJnRoaXMuX21hcC5yZW1vdmVMYXllcihvW3NdKTtmb3Iocz0wO3M8bi5sZW5ndGg7cysrKXRoaXMuX21hcC5oYXNMYXllcihuW3NdKXx8dGhpcy5fbWFwLmFkZExheWVyKG5bc10pO3RoaXMuX2hhbmRsaW5nQ2xpY2s9ITEsdGhpcy5fcmVmb2N1c09uTWFwKCl9LF9jaGVja0Rpc2FibGVkTGF5ZXJzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LGksZT10aGlzLl9sYXllckNvbnRyb2xJbnB1dHMsbj10aGlzLl9tYXAuZ2V0Wm9vbSgpLG89ZS5sZW5ndGgtMTswPD1vO28tLSl0PWVbb10saT10aGlzLl9nZXRMYXllcih0LmxheWVySWQpLmxheWVyLHQuZGlzYWJsZWQ9dm9pZCAwIT09aS5vcHRpb25zLm1pblpvb20mJm48aS5vcHRpb25zLm1pblpvb218fHZvaWQgMCE9PWkub3B0aW9ucy5tYXhab29tJiZuPmkub3B0aW9ucy5tYXhab29tfSxfZXhwYW5kSWZOb3RDb2xsYXBzZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiYhdGhpcy5vcHRpb25zLmNvbGxhcHNlZCYmdGhpcy5leHBhbmQoKSx0aGlzfSxfZXhwYW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhwYW5kKCl9LF9jb2xsYXBzZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbGxhcHNlKCl9fSksJGk9WGkuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcInRvcGxlZnRcIix6b29tSW5UZXh0OlwiK1wiLHpvb21JblRpdGxlOlwiWm9vbSBpblwiLHpvb21PdXRUZXh0OlwiJiN4MjIxMjtcIix6b29tT3V0VGl0bGU6XCJab29tIG91dFwifSxvbkFkZDpmdW5jdGlvbih0KXt2YXIgaT1cImxlYWZsZXQtY29udHJvbC16b29tXCIsZT1zaShcImRpdlwiLGkrXCIgbGVhZmxldC1iYXJcIiksbj10aGlzLm9wdGlvbnM7cmV0dXJuIHRoaXMuX3pvb21JbkJ1dHRvbj10aGlzLl9jcmVhdGVCdXR0b24obi56b29tSW5UZXh0LG4uem9vbUluVGl0bGUsaStcIi1pblwiLGUsdGhpcy5fem9vbUluKSx0aGlzLl96b29tT3V0QnV0dG9uPXRoaXMuX2NyZWF0ZUJ1dHRvbihuLnpvb21PdXRUZXh0LG4uem9vbU91dFRpdGxlLGkrXCItb3V0XCIsZSx0aGlzLl96b29tT3V0KSx0aGlzLl91cGRhdGVEaXNhYmxlZCgpLHQub24oXCJ6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2VcIix0aGlzLl91cGRhdGVEaXNhYmxlZCx0aGlzKSxlfSxvblJlbW92ZTpmdW5jdGlvbih0KXt0Lm9mZihcInpvb21lbmQgem9vbWxldmVsc2NoYW5nZVwiLHRoaXMuX3VwZGF0ZURpc2FibGVkLHRoaXMpfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc2FibGVkPSEwLHRoaXMuX3VwZGF0ZURpc2FibGVkKCksdGhpc30sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rpc2FibGVkPSExLHRoaXMuX3VwZGF0ZURpc2FibGVkKCksdGhpc30sX3pvb21JbjpmdW5jdGlvbih0KXshdGhpcy5fZGlzYWJsZWQmJnRoaXMuX21hcC5fem9vbTx0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpJiZ0aGlzLl9tYXAuem9vbUluKHRoaXMuX21hcC5vcHRpb25zLnpvb21EZWx0YSoodC5zaGlmdEtleT8zOjEpKX0sX3pvb21PdXQ6ZnVuY3Rpb24odCl7IXRoaXMuX2Rpc2FibGVkJiZ0aGlzLl9tYXAuX3pvb20+dGhpcy5fbWFwLmdldE1pblpvb20oKSYmdGhpcy5fbWFwLnpvb21PdXQodGhpcy5fbWFwLm9wdGlvbnMuem9vbURlbHRhKih0LnNoaWZ0S2V5PzM6MSkpfSxfY3JlYXRlQnV0dG9uOmZ1bmN0aW9uKHQsaSxlLG4sbyl7dmFyIHM9c2koXCJhXCIsZSxuKTtyZXR1cm4gcy5pbm5lckhUTUw9dCxzLmhyZWY9XCIjXCIscy50aXRsZT1pLHMuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwiYnV0dG9uXCIpLHMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLGkpLE9pKHMpLHppKHMsXCJjbGlja1wiLE5pKSx6aShzLFwiY2xpY2tcIixvLHRoaXMpLHppKHMsXCJjbGlja1wiLHRoaXMuX3JlZm9jdXNPbk1hcCx0aGlzKSxzfSxfdXBkYXRlRGlzYWJsZWQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAsaT1cImxlYWZsZXQtZGlzYWJsZWRcIjtfaSh0aGlzLl96b29tSW5CdXR0b24saSksX2kodGhpcy5fem9vbU91dEJ1dHRvbixpKSwhdGhpcy5fZGlzYWJsZWQmJnQuX3pvb20hPT10LmdldE1pblpvb20oKXx8Y2kodGhpcy5fem9vbU91dEJ1dHRvbixpKSwhdGhpcy5fZGlzYWJsZWQmJnQuX3pvb20hPT10LmdldE1heFpvb20oKXx8Y2kodGhpcy5fem9vbUluQnV0dG9uLGkpfX0pO0tpLm1lcmdlT3B0aW9ucyh7em9vbUNvbnRyb2w6ITB9KSxLaS5hZGRJbml0SG9vayhmdW5jdGlvbigpe3RoaXMub3B0aW9ucy56b29tQ29udHJvbCYmKHRoaXMuem9vbUNvbnRyb2w9bmV3ICRpLHRoaXMuYWRkQ29udHJvbCh0aGlzLnpvb21Db250cm9sKSl9KTt2YXIgUWk9WGkuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcImJvdHRvbWxlZnRcIixtYXhXaWR0aDoxMDAsbWV0cmljOiEwLGltcGVyaWFsOiEwfSxvbkFkZDpmdW5jdGlvbih0KXt2YXIgaT1cImxlYWZsZXQtY29udHJvbC1zY2FsZVwiLGU9c2koXCJkaXZcIixpKSxuPXRoaXMub3B0aW9ucztyZXR1cm4gdGhpcy5fYWRkU2NhbGVzKG4saStcIi1saW5lXCIsZSksdC5vbihuLnVwZGF0ZVdoZW5JZGxlP1wibW92ZWVuZFwiOlwibW92ZVwiLHRoaXMuX3VwZGF0ZSx0aGlzKSx0LndoZW5SZWFkeSh0aGlzLl91cGRhdGUsdGhpcyksZX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7dC5vZmYodGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5JZGxlP1wibW92ZWVuZFwiOlwibW92ZVwiLHRoaXMuX3VwZGF0ZSx0aGlzKX0sX2FkZFNjYWxlczpmdW5jdGlvbih0LGksZSl7dC5tZXRyaWMmJih0aGlzLl9tU2NhbGU9c2koXCJkaXZcIixpLGUpKSx0LmltcGVyaWFsJiYodGhpcy5faVNjYWxlPXNpKFwiZGl2XCIsaSxlKSl9LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAsaT10LmdldFNpemUoKS55LzIsZT10LmRpc3RhbmNlKHQuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbMCxpXSksdC5jb250YWluZXJQb2ludFRvTGF0TG5nKFt0aGlzLm9wdGlvbnMubWF4V2lkdGgsaV0pKTt0aGlzLl91cGRhdGVTY2FsZXMoZSl9LF91cGRhdGVTY2FsZXM6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zLm1ldHJpYyYmdCYmdGhpcy5fdXBkYXRlTWV0cmljKHQpLHRoaXMub3B0aW9ucy5pbXBlcmlhbCYmdCYmdGhpcy5fdXBkYXRlSW1wZXJpYWwodCl9LF91cGRhdGVNZXRyaWM6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fZ2V0Um91bmROdW0odCksZT1pPDFlMz9pK1wiIG1cIjppLzFlMytcIiBrbVwiO3RoaXMuX3VwZGF0ZVNjYWxlKHRoaXMuX21TY2FsZSxlLGkvdCl9LF91cGRhdGVJbXBlcmlhbDpmdW5jdGlvbih0KXt2YXIgaSxlLG4sbz0zLjI4MDgzOTkqdDs1MjgwPG8/KGk9by81MjgwLGU9dGhpcy5fZ2V0Um91bmROdW0oaSksdGhpcy5fdXBkYXRlU2NhbGUodGhpcy5faVNjYWxlLGUrXCIgbWlcIixlL2kpKToobj10aGlzLl9nZXRSb3VuZE51bShvKSx0aGlzLl91cGRhdGVTY2FsZSh0aGlzLl9pU2NhbGUsbitcIiBmdFwiLG4vbykpfSxfdXBkYXRlU2NhbGU6ZnVuY3Rpb24odCxpLGUpe3Quc3R5bGUud2lkdGg9TWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGgqZSkrXCJweFwiLHQuaW5uZXJIVE1MPWl9LF9nZXRSb3VuZE51bTpmdW5jdGlvbih0KXt2YXIgaT1NYXRoLnBvdygxMCwoTWF0aC5mbG9vcih0KStcIlwiKS5sZW5ndGgtMSksZT10L2k7cmV0dXJuIGkqKGU9MTA8PWU/MTA6NTw9ZT81OjM8PWU/MzoyPD1lPzI6MSl9fSksdGU9WGkuZXh0ZW5kKHtvcHRpb25zOntwb3NpdGlvbjpcImJvdHRvbXJpZ2h0XCIscHJlZml4Oic8YSBocmVmPVwiaHR0cHM6Ly9sZWFmbGV0anMuY29tXCIgdGl0bGU9XCJBIEpTIGxpYnJhcnkgZm9yIGludGVyYWN0aXZlIG1hcHNcIj5MZWFmbGV0PC9hPid9LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7Yyh0aGlzLHQpLHRoaXMuX2F0dHJpYnV0aW9ucz17fX0sb25BZGQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBpIGluKHQuYXR0cmlidXRpb25Db250cm9sPXRoaXMpLl9jb250YWluZXI9c2koXCJkaXZcIixcImxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvblwiKSxPaSh0aGlzLl9jb250YWluZXIpLHQuX2xheWVycyl0Ll9sYXllcnNbaV0uZ2V0QXR0cmlidXRpb24mJnRoaXMuYWRkQXR0cmlidXRpb24odC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKCkpO3JldHVybiB0aGlzLl91cGRhdGUoKSx0aGlzLl9jb250YWluZXJ9LHNldFByZWZpeDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLnByZWZpeD10LHRoaXMuX3VwZGF0ZSgpLHRoaXN9LGFkZEF0dHJpYnV0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0JiYodGhpcy5fYXR0cmlidXRpb25zW3RdfHwodGhpcy5fYXR0cmlidXRpb25zW3RdPTApLHRoaXMuX2F0dHJpYnV0aW9uc1t0XSsrLHRoaXMuX3VwZGF0ZSgpKSx0aGlzfSxyZW1vdmVBdHRyaWJ1dGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdGhpcy5fYXR0cmlidXRpb25zW3RdJiYodGhpcy5fYXR0cmlidXRpb25zW3RdLS0sdGhpcy5fdXBkYXRlKCkpLHRoaXN9LF91cGRhdGU6ZnVuY3Rpb24oKXtpZih0aGlzLl9tYXApe3ZhciB0PVtdO2Zvcih2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpdGhpcy5fYXR0cmlidXRpb25zW2ldJiZ0LnB1c2goaSk7dmFyIGU9W107dGhpcy5vcHRpb25zLnByZWZpeCYmZS5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpLHQubGVuZ3RoJiZlLnB1c2godC5qb2luKFwiLCBcIikpLHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUw9ZS5qb2luKFwiIHwgXCIpfX19KTtLaS5tZXJnZU9wdGlvbnMoe2F0dHJpYnV0aW9uQ29udHJvbDohMH0pLEtpLmFkZEluaXRIb29rKGZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCYmKG5ldyB0ZSkuYWRkVG8odGhpcyl9KTtYaS5MYXllcnM9SmksWGkuWm9vbT0kaSxYaS5TY2FsZT1RaSxYaS5BdHRyaWJ1dGlvbj10ZSxZaS5sYXllcnM9ZnVuY3Rpb24odCxpLGUpe3JldHVybiBuZXcgSmkodCxpLGUpfSxZaS56b29tPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgJGkodCl9LFlpLnNjYWxlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUWkodCl9LFlpLmF0dHJpYnV0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdGUodCl9O3ZhciBpZT1TLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dH0sZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VuYWJsZWR8fCh0aGlzLl9lbmFibGVkPSEwLHRoaXMuYWRkSG9va3MoKSksdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9lbmFibGVkJiYodGhpcy5fZW5hYmxlZD0hMSx0aGlzLnJlbW92ZUhvb2tzKCkpLHRoaXN9LGVuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX2VuYWJsZWR9fSk7aWUuYWRkVG89ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC5hZGRIYW5kbGVyKGksdGhpcyksdGhpc307dmFyIGVlLG5lPXtFdmVudHM6Wn0sb2U9YnQ/XCJ0b3VjaHN0YXJ0IG1vdXNlZG93blwiOlwibW91c2Vkb3duXCIsc2U9e21vdXNlZG93bjpcIm1vdXNldXBcIix0b3VjaHN0YXJ0OlwidG91Y2hlbmRcIixwb2ludGVyZG93bjpcInRvdWNoZW5kXCIsTVNQb2ludGVyRG93bjpcInRvdWNoZW5kXCJ9LHJlPXttb3VzZWRvd246XCJtb3VzZW1vdmVcIix0b3VjaHN0YXJ0OlwidG91Y2htb3ZlXCIscG9pbnRlcmRvd246XCJ0b3VjaG1vdmVcIixNU1BvaW50ZXJEb3duOlwidG91Y2htb3ZlXCJ9LGFlPUUuZXh0ZW5kKHtvcHRpb25zOntjbGlja1RvbGVyYW5jZTozfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSxlLG4pe2ModGhpcyxuKSx0aGlzLl9lbGVtZW50PXQsdGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0PWl8fHQsdGhpcy5fcHJldmVudE91dGxpbmU9ZX0sZW5hYmxlOmZ1bmN0aW9uKCl7dGhpcy5fZW5hYmxlZHx8KHppKHRoaXMuX2RyYWdTdGFydFRhcmdldCxvZSx0aGlzLl9vbkRvd24sdGhpcyksdGhpcy5fZW5hYmxlZD0hMCl9LGRpc2FibGU6ZnVuY3Rpb24oKXt0aGlzLl9lbmFibGVkJiYoYWUuX2RyYWdnaW5nPT09dGhpcyYmdGhpcy5maW5pc2hEcmFnKCksU2kodGhpcy5fZHJhZ1N0YXJ0VGFyZ2V0LG9lLHRoaXMuX29uRG93bix0aGlzKSx0aGlzLl9lbmFibGVkPSExLHRoaXMuX21vdmVkPSExKX0sX29uRG93bjpmdW5jdGlvbih0KXt2YXIgaSxlOyF0Ll9zaW11bGF0ZWQmJnRoaXMuX2VuYWJsZWQmJih0aGlzLl9tb3ZlZD0hMSxsaSh0aGlzLl9lbGVtZW50LFwibGVhZmxldC16b29tLWFuaW1cIil8fGFlLl9kcmFnZ2luZ3x8dC5zaGlmdEtleXx8MSE9PXQud2hpY2gmJjEhPT10LmJ1dHRvbiYmIXQudG91Y2hlc3x8KChhZS5fZHJhZ2dpbmc9dGhpcykuX3ByZXZlbnRPdXRsaW5lJiZQaSh0aGlzLl9lbGVtZW50KSx4aSgpLFh0KCksdGhpcy5fbW92aW5nfHwodGhpcy5maXJlKFwiZG93blwiKSxpPXQudG91Y2hlcz90LnRvdWNoZXNbMF06dCxlPWJpKHRoaXMuX2VsZW1lbnQpLHRoaXMuX3N0YXJ0UG9pbnQ9bmV3IGsoaS5jbGllbnRYLGkuY2xpZW50WSksdGhpcy5fcGFyZW50U2NhbGU9VGkoZSksemkoZG9jdW1lbnQscmVbdC50eXBlXSx0aGlzLl9vbk1vdmUsdGhpcyksemkoZG9jdW1lbnQsc2VbdC50eXBlXSx0aGlzLl9vblVwLHRoaXMpKSkpfSxfb25Nb3ZlOmZ1bmN0aW9uKHQpe3ZhciBpLGU7IXQuX3NpbXVsYXRlZCYmdGhpcy5fZW5hYmxlZCYmKHQudG91Y2hlcyYmMTx0LnRvdWNoZXMubGVuZ3RoP3RoaXMuX21vdmVkPSEwOigoZT1uZXcgaygoaT10LnRvdWNoZXMmJjE9PT10LnRvdWNoZXMubGVuZ3RoP3QudG91Y2hlc1swXTp0KS5jbGllbnRYLGkuY2xpZW50WSkuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpKS54fHxlLnkpJiYoTWF0aC5hYnMoZS54KStNYXRoLmFicyhlLnkpPHRoaXMub3B0aW9ucy5jbGlja1RvbGVyYW5jZXx8KGUueC89dGhpcy5fcGFyZW50U2NhbGUueCxlLnkvPXRoaXMuX3BhcmVudFNjYWxlLnksUmkodCksdGhpcy5fbW92ZWR8fCh0aGlzLmZpcmUoXCJkcmFnc3RhcnRcIiksdGhpcy5fbW92ZWQ9ITAsdGhpcy5fc3RhcnRQb3M9eWkodGhpcy5fZWxlbWVudCkuc3VidHJhY3QoZSksY2koZG9jdW1lbnQuYm9keSxcImxlYWZsZXQtZHJhZ2dpbmdcIiksdGhpcy5fbGFzdFRhcmdldD10LnRhcmdldHx8dC5zcmNFbGVtZW50LHdpbmRvdy5TVkdFbGVtZW50SW5zdGFuY2UmJnRoaXMuX2xhc3RUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudEluc3RhbmNlJiYodGhpcy5fbGFzdFRhcmdldD10aGlzLl9sYXN0VGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSxjaSh0aGlzLl9sYXN0VGFyZ2V0LFwibGVhZmxldC1kcmFnLXRhcmdldFwiKSksdGhpcy5fbmV3UG9zPXRoaXMuX3N0YXJ0UG9zLmFkZChlKSx0aGlzLl9tb3Zpbmc9ITAseih0aGlzLl9hbmltUmVxdWVzdCksdGhpcy5fbGFzdEV2ZW50PXQsdGhpcy5fYW5pbVJlcXVlc3Q9TSh0aGlzLl91cGRhdGVQb3NpdGlvbix0aGlzLCEwKSkpKX0sX3VwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ9e29yaWdpbmFsRXZlbnQ6dGhpcy5fbGFzdEV2ZW50fTt0aGlzLmZpcmUoXCJwcmVkcmFnXCIsdCksdmkodGhpcy5fZWxlbWVudCx0aGlzLl9uZXdQb3MpLHRoaXMuZmlyZShcImRyYWdcIix0KX0sX29uVXA6ZnVuY3Rpb24odCl7IXQuX3NpbXVsYXRlZCYmdGhpcy5fZW5hYmxlZCYmdGhpcy5maW5pc2hEcmFnKCl9LGZpbmlzaERyYWc6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gX2koZG9jdW1lbnQuYm9keSxcImxlYWZsZXQtZHJhZ2dpbmdcIiksdGhpcy5fbGFzdFRhcmdldCYmKF9pKHRoaXMuX2xhc3RUYXJnZXQsXCJsZWFmbGV0LWRyYWctdGFyZ2V0XCIpLHRoaXMuX2xhc3RUYXJnZXQ9bnVsbCkscmUpU2koZG9jdW1lbnQscmVbdF0sdGhpcy5fb25Nb3ZlLHRoaXMpLFNpKGRvY3VtZW50LHNlW3RdLHRoaXMuX29uVXAsdGhpcyk7d2koKSxKdCgpLHRoaXMuX21vdmVkJiZ0aGlzLl9tb3ZpbmcmJih6KHRoaXMuX2FuaW1SZXF1ZXN0KSx0aGlzLmZpcmUoXCJkcmFnZW5kXCIse2Rpc3RhbmNlOnRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKX0pKSx0aGlzLl9tb3Zpbmc9ITEsYWUuX2RyYWdnaW5nPSExfX0pO2Z1bmN0aW9uIGhlKHQsaSl7aWYoIWl8fCF0Lmxlbmd0aClyZXR1cm4gdC5zbGljZSgpO3ZhciBlPWkqaTtyZXR1cm4gdD1mdW5jdGlvbih0LGkpe3ZhciBlPXQubGVuZ3RoLG49bmV3KHR5cGVvZiBVaW50OEFycmF5IT12b2lkIDArXCJcIj9VaW50OEFycmF5OkFycmF5KShlKTtuWzBdPW5bZS0xXT0xLGZ1bmN0aW9uIHQoaSxlLG4sbyxzKXt2YXIgcixhLGgsdT0wO2ZvcihhPW8rMTthPD1zLTE7YSsrKWg9ZGUoaVthXSxpW29dLGlbc10sITApLHU8aCYmKHI9YSx1PWgpO248dSYmKGVbcl09MSx0KGksZSxuLG8sciksdChpLGUsbixyLHMpKX0odCxuLGksMCxlLTEpO3ZhciBvLHM9W107Zm9yKG89MDtvPGU7bysrKW5bb10mJnMucHVzaCh0W29dKTtyZXR1cm4gc30odD1mdW5jdGlvbih0LGkpe2Zvcih2YXIgZT1bdFswXV0sbj0xLG89MCxzPXQubGVuZ3RoO248cztuKyspKGZ1bmN0aW9uKHQsaSl7dmFyIGU9aS54LXQueCxuPWkueS10Lnk7cmV0dXJuIGUqZStuKm59KSh0W25dLHRbb10pPmkmJihlLnB1c2godFtuXSksbz1uKTtvPHMtMSYmZS5wdXNoKHRbcy0xXSk7cmV0dXJuIGV9KHQsZSksZSl9ZnVuY3Rpb24gdWUodCxpLGUpe3JldHVybiBNYXRoLnNxcnQoZGUodCxpLGUsITApKX1mdW5jdGlvbiBsZSh0LGksZSxuLG8pe3ZhciBzLHIsYSxoPW4/ZWU6X2UodCxlKSx1PV9lKGksZSk7Zm9yKGVlPXU7Oyl7aWYoIShofHUpKXJldHVyblt0LGldO2lmKGgmdSlyZXR1cm4hMTthPV9lKHI9Y2UodCxpLHM9aHx8dSxlLG8pLGUpLHM9PT1oPyh0PXIsaD1hKTooaT1yLHU9YSl9fWZ1bmN0aW9uIGNlKHQsaSxlLG4sbyl7dmFyIHMscixhPWkueC10LngsaD1pLnktdC55LHU9bi5taW4sbD1uLm1heDtyZXR1cm4gOCZlPyhzPXQueCthKihsLnktdC55KS9oLHI9bC55KTo0JmU/KHM9dC54K2EqKHUueS10LnkpL2gscj11LnkpOjImZT8ocz1sLngscj10LnkraCoobC54LXQueCkvYSk6MSZlJiYocz11Lngscj10LnkraCoodS54LXQueCkvYSksbmV3IGsocyxyLG8pfWZ1bmN0aW9uIF9lKHQsaSl7dmFyIGU9MDtyZXR1cm4gdC54PGkubWluLng/ZXw9MTp0Lng+aS5tYXgueCYmKGV8PTIpLHQueTxpLm1pbi55P2V8PTQ6dC55PmkubWF4LnkmJihlfD04KSxlfWZ1bmN0aW9uIGRlKHQsaSxlLG4pe3ZhciBvLHM9aS54LHI9aS55LGE9ZS54LXMsaD1lLnktcix1PWEqYStoKmg7cmV0dXJuIDA8dSYmKDE8KG89KCh0LngtcykqYSsodC55LXIpKmgpL3UpPyhzPWUueCxyPWUueSk6MDxvJiYocys9YSpvLHIrPWgqbykpLGE9dC54LXMsaD10LnktcixuP2EqYStoKmg6bmV3IGsocyxyKX1mdW5jdGlvbiBwZSh0KXtyZXR1cm4hZyh0WzBdKXx8XCJvYmplY3RcIiE9dHlwZW9mIHRbMF1bMF0mJnZvaWQgMCE9PXRbMF1bMF19ZnVuY3Rpb24gbWUodCl7cmV0dXJuIGNvbnNvbGUud2FybihcIkRlcHJlY2F0ZWQgdXNlIG9mIF9mbGF0LCBwbGVhc2UgdXNlIEwuTGluZVV0aWwuaXNGbGF0IGluc3RlYWQuXCIpLHBlKHQpfXZhciBmZT17c2ltcGxpZnk6aGUscG9pbnRUb1NlZ21lbnREaXN0YW5jZTp1ZSxjbG9zZXN0UG9pbnRPblNlZ21lbnQ6ZnVuY3Rpb24odCxpLGUpe3JldHVybiBkZSh0LGksZSl9LGNsaXBTZWdtZW50OmxlLF9nZXRFZGdlSW50ZXJzZWN0aW9uOmNlLF9nZXRCaXRDb2RlOl9lLF9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudDpkZSxpc0ZsYXQ6cGUsX2ZsYXQ6bWV9O2Z1bmN0aW9uIGdlKHQsaSxlKXtmb3IodmFyIG4sbyxzLHIsYSxoLHUsbD1bMSw0LDIsOF0sYz0wLF89dC5sZW5ndGg7YzxfO2MrKyl0W2NdLl9jb2RlPV9lKHRbY10saSk7Zm9yKHM9MDtzPDQ7cysrKXtmb3IoaD1sW3NdLG49W10sYz0wLG89KF89dC5sZW5ndGgpLTE7YzxfO289YysrKXI9dFtjXSxhPXRbb10sci5fY29kZSZoP2EuX2NvZGUmaHx8KCh1PWNlKGEscixoLGksZSkpLl9jb2RlPV9lKHUsaSksbi5wdXNoKHUpKTooYS5fY29kZSZoJiYoKHU9Y2UoYSxyLGgsaSxlKSkuX2NvZGU9X2UodSxpKSxuLnB1c2godSkpLG4ucHVzaChyKSk7dD1ufXJldHVybiB0fXZhciB2ZSx5ZT17Y2xpcFBvbHlnb246Z2V9LHhlPXtwcm9qZWN0OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgayh0LmxuZyx0LmxhdCl9LHVucHJvamVjdDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEQodC55LHQueCl9LGJvdW5kczpuZXcgSShbLTE4MCwtOTBdLFsxODAsOTBdKX0sd2U9e1I6NjM3ODEzNyxSX01JTk9SOjYzNTY3NTIuMzE0MjQ1MTc5LGJvdW5kczpuZXcgSShbLTIwMDM3NTA4LjM0Mjc5LC0xNTQ5NjU3MC43Mzk3Ml0sWzIwMDM3NTA4LjM0Mjc5LDE4NzY0NjU2LjIzMTM4XSkscHJvamVjdDpmdW5jdGlvbih0KXt2YXIgaT1NYXRoLlBJLzE4MCxlPXRoaXMuUixuPXQubGF0Kmksbz10aGlzLlJfTUlOT1IvZSxzPU1hdGguc3FydCgxLW8qbykscj1zKk1hdGguc2luKG4pLGE9TWF0aC50YW4oTWF0aC5QSS80LW4vMikvTWF0aC5wb3coKDEtcikvKDErcikscy8yKSxuPS1lKk1hdGgubG9nKE1hdGgubWF4KGEsMWUtMTApKTtyZXR1cm4gbmV3IGsodC5sbmcqaSplLG4pfSx1bnByb2plY3Q6ZnVuY3Rpb24odCl7Zm9yKHZhciBpLGU9MTgwL01hdGguUEksbj10aGlzLlIsbz10aGlzLlJfTUlOT1IvbixzPU1hdGguc3FydCgxLW8qbykscj1NYXRoLmV4cCgtdC55L24pLGE9TWF0aC5QSS8yLTIqTWF0aC5hdGFuKHIpLGg9MCx1PS4xO2g8MTUmJjFlLTc8TWF0aC5hYnModSk7aCsrKWk9cypNYXRoLnNpbihhKSxpPU1hdGgucG93KCgxLWkpLygxK2kpLHMvMiksYSs9dT1NYXRoLlBJLzItMipNYXRoLmF0YW4ocippKS1hO3JldHVybiBuZXcgRChhKmUsdC54KmUvbil9fSxQZT17TG9uTGF0OnhlLE1lcmNhdG9yOndlLFNwaGVyaWNhbE1lcmNhdG9yOlZ9LExlPWgoe30sRix7Y29kZTpcIkVQU0c6MzM5NVwiLHByb2plY3Rpb246d2UsdHJhbnNmb3JtYXRpb246Ryh2ZT0uNS8oTWF0aC5QSSp3ZS5SKSwuNSwtdmUsLjUpfSksYmU9aCh7fSxGLHtjb2RlOlwiRVBTRzo0MzI2XCIscHJvamVjdGlvbjp4ZSx0cmFuc2Zvcm1hdGlvbjpHKDEvMTgwLDEsLTEvMTgwLC41KX0pLFRlPWgoe30sSCx7cHJvamVjdGlvbjp4ZSx0cmFuc2Zvcm1hdGlvbjpHKDEsMCwtMSwwKSxzY2FsZTpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0KX0sem9vbTpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5sb2codCkvTWF0aC5MTjJ9LGRpc3RhbmNlOmZ1bmN0aW9uKHQsaSl7dmFyIGU9aS5sbmctdC5sbmcsbj1pLmxhdC10LmxhdDtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4pfSxpbmZpbml0ZTohMH0pO0guRWFydGg9RixILkVQU0czMzk1PUxlLEguRVBTRzM4NTc9WSxILkVQU0c5MDA5MTM9WCxILkVQU0c0MzI2PWJlLEguU2ltcGxlPVRlO3ZhciBNZT1FLmV4dGVuZCh7b3B0aW9uczp7cGFuZTpcIm92ZXJsYXlQYW5lXCIsYXR0cmlidXRpb246bnVsbCxidWJibGluZ01vdXNlRXZlbnRzOiEwfSxhZGRUbzpmdW5jdGlvbih0KXtyZXR1cm4gdC5hZGRMYXllcih0aGlzKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW1vdmVGcm9tKHRoaXMuX21hcHx8dGhpcy5fbWFwVG9BZGQpfSxyZW1vdmVGcm9tOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0LnJlbW92ZUxheWVyKHRoaXMpLHRoaXN9LGdldFBhbmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX21hcC5nZXRQYW5lKHQ/dGhpcy5vcHRpb25zW3RdfHx0OnRoaXMub3B0aW9ucy5wYW5lKX0sYWRkSW50ZXJhY3RpdmVUYXJnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX21hcC5fdGFyZ2V0c1ttKHQpXT10aGlzfSxyZW1vdmVJbnRlcmFjdGl2ZVRhcmdldDpmdW5jdGlvbih0KXtyZXR1cm4gZGVsZXRlIHRoaXMuX21hcC5fdGFyZ2V0c1ttKHQpXSx0aGlzfSxnZXRBdHRyaWJ1dGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuYXR0cmlidXRpb259LF9sYXllckFkZDpmdW5jdGlvbih0KXt2YXIgaSxlPXQudGFyZ2V0O2UuaGFzTGF5ZXIodGhpcykmJih0aGlzLl9tYXA9ZSx0aGlzLl96b29tQW5pbWF0ZWQ9ZS5fem9vbUFuaW1hdGVkLHRoaXMuZ2V0RXZlbnRzJiYoaT10aGlzLmdldEV2ZW50cygpLGUub24oaSx0aGlzKSx0aGlzLm9uY2UoXCJyZW1vdmVcIixmdW5jdGlvbigpe2Uub2ZmKGksdGhpcyl9LHRoaXMpKSx0aGlzLm9uQWRkKGUpLHRoaXMuZ2V0QXR0cmlidXRpb24mJmUuYXR0cmlidXRpb25Db250cm9sJiZlLmF0dHJpYnV0aW9uQ29udHJvbC5hZGRBdHRyaWJ1dGlvbih0aGlzLmdldEF0dHJpYnV0aW9uKCkpLHRoaXMuZmlyZShcImFkZFwiKSxlLmZpcmUoXCJsYXllcmFkZFwiLHtsYXllcjp0aGlzfSkpfX0pO0tpLmluY2x1ZGUoe2FkZExheWVyOmZ1bmN0aW9uKHQpe2lmKCF0Ll9sYXllckFkZCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcHJvdmlkZWQgb2JqZWN0IGlzIG5vdCBhIExheWVyLlwiKTt2YXIgaT1tKHQpO3JldHVybiB0aGlzLl9sYXllcnNbaV18fCgodGhpcy5fbGF5ZXJzW2ldPXQpLl9tYXBUb0FkZD10aGlzLHQuYmVmb3JlQWRkJiZ0LmJlZm9yZUFkZCh0aGlzKSx0aGlzLndoZW5SZWFkeSh0Ll9sYXllckFkZCx0KSksdGhpc30scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGk9bSh0KTtyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldJiYodGhpcy5fbG9hZGVkJiZ0Lm9uUmVtb3ZlKHRoaXMpLHQuZ2V0QXR0cmlidXRpb24mJnRoaXMuYXR0cmlidXRpb25Db250cm9sJiZ0aGlzLmF0dHJpYnV0aW9uQ29udHJvbC5yZW1vdmVBdHRyaWJ1dGlvbih0LmdldEF0dHJpYnV0aW9uKCkpLGRlbGV0ZSB0aGlzLl9sYXllcnNbaV0sdGhpcy5fbG9hZGVkJiYodGhpcy5maXJlKFwibGF5ZXJyZW1vdmVcIix7bGF5ZXI6dH0pLHQuZmlyZShcInJlbW92ZVwiKSksdC5fbWFwPXQuX21hcFRvQWRkPW51bGwpLHRoaXN9LGhhc0xheWVyOmZ1bmN0aW9uKHQpe3JldHVybiEhdCYmbSh0KWluIHRoaXMuX2xheWVyc30sZWFjaExheWVyOmZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBlIGluIHRoaXMuX2xheWVycyl0LmNhbGwoaSx0aGlzLl9sYXllcnNbZV0pO3JldHVybiB0aGlzfSxfYWRkTGF5ZXJzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaT0wLGU9KHQ9dD9nKHQpP3Q6W3RdOltdKS5sZW5ndGg7aTxlO2krKyl0aGlzLmFkZExheWVyKHRbaV0pfSxfYWRkWm9vbUxpbWl0OmZ1bmN0aW9uKHQpeyFpc05hTih0Lm9wdGlvbnMubWF4Wm9vbSkmJmlzTmFOKHQub3B0aW9ucy5taW5ab29tKXx8KHRoaXMuX3pvb21Cb3VuZExheWVyc1ttKHQpXT10LHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKSl9LF9yZW1vdmVab29tTGltaXQ6ZnVuY3Rpb24odCl7dmFyIGk9bSh0KTt0aGlzLl96b29tQm91bmRMYXllcnNbaV0mJihkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2ldLHRoaXMuX3VwZGF0ZVpvb21MZXZlbHMoKSl9LF91cGRhdGVab29tTGV2ZWxzOmZ1bmN0aW9uKCl7dmFyIHQ9MS8wLGk9LTEvMCxlPXRoaXMuX2dldFpvb21TcGFuKCk7Zm9yKHZhciBuIGluIHRoaXMuX3pvb21Cb3VuZExheWVycyl2YXIgbz10aGlzLl96b29tQm91bmRMYXllcnNbbl0ub3B0aW9ucyx0PXZvaWQgMD09PW8ubWluWm9vbT90Ok1hdGgubWluKHQsby5taW5ab29tKSxpPXZvaWQgMD09PW8ubWF4Wm9vbT9pOk1hdGgubWF4KGksby5tYXhab29tKTt0aGlzLl9sYXllcnNNYXhab29tPWk9PT0tMS8wP3ZvaWQgMDppLHRoaXMuX2xheWVyc01pblpvb209dD09PTEvMD92b2lkIDA6dCxlIT09dGhpcy5fZ2V0Wm9vbVNwYW4oKSYmdGhpcy5maXJlKFwiem9vbWxldmVsc2NoYW5nZVwiKSx2b2lkIDA9PT10aGlzLm9wdGlvbnMubWF4Wm9vbSYmdGhpcy5fbGF5ZXJzTWF4Wm9vbSYmdGhpcy5nZXRab29tKCk+dGhpcy5fbGF5ZXJzTWF4Wm9vbSYmdGhpcy5zZXRab29tKHRoaXMuX2xheWVyc01heFpvb20pLHZvaWQgMD09PXRoaXMub3B0aW9ucy5taW5ab29tJiZ0aGlzLl9sYXllcnNNaW5ab29tJiZ0aGlzLmdldFpvb20oKTx0aGlzLl9sYXllcnNNaW5ab29tJiZ0aGlzLnNldFpvb20odGhpcy5fbGF5ZXJzTWluWm9vbSl9fSk7dmFyIHplPU1lLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe3ZhciBlLG47aWYoYyh0aGlzLGkpLHRoaXMuX2xheWVycz17fSx0KWZvcihlPTAsbj10Lmxlbmd0aDtlPG47ZSsrKXRoaXMuYWRkTGF5ZXIodFtlXSl9LGFkZExheWVyOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZ2V0TGF5ZXJJZCh0KTtyZXR1cm4gdGhpcy5fbGF5ZXJzW2ldPXQsdGhpcy5fbWFwJiZ0aGlzLl9tYXAuYWRkTGF5ZXIodCksdGhpc30scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7dmFyIGk9dCBpbiB0aGlzLl9sYXllcnM/dDp0aGlzLmdldExheWVySWQodCk7cmV0dXJuIHRoaXMuX21hcCYmdGhpcy5fbGF5ZXJzW2ldJiZ0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJzW2ldKSxkZWxldGUgdGhpcy5fbGF5ZXJzW2ldLHRoaXN9LGhhc0xheWVyOmZ1bmN0aW9uKHQpe3JldHVybiEhdCYmKFwibnVtYmVyXCI9PXR5cGVvZiB0P3Q6dGhpcy5nZXRMYXllcklkKHQpKWluIHRoaXMuX2xheWVyc30sY2xlYXJMYXllcnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodGhpcy5yZW1vdmVMYXllcix0aGlzKX0saW52b2tlOmZ1bmN0aW9uKHQpe3ZhciBpLGUsbj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7Zm9yKGkgaW4gdGhpcy5fbGF5ZXJzKShlPXRoaXMuX2xheWVyc1tpXSlbdF0mJmVbdF0uYXBwbHkoZSxuKTtyZXR1cm4gdGhpc30sb25BZGQ6ZnVuY3Rpb24odCl7dGhpcy5lYWNoTGF5ZXIodC5hZGRMYXllcix0KX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7dGhpcy5lYWNoTGF5ZXIodC5yZW1vdmVMYXllcix0KX0sZWFjaExheWVyOmZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBlIGluIHRoaXMuX2xheWVycyl0LmNhbGwoaSx0aGlzLl9sYXllcnNbZV0pO3JldHVybiB0aGlzfSxnZXRMYXllcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbGF5ZXJzW3RdfSxnZXRMYXllcnM6ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdGhpcy5lYWNoTGF5ZXIodC5wdXNoLHQpLHR9LHNldFpJbmRleDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pbnZva2UoXCJzZXRaSW5kZXhcIix0KX0sZ2V0TGF5ZXJJZDptfSksQ2U9emUuZXh0ZW5kKHthZGRMYXllcjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oYXNMYXllcih0KT90aGlzOih0LmFkZEV2ZW50UGFyZW50KHRoaXMpLHplLnByb3RvdHlwZS5hZGRMYXllci5jYWxsKHRoaXMsdCksdGhpcy5maXJlKFwibGF5ZXJhZGRcIix7bGF5ZXI6dH0pKX0scmVtb3ZlTGF5ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGFzTGF5ZXIodCk/KHQgaW4gdGhpcy5fbGF5ZXJzJiYodD10aGlzLl9sYXllcnNbdF0pLHQucmVtb3ZlRXZlbnRQYXJlbnQodGhpcyksemUucHJvdG90eXBlLnJlbW92ZUxheWVyLmNhbGwodGhpcyx0KSx0aGlzLmZpcmUoXCJsYXllcnJlbW92ZVwiLHtsYXllcjp0fSkpOnRoaXN9LHNldFN0eWxlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmludm9rZShcInNldFN0eWxlXCIsdCl9LGJyaW5nVG9Gcm9udDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludm9rZShcImJyaW5nVG9Gcm9udFwiKX0sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZva2UoXCJicmluZ1RvQmFja1wiKX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFI7Zm9yKHZhciBpIGluIHRoaXMuX2xheWVycyl7dmFyIGU9dGhpcy5fbGF5ZXJzW2ldO3QuZXh0ZW5kKGUuZ2V0Qm91bmRzP2UuZ2V0Qm91bmRzKCk6ZS5nZXRMYXRMbmcoKSl9cmV0dXJuIHR9fSksU2U9Uy5leHRlbmQoe29wdGlvbnM6e3BvcHVwQW5jaG9yOlswLDBdLHRvb2x0aXBBbmNob3I6WzAsMF19LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7Yyh0aGlzLHQpfSxjcmVhdGVJY29uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jcmVhdGVJY29uKFwiaWNvblwiLHQpfSxjcmVhdGVTaGFkb3c6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NyZWF0ZUljb24oXCJzaGFkb3dcIix0KX0sX2NyZWF0ZUljb246ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLl9nZXRJY29uVXJsKHQpO2lmKCFlKXtpZihcImljb25cIj09PXQpdGhyb3cgbmV3IEVycm9yKFwiaWNvblVybCBub3Qgc2V0IGluIEljb24gb3B0aW9ucyAoc2VlIHRoZSBkb2NzKS5cIik7cmV0dXJuIG51bGx9dmFyIG49dGhpcy5fY3JlYXRlSW1nKGUsaSYmXCJJTUdcIj09PWkudGFnTmFtZT9pOm51bGwpO3JldHVybiB0aGlzLl9zZXRJY29uU3R5bGVzKG4sdCksbn0sX3NldEljb25TdHlsZXM6ZnVuY3Rpb24odCxpKXt2YXIgZT10aGlzLm9wdGlvbnMsbj1lW2krXCJTaXplXCJdO1wibnVtYmVyXCI9PXR5cGVvZiBuJiYobj1bbixuXSk7dmFyIG89QShuKSxzPUEoXCJzaGFkb3dcIj09PWkmJmUuc2hhZG93QW5jaG9yfHxlLmljb25BbmNob3J8fG8mJm8uZGl2aWRlQnkoMiwhMCkpO3QuY2xhc3NOYW1lPVwibGVhZmxldC1tYXJrZXItXCIraStcIiBcIisoZS5jbGFzc05hbWV8fFwiXCIpLHMmJih0LnN0eWxlLm1hcmdpbkxlZnQ9LXMueCtcInB4XCIsdC5zdHlsZS5tYXJnaW5Ub3A9LXMueStcInB4XCIpLG8mJih0LnN0eWxlLndpZHRoPW8ueCtcInB4XCIsdC5zdHlsZS5oZWlnaHQ9by55K1wicHhcIil9LF9jcmVhdGVJbWc6ZnVuY3Rpb24odCxpKXtyZXR1cm4oaT1pfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpKS5zcmM9dCxpfSxfZ2V0SWNvblVybDpmdW5jdGlvbih0KXtyZXR1cm4genQmJnRoaXMub3B0aW9uc1t0K1wiUmV0aW5hVXJsXCJdfHx0aGlzLm9wdGlvbnNbdCtcIlVybFwiXX19KTt2YXIgWmU9U2UuZXh0ZW5kKHtvcHRpb25zOntpY29uVXJsOlwibWFya2VyLWljb24ucG5nXCIsaWNvblJldGluYVVybDpcIm1hcmtlci1pY29uLTJ4LnBuZ1wiLHNoYWRvd1VybDpcIm1hcmtlci1zaGFkb3cucG5nXCIsaWNvblNpemU6WzI1LDQxXSxpY29uQW5jaG9yOlsxMiw0MV0scG9wdXBBbmNob3I6WzEsLTM0XSx0b29sdGlwQW5jaG9yOlsxNiwtMjhdLHNoYWRvd1NpemU6WzQxLDQxXX0sX2dldEljb25Vcmw6ZnVuY3Rpb24odCl7cmV0dXJuIFplLmltYWdlUGF0aHx8KFplLmltYWdlUGF0aD10aGlzLl9kZXRlY3RJY29uUGF0aCgpKSwodGhpcy5vcHRpb25zLmltYWdlUGF0aHx8WmUuaW1hZ2VQYXRoKStTZS5wcm90b3R5cGUuX2dldEljb25VcmwuY2FsbCh0aGlzLHQpfSxfZGV0ZWN0SWNvblBhdGg6ZnVuY3Rpb24oKXt2YXIgdD1zaShcImRpdlwiLFwibGVhZmxldC1kZWZhdWx0LWljb24tcGF0aFwiLGRvY3VtZW50LmJvZHkpLGk9b2kodCxcImJhY2tncm91bmQtaW1hZ2VcIil8fG9pKHQsXCJiYWNrZ3JvdW5kSW1hZ2VcIik7cmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksaT1udWxsPT09aXx8MCE9PWkuaW5kZXhPZihcInVybFwiKT9cIlwiOmkucmVwbGFjZSgvXnVybFxcKFtcIiddPy8sXCJcIikucmVwbGFjZSgvbWFya2VyLWljb25cXC5wbmdbXCInXT9cXCkkLyxcIlwiKX19KSxFZT1pZS5leHRlbmQoe2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fbWFya2VyPXR9LGFkZEhvb2tzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fbWFya2VyLl9pY29uO3RoaXMuX2RyYWdnYWJsZXx8KHRoaXMuX2RyYWdnYWJsZT1uZXcgYWUodCx0LCEwKSksdGhpcy5fZHJhZ2dhYmxlLm9uKHtkcmFnc3RhcnQ6dGhpcy5fb25EcmFnU3RhcnQscHJlZHJhZzp0aGlzLl9vblByZURyYWcsZHJhZzp0aGlzLl9vbkRyYWcsZHJhZ2VuZDp0aGlzLl9vbkRyYWdFbmR9LHRoaXMpLmVuYWJsZSgpLGNpKHQsXCJsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGVcIil9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7dGhpcy5fZHJhZ2dhYmxlLm9mZih7ZHJhZ3N0YXJ0OnRoaXMuX29uRHJhZ1N0YXJ0LHByZWRyYWc6dGhpcy5fb25QcmVEcmFnLGRyYWc6dGhpcy5fb25EcmFnLGRyYWdlbmQ6dGhpcy5fb25EcmFnRW5kfSx0aGlzKS5kaXNhYmxlKCksdGhpcy5fbWFya2VyLl9pY29uJiZfaSh0aGlzLl9tYXJrZXIuX2ljb24sXCJsZWFmbGV0LW1hcmtlci1kcmFnZ2FibGVcIil9LG1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RyYWdnYWJsZSYmdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZH0sX2FkanVzdFBhbjpmdW5jdGlvbih0KXt2YXIgaSxlPXRoaXMuX21hcmtlcixuPWUuX21hcCxvPXRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5TcGVlZCxzPXRoaXMuX21hcmtlci5vcHRpb25zLmF1dG9QYW5QYWRkaW5nLHI9eWkoZS5faWNvbiksYT1uLmdldFBpeGVsQm91bmRzKCksaD1uLmdldFBpeGVsT3JpZ2luKCksdT1PKGEubWluLl9zdWJ0cmFjdChoKS5hZGQocyksYS5tYXguX3N1YnRyYWN0KGgpLnN1YnRyYWN0KHMpKTt1LmNvbnRhaW5zKHIpfHwoaT1BKChNYXRoLm1heCh1Lm1heC54LHIueCktdS5tYXgueCkvKGEubWF4LngtdS5tYXgueCktKE1hdGgubWluKHUubWluLngsci54KS11Lm1pbi54KS8oYS5taW4ueC11Lm1pbi54KSwoTWF0aC5tYXgodS5tYXgueSxyLnkpLXUubWF4LnkpLyhhLm1heC55LXUubWF4LnkpLShNYXRoLm1pbih1Lm1pbi55LHIueSktdS5taW4ueSkvKGEubWluLnktdS5taW4ueSkpLm11bHRpcGx5Qnkobyksbi5wYW5CeShpLHthbmltYXRlOiExfSksdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuX2FkZChpKSx0aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLl9hZGQoaSksdmkoZS5faWNvbix0aGlzLl9kcmFnZ2FibGUuX25ld1BvcyksdGhpcy5fb25EcmFnKHQpLHRoaXMuX3BhblJlcXVlc3Q9TSh0aGlzLl9hZGp1c3RQYW4uYmluZCh0aGlzLHQpKSl9LF9vbkRyYWdTdGFydDpmdW5jdGlvbigpe3RoaXMuX29sZExhdExuZz10aGlzLl9tYXJrZXIuZ2V0TGF0TG5nKCksdGhpcy5fbWFya2VyLmNsb3NlUG9wdXAmJnRoaXMuX21hcmtlci5jbG9zZVBvcHVwKCksdGhpcy5fbWFya2VyLmZpcmUoXCJtb3Zlc3RhcnRcIikuZmlyZShcImRyYWdzdGFydFwiKX0sX29uUHJlRHJhZzpmdW5jdGlvbih0KXt0aGlzLl9tYXJrZXIub3B0aW9ucy5hdXRvUGFuJiYoeih0aGlzLl9wYW5SZXF1ZXN0KSx0aGlzLl9wYW5SZXF1ZXN0PU0odGhpcy5fYWRqdXN0UGFuLmJpbmQodGhpcyx0KSkpfSxfb25EcmFnOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcmtlcixlPWkuX3NoYWRvdyxuPXlpKGkuX2ljb24pLG89aS5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhuKTtlJiZ2aShlLG4pLGkuX2xhdGxuZz1vLHQubGF0bG5nPW8sdC5vbGRMYXRMbmc9dGhpcy5fb2xkTGF0TG5nLGkuZmlyZShcIm1vdmVcIix0KS5maXJlKFwiZHJhZ1wiLHQpfSxfb25EcmFnRW5kOmZ1bmN0aW9uKHQpe3oodGhpcy5fcGFuUmVxdWVzdCksZGVsZXRlIHRoaXMuX29sZExhdExuZyx0aGlzLl9tYXJrZXIuZmlyZShcIm1vdmVlbmRcIikuZmlyZShcImRyYWdlbmRcIix0KX19KSxrZT1NZS5leHRlbmQoe29wdGlvbnM6e2ljb246bmV3IFplLGludGVyYWN0aXZlOiEwLGtleWJvYXJkOiEwLHRpdGxlOlwiXCIsYWx0OlwiXCIsekluZGV4T2Zmc2V0OjAsb3BhY2l0eToxLHJpc2VPbkhvdmVyOiExLHJpc2VPZmZzZXQ6MjUwLHBhbmU6XCJtYXJrZXJQYW5lXCIsc2hhZG93UGFuZTpcInNoYWRvd1BhbmVcIixidWJibGluZ01vdXNlRXZlbnRzOiExLGRyYWdnYWJsZTohMSxhdXRvUGFuOiExLGF1dG9QYW5QYWRkaW5nOls1MCw1MF0sYXV0b1BhblNwZWVkOjEwfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7Yyh0aGlzLGkpLHRoaXMuX2xhdGxuZz1qKHQpfSxvbkFkZDpmdW5jdGlvbih0KXt0aGlzLl96b29tQW5pbWF0ZWQ9dGhpcy5fem9vbUFuaW1hdGVkJiZ0Lm9wdGlvbnMubWFya2VyWm9vbUFuaW1hdGlvbix0aGlzLl96b29tQW5pbWF0ZWQmJnQub24oXCJ6b29tYW5pbVwiLHRoaXMuX2FuaW1hdGVab29tLHRoaXMpLHRoaXMuX2luaXRJY29uKCksdGhpcy51cGRhdGUoKX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7dGhpcy5kcmFnZ2luZyYmdGhpcy5kcmFnZ2luZy5lbmFibGVkKCkmJih0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlPSEwLHRoaXMuZHJhZ2dpbmcucmVtb3ZlSG9va3MoKSksZGVsZXRlIHRoaXMuZHJhZ2dpbmcsdGhpcy5fem9vbUFuaW1hdGVkJiZ0Lm9mZihcInpvb21hbmltXCIsdGhpcy5fYW5pbWF0ZVpvb20sdGhpcyksdGhpcy5fcmVtb3ZlSWNvbigpLHRoaXMuX3JlbW92ZVNoYWRvdygpfSxnZXRFdmVudHM6ZnVuY3Rpb24oKXtyZXR1cm57em9vbTp0aGlzLnVwZGF0ZSx2aWV3cmVzZXQ6dGhpcy51cGRhdGV9fSxnZXRMYXRMbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGF0bG5nfSxzZXRMYXRMbmc6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbGF0bG5nO3JldHVybiB0aGlzLl9sYXRsbmc9aih0KSx0aGlzLnVwZGF0ZSgpLHRoaXMuZmlyZShcIm1vdmVcIix7b2xkTGF0TG5nOmksbGF0bG5nOnRoaXMuX2xhdGxuZ30pfSxzZXRaSW5kZXhPZmZzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ9dCx0aGlzLnVwZGF0ZSgpfSxnZXRJY29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9ucy5pY29ufSxzZXRJY29uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbj10LHRoaXMuX21hcCYmKHRoaXMuX2luaXRJY29uKCksdGhpcy51cGRhdGUoKSksdGhpcy5fcG9wdXAmJnRoaXMuYmluZFBvcHVwKHRoaXMuX3BvcHVwLHRoaXMuX3BvcHVwLm9wdGlvbnMpLHRoaXN9LGdldEVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWNvbn0sdXBkYXRlOmZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHRoaXMuX2ljb24mJnRoaXMuX21hcCYmKHQ9dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLnJvdW5kKCksdGhpcy5fc2V0UG9zKHQpKSx0aGlzfSxfaW5pdEljb246ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMsaT1cImxlYWZsZXQtem9vbS1cIisodGhpcy5fem9vbUFuaW1hdGVkP1wiYW5pbWF0ZWRcIjpcImhpZGVcIiksZT10Lmljb24uY3JlYXRlSWNvbih0aGlzLl9pY29uKSxuPSExO2UhPT10aGlzLl9pY29uJiYodGhpcy5faWNvbiYmdGhpcy5fcmVtb3ZlSWNvbigpLG49ITAsdC50aXRsZSYmKGUudGl0bGU9dC50aXRsZSksXCJJTUdcIj09PWUudGFnTmFtZSYmKGUuYWx0PXQuYWx0fHxcIlwiKSksY2koZSxpKSx0LmtleWJvYXJkJiYoZS50YWJJbmRleD1cIjBcIiksdGhpcy5faWNvbj1lLHQucmlzZU9uSG92ZXImJnRoaXMub24oe21vdXNlb3Zlcjp0aGlzLl9icmluZ1RvRnJvbnQsbW91c2VvdXQ6dGhpcy5fcmVzZXRaSW5kZXh9KTt2YXIgbz10Lmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdykscz0hMTtvIT09dGhpcy5fc2hhZG93JiYodGhpcy5fcmVtb3ZlU2hhZG93KCkscz0hMCksbyYmKGNpKG8saSksby5hbHQ9XCJcIiksdGhpcy5fc2hhZG93PW8sdC5vcGFjaXR5PDEmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSxuJiZ0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKSx0aGlzLl9pbml0SW50ZXJhY3Rpb24oKSxvJiZzJiZ0aGlzLmdldFBhbmUodC5zaGFkb3dQYW5lKS5hcHBlbmRDaGlsZCh0aGlzLl9zaGFkb3cpfSxfcmVtb3ZlSWNvbjpmdW5jdGlvbigpe3RoaXMub3B0aW9ucy5yaXNlT25Ib3ZlciYmdGhpcy5vZmYoe21vdXNlb3Zlcjp0aGlzLl9icmluZ1RvRnJvbnQsbW91c2VvdXQ6dGhpcy5fcmVzZXRaSW5kZXh9KSxyaSh0aGlzLl9pY29uKSx0aGlzLnJlbW92ZUludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ljb24pLHRoaXMuX2ljb249bnVsbH0sX3JlbW92ZVNoYWRvdzpmdW5jdGlvbigpe3RoaXMuX3NoYWRvdyYmcmkodGhpcy5fc2hhZG93KSx0aGlzLl9zaGFkb3c9bnVsbH0sX3NldFBvczpmdW5jdGlvbih0KXt0aGlzLl9pY29uJiZ2aSh0aGlzLl9pY29uLHQpLHRoaXMuX3NoYWRvdyYmdmkodGhpcy5fc2hhZG93LHQpLHRoaXMuX3pJbmRleD10LnkrdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCx0aGlzLl9yZXNldFpJbmRleCgpfSxfdXBkYXRlWkluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuX2ljb24mJih0aGlzLl9pY29uLnN0eWxlLnpJbmRleD10aGlzLl96SW5kZXgrdCl9LF9hbmltYXRlWm9vbTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsdC56b29tLHQuY2VudGVyKS5yb3VuZCgpO3RoaXMuX3NldFBvcyhpKX0sX2luaXRJbnRlcmFjdGlvbjpmdW5jdGlvbigpe3ZhciB0O3RoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSYmKGNpKHRoaXMuX2ljb24sXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuYWRkSW50ZXJhY3RpdmVUYXJnZXQodGhpcy5faWNvbiksRWUmJih0PXRoaXMub3B0aW9ucy5kcmFnZ2FibGUsdGhpcy5kcmFnZ2luZyYmKHQ9dGhpcy5kcmFnZ2luZy5lbmFibGVkKCksdGhpcy5kcmFnZ2luZy5kaXNhYmxlKCkpLHRoaXMuZHJhZ2dpbmc9bmV3IEVlKHRoaXMpLHQmJnRoaXMuZHJhZ2dpbmcuZW5hYmxlKCkpKX0sc2V0T3BhY2l0eTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl9tYXAmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSx0aGlzfSxfdXBkYXRlT3BhY2l0eTpmdW5jdGlvbigpe3ZhciB0PXRoaXMub3B0aW9ucy5vcGFjaXR5O3RoaXMuX2ljb24mJm1pKHRoaXMuX2ljb24sdCksdGhpcy5fc2hhZG93JiZtaSh0aGlzLl9zaGFkb3csdCl9LF9icmluZ1RvRnJvbnQ6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpfSxfcmVzZXRaSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVaSW5kZXgoMCl9LF9nZXRQb3B1cEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yfSxfZ2V0VG9vbHRpcEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnRvb2x0aXBBbmNob3J9fSk7dmFyIEJlPU1lLmV4dGVuZCh7b3B0aW9uczp7c3Ryb2tlOiEwLGNvbG9yOlwiIzMzODhmZlwiLHdlaWdodDozLG9wYWNpdHk6MSxsaW5lQ2FwOlwicm91bmRcIixsaW5lSm9pbjpcInJvdW5kXCIsZGFzaEFycmF5Om51bGwsZGFzaE9mZnNldDpudWxsLGZpbGw6ITEsZmlsbENvbG9yOm51bGwsZmlsbE9wYWNpdHk6LjIsZmlsbFJ1bGU6XCJldmVub2RkXCIsaW50ZXJhY3RpdmU6ITAsYnViYmxpbmdNb3VzZUV2ZW50czohMH0sYmVmb3JlQWRkOmZ1bmN0aW9uKHQpe3RoaXMuX3JlbmRlcmVyPXQuZ2V0UmVuZGVyZXIodGhpcyl9LG9uQWRkOmZ1bmN0aW9uKCl7dGhpcy5fcmVuZGVyZXIuX2luaXRQYXRoKHRoaXMpLHRoaXMuX3Jlc2V0KCksdGhpcy5fcmVuZGVyZXIuX2FkZFBhdGgodGhpcyl9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7dGhpcy5fcmVuZGVyZXIuX3JlbW92ZVBhdGgodGhpcyl9LHJlZHJhdzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJnRoaXMuX3JlbmRlcmVyLl91cGRhdGVQYXRoKHRoaXMpLHRoaXN9LHNldFN0eWxlOmZ1bmN0aW9uKHQpe3JldHVybiBjKHRoaXMsdCksdGhpcy5fcmVuZGVyZXImJih0aGlzLl9yZW5kZXJlci5fdXBkYXRlU3R5bGUodGhpcyksdGhpcy5vcHRpb25zLnN0cm9rZSYmdCYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJ3ZWlnaHRcIikmJnRoaXMuX3VwZGF0ZUJvdW5kcygpKSx0aGlzfSxicmluZ1RvRnJvbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVyZXImJnRoaXMuX3JlbmRlcmVyLl9icmluZ1RvRnJvbnQodGhpcyksdGhpc30sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVuZGVyZXImJnRoaXMuX3JlbmRlcmVyLl9icmluZ1RvQmFjayh0aGlzKSx0aGlzfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BhdGh9LF9yZXNldDpmdW5jdGlvbigpe3RoaXMuX3Byb2plY3QoKSx0aGlzLl91cGRhdGUoKX0sX2NsaWNrVG9sZXJhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMub3B0aW9ucy5zdHJva2U/dGhpcy5vcHRpb25zLndlaWdodC8yOjApK3RoaXMuX3JlbmRlcmVyLm9wdGlvbnMudG9sZXJhbmNlfX0pLEFlPUJlLmV4dGVuZCh7b3B0aW9uczp7ZmlsbDohMCxyYWRpdXM6MTB9LGluaXRpYWxpemU6ZnVuY3Rpb24odCxpKXtjKHRoaXMsaSksdGhpcy5fbGF0bG5nPWoodCksdGhpcy5fcmFkaXVzPXRoaXMub3B0aW9ucy5yYWRpdXN9LHNldExhdExuZzpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9sYXRsbmc7cmV0dXJuIHRoaXMuX2xhdGxuZz1qKHQpLHRoaXMucmVkcmF3KCksdGhpcy5maXJlKFwibW92ZVwiLHtvbGRMYXRMbmc6aSxsYXRsbmc6dGhpcy5fbGF0bG5nfSl9LGdldExhdExuZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sYXRsbmd9LHNldFJhZGl1czpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLnJhZGl1cz10aGlzLl9yYWRpdXM9dCx0aGlzLnJlZHJhdygpfSxnZXRSYWRpdXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmFkaXVzfSxzZXRTdHlsZTpmdW5jdGlvbih0KXt2YXIgaT10JiZ0LnJhZGl1c3x8dGhpcy5fcmFkaXVzO3JldHVybiBCZS5wcm90b3R5cGUuc2V0U3R5bGUuY2FsbCh0aGlzLHQpLHRoaXMuc2V0UmFkaXVzKGkpLHRoaXN9LF9wcm9qZWN0OmZ1bmN0aW9uKCl7dGhpcy5fcG9pbnQ9dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLHRoaXMuX3VwZGF0ZUJvdW5kcygpfSxfdXBkYXRlQm91bmRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcmFkaXVzLGk9dGhpcy5fcmFkaXVzWXx8dCxlPXRoaXMuX2NsaWNrVG9sZXJhbmNlKCksbj1bdCtlLGkrZV07dGhpcy5fcHhCb3VuZHM9bmV3IEkodGhpcy5fcG9pbnQuc3VidHJhY3QobiksdGhpcy5fcG9pbnQuYWRkKG4pKX0sX3VwZGF0ZTpmdW5jdGlvbigpe3RoaXMuX21hcCYmdGhpcy5fdXBkYXRlUGF0aCgpfSxfdXBkYXRlUGF0aDpmdW5jdGlvbigpe3RoaXMuX3JlbmRlcmVyLl91cGRhdGVDaXJjbGUodGhpcyl9LF9lbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yYWRpdXMmJiF0aGlzLl9yZW5kZXJlci5fYm91bmRzLmludGVyc2VjdHModGhpcy5fcHhCb3VuZHMpfSxfY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gdC5kaXN0YW5jZVRvKHRoaXMuX3BvaW50KTw9dGhpcy5fcmFkaXVzK3RoaXMuX2NsaWNrVG9sZXJhbmNlKCl9fSk7dmFyIEllPUFlLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0LGksZSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGkmJihpPWgoe30sZSx7cmFkaXVzOml9KSksYyh0aGlzLGkpLHRoaXMuX2xhdGxuZz1qKHQpLGlzTmFOKHRoaXMub3B0aW9ucy5yYWRpdXMpKXRocm93IG5ldyBFcnJvcihcIkNpcmNsZSByYWRpdXMgY2Fubm90IGJlIE5hTlwiKTt0aGlzLl9tUmFkaXVzPXRoaXMub3B0aW9ucy5yYWRpdXN9LHNldFJhZGl1czpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbVJhZGl1cz10LHRoaXMucmVkcmF3KCl9LGdldFJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tUmFkaXVzfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXt2YXIgdD1bdGhpcy5fcmFkaXVzLHRoaXMuX3JhZGl1c1l8fHRoaXMuX3JhZGl1c107cmV0dXJuIG5ldyBSKHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuc3VidHJhY3QodCkpLHRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcodGhpcy5fcG9pbnQuYWRkKHQpKSl9LHNldFN0eWxlOkJlLnByb3RvdHlwZS5zZXRTdHlsZSxfcHJvamVjdDpmdW5jdGlvbigpe3ZhciB0LGksZSxuLG8scyxyLGEsaD10aGlzLl9sYXRsbmcubG5nLHU9dGhpcy5fbGF0bG5nLmxhdCxsPXRoaXMuX21hcCxjPWwub3B0aW9ucy5jcnM7Yy5kaXN0YW5jZT09PUYuZGlzdGFuY2U/KHQ9TWF0aC5QSS8xODAsaT10aGlzLl9tUmFkaXVzL0YuUi90LGU9bC5wcm9qZWN0KFt1K2ksaF0pLG49bC5wcm9qZWN0KFt1LWksaF0pLG89ZS5hZGQobikuZGl2aWRlQnkoMikscz1sLnVucHJvamVjdChvKS5sYXQscj1NYXRoLmFjb3MoKE1hdGguY29zKGkqdCktTWF0aC5zaW4odSp0KSpNYXRoLnNpbihzKnQpKS8oTWF0aC5jb3ModSp0KSpNYXRoLmNvcyhzKnQpKSkvdCwhaXNOYU4ocikmJjAhPT1yfHwocj1pL01hdGguY29zKE1hdGguUEkvMTgwKnUpKSx0aGlzLl9wb2ludD1vLnN1YnRyYWN0KGwuZ2V0UGl4ZWxPcmlnaW4oKSksdGhpcy5fcmFkaXVzPWlzTmFOKHIpPzA6by54LWwucHJvamVjdChbcyxoLXJdKS54LHRoaXMuX3JhZGl1c1k9by55LWUueSk6KGE9Yy51bnByb2plY3QoYy5wcm9qZWN0KHRoaXMuX2xhdGxuZykuc3VidHJhY3QoW3RoaXMuX21SYWRpdXMsMF0pKSx0aGlzLl9wb2ludD1sLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLHRoaXMuX3JhZGl1cz10aGlzLl9wb2ludC54LWwubGF0TG5nVG9MYXllclBvaW50KGEpLngpLHRoaXMuX3VwZGF0ZUJvdW5kcygpfX0pO3ZhciBPZT1CZS5leHRlbmQoe29wdGlvbnM6e3Ntb290aEZhY3RvcjoxLG5vQ2xpcDohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe2ModGhpcyxpKSx0aGlzLl9zZXRMYXRMbmdzKHQpfSxnZXRMYXRMbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xhdGxuZ3N9LHNldExhdExuZ3M6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3NldExhdExuZ3ModCksdGhpcy5yZWRyYXcoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiF0aGlzLl9sYXRsbmdzLmxlbmd0aH0sY2xvc2VzdExheWVyUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBpLGUsbj0xLzAsbz1udWxsLHM9ZGUscj0wLGE9dGhpcy5fcGFydHMubGVuZ3RoO3I8YTtyKyspZm9yKHZhciBoPXRoaXMuX3BhcnRzW3JdLHU9MSxsPWgubGVuZ3RoO3U8bDt1Kyspe3ZhciBjPXModCxpPWhbdS0xXSxlPWhbdV0sITApO2M8biYmKG49YyxvPXModCxpLGUpKX1yZXR1cm4gbyYmKG8uZGlzdGFuY2U9TWF0aC5zcXJ0KG4pKSxvfSxnZXRDZW50ZXI6ZnVuY3Rpb24oKXtpZighdGhpcy5fbWFwKXRocm93IG5ldyBFcnJvcihcIk11c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKClcIik7dmFyIHQsaSxlLG4sbyxzLHIsYT10aGlzLl9yaW5nc1swXSxoPWEubGVuZ3RoO2lmKCFoKXJldHVybiBudWxsO2ZvcihpPXQ9MDt0PGgtMTt0KyspaSs9YVt0XS5kaXN0YW5jZVRvKGFbdCsxXSkvMjtpZigwPT09aSlyZXR1cm4gdGhpcy5fbWFwLmxheWVyUG9pbnRUb0xhdExuZyhhWzBdKTtmb3Iobj10PTA7dDxoLTE7dCsrKWlmKG89YVt0XSxzPWFbdCsxXSxpPChuKz1lPW8uZGlzdGFuY2VUbyhzKSkpcmV0dXJuIHI9KG4taSkvZSx0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKFtzLngtcioocy54LW8ueCkscy55LXIqKHMueS1vLnkpXSl9LGdldEJvdW5kczpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib3VuZHN9LGFkZExhdExuZzpmdW5jdGlvbih0LGkpe3JldHVybiBpPWl8fHRoaXMuX2RlZmF1bHRTaGFwZSgpLHQ9aih0KSxpLnB1c2godCksdGhpcy5fYm91bmRzLmV4dGVuZCh0KSx0aGlzLnJlZHJhdygpfSxfc2V0TGF0TG5nczpmdW5jdGlvbih0KXt0aGlzLl9ib3VuZHM9bmV3IFIsdGhpcy5fbGF0bG5ncz10aGlzLl9jb252ZXJ0TGF0TG5ncyh0KX0sX2RlZmF1bHRTaGFwZTpmdW5jdGlvbigpe3JldHVybiBwZSh0aGlzLl9sYXRsbmdzKT90aGlzLl9sYXRsbmdzOnRoaXMuX2xhdGxuZ3NbMF19LF9jb252ZXJ0TGF0TG5nczpmdW5jdGlvbih0KXtmb3IodmFyIGk9W10sZT1wZSh0KSxuPTAsbz10Lmxlbmd0aDtuPG87bisrKWU/KGlbbl09aih0W25dKSx0aGlzLl9ib3VuZHMuZXh0ZW5kKGlbbl0pKTppW25dPXRoaXMuX2NvbnZlcnRMYXRMbmdzKHRbbl0pO3JldHVybiBpfSxfcHJvamVjdDpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3RoaXMuX3JpbmdzPVtdLHRoaXMuX3Byb2plY3RMYXRsbmdzKHRoaXMuX2xhdGxuZ3MsdGhpcy5fcmluZ3MsdCksdGhpcy5fYm91bmRzLmlzVmFsaWQoKSYmdC5pc1ZhbGlkKCkmJih0aGlzLl9yYXdQeEJvdW5kcz10LHRoaXMuX3VwZGF0ZUJvdW5kcygpKX0sX3VwZGF0ZUJvdW5kczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NsaWNrVG9sZXJhbmNlKCksaT1uZXcgayh0LHQpO3RoaXMuX3B4Qm91bmRzPW5ldyBJKFt0aGlzLl9yYXdQeEJvdW5kcy5taW4uc3VidHJhY3QoaSksdGhpcy5fcmF3UHhCb3VuZHMubWF4LmFkZChpKV0pfSxfcHJvamVjdExhdGxuZ3M6ZnVuY3Rpb24odCxpLGUpe3ZhciBuLG8scz10WzBdaW5zdGFuY2VvZiBELHI9dC5sZW5ndGg7aWYocyl7Zm9yKG89W10sbj0wO248cjtuKyspb1tuXT10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRbbl0pLGUuZXh0ZW5kKG9bbl0pO2kucHVzaChvKX1lbHNlIGZvcihuPTA7bjxyO24rKyl0aGlzLl9wcm9qZWN0TGF0bG5ncyh0W25dLGksZSl9LF9jbGlwUG9pbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fcmVuZGVyZXIuX2JvdW5kcztpZih0aGlzLl9wYXJ0cz1bXSx0aGlzLl9weEJvdW5kcyYmdGhpcy5fcHhCb3VuZHMuaW50ZXJzZWN0cyh0KSlpZih0aGlzLm9wdGlvbnMubm9DbGlwKXRoaXMuX3BhcnRzPXRoaXMuX3JpbmdzO2Vsc2UgZm9yKHZhciBpLGUsbixvLHM9dGhpcy5fcGFydHMscj0wLGE9MCxoPXRoaXMuX3JpbmdzLmxlbmd0aDtyPGg7cisrKWZvcihpPTAsZT0obz10aGlzLl9yaW5nc1tyXSkubGVuZ3RoO2k8ZS0xO2krKykobj1sZShvW2ldLG9baSsxXSx0LGksITApKSYmKHNbYV09c1thXXx8W10sc1thXS5wdXNoKG5bMF0pLG5bMV09PT1vW2krMV0mJmkhPT1lLTJ8fChzW2FdLnB1c2goblsxXSksYSsrKSl9LF9zaW1wbGlmeVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9wYXJ0cyxpPXRoaXMub3B0aW9ucy5zbW9vdGhGYWN0b3IsZT0wLG49dC5sZW5ndGg7ZTxuO2UrKyl0W2VdPWhlKHRbZV0saSl9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJih0aGlzLl9jbGlwUG9pbnRzKCksdGhpcy5fc2ltcGxpZnlQb2ludHMoKSx0aGlzLl91cGRhdGVQYXRoKCkpfSxfdXBkYXRlUGF0aDpmdW5jdGlvbigpe3RoaXMuX3JlbmRlcmVyLl91cGRhdGVQb2x5KHRoaXMpfSxfY29udGFpbnNQb2ludDpmdW5jdGlvbih0LGkpe3ZhciBlLG4sbyxzLHIsYSxoPXRoaXMuX2NsaWNrVG9sZXJhbmNlKCk7aWYoIXRoaXMuX3B4Qm91bmRzfHwhdGhpcy5fcHhCb3VuZHMuY29udGFpbnModCkpcmV0dXJuITE7Zm9yKGU9MCxzPXRoaXMuX3BhcnRzLmxlbmd0aDtlPHM7ZSsrKWZvcihuPTAsbz0ocj0oYT10aGlzLl9wYXJ0c1tlXSkubGVuZ3RoKS0xO248cjtvPW4rKylpZigoaXx8MCE9PW4pJiZ1ZSh0LGFbb10sYVtuXSk8PWgpcmV0dXJuITA7cmV0dXJuITF9fSk7T2UuX2ZsYXQ9bWU7dmFyIFJlPU9lLmV4dGVuZCh7b3B0aW9uczp7ZmlsbDohMH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiF0aGlzLl9sYXRsbmdzLmxlbmd0aHx8IXRoaXMuX2xhdGxuZ3NbMF0ubGVuZ3RofSxnZXRDZW50ZXI6ZnVuY3Rpb24oKXtpZighdGhpcy5fbWFwKXRocm93IG5ldyBFcnJvcihcIk11c3QgYWRkIGxheWVyIHRvIG1hcCBiZWZvcmUgdXNpbmcgZ2V0Q2VudGVyKClcIik7dmFyIHQsaSxlLG4sbyxzLHIsYSxoLHU9dGhpcy5fcmluZ3NbMF0sbD11Lmxlbmd0aDtpZighbClyZXR1cm4gbnVsbDtmb3IodD1zPXI9YT0wLGk9bC0xO3Q8bDtpPXQrKyllPXVbdF0sbj11W2ldLG89ZS55Km4ueC1uLnkqZS54LHIrPShlLngrbi54KSpvLGErPShlLnkrbi55KSpvLHMrPTMqbztyZXR1cm4gaD0wPT09cz91WzBdOltyL3MsYS9zXSx0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGgpfSxfY29udmVydExhdExuZ3M6ZnVuY3Rpb24odCl7dmFyIGk9T2UucHJvdG90eXBlLl9jb252ZXJ0TGF0TG5ncy5jYWxsKHRoaXMsdCksZT1pLmxlbmd0aDtyZXR1cm4gMjw9ZSYmaVswXWluc3RhbmNlb2YgRCYmaVswXS5lcXVhbHMoaVtlLTFdKSYmaS5wb3AoKSxpfSxfc2V0TGF0TG5nczpmdW5jdGlvbih0KXtPZS5wcm90b3R5cGUuX3NldExhdExuZ3MuY2FsbCh0aGlzLHQpLHBlKHRoaXMuX2xhdGxuZ3MpJiYodGhpcy5fbGF0bG5ncz1bdGhpcy5fbGF0bG5nc10pfSxfZGVmYXVsdFNoYXBlOmZ1bmN0aW9uKCl7cmV0dXJuIHBlKHRoaXMuX2xhdGxuZ3NbMF0pP3RoaXMuX2xhdGxuZ3NbMF06dGhpcy5fbGF0bG5nc1swXVswXX0sX2NsaXBQb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9yZW5kZXJlci5fYm91bmRzLGk9dGhpcy5vcHRpb25zLndlaWdodCxlPW5ldyBrKGksaSksdD1uZXcgSSh0Lm1pbi5zdWJ0cmFjdChlKSx0Lm1heC5hZGQoZSkpO2lmKHRoaXMuX3BhcnRzPVtdLHRoaXMuX3B4Qm91bmRzJiZ0aGlzLl9weEJvdW5kcy5pbnRlcnNlY3RzKHQpKWlmKHRoaXMub3B0aW9ucy5ub0NsaXApdGhpcy5fcGFydHM9dGhpcy5fcmluZ3M7ZWxzZSBmb3IodmFyIG4sbz0wLHM9dGhpcy5fcmluZ3MubGVuZ3RoO288cztvKyspKG49Z2UodGhpcy5fcmluZ3Nbb10sdCwhMCkpLmxlbmd0aCYmdGhpcy5fcGFydHMucHVzaChuKX0sX3VwZGF0ZVBhdGg6ZnVuY3Rpb24oKXt0aGlzLl9yZW5kZXJlci5fdXBkYXRlUG9seSh0aGlzLCEwKX0sX2NvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGksZSxuLG8scyxyLGEsaCx1PSExO2lmKCF0aGlzLl9weEJvdW5kc3x8IXRoaXMuX3B4Qm91bmRzLmNvbnRhaW5zKHQpKXJldHVybiExO2ZvcihvPTAsYT10aGlzLl9wYXJ0cy5sZW5ndGg7bzxhO28rKylmb3Iocz0wLHI9KGg9KGk9dGhpcy5fcGFydHNbb10pLmxlbmd0aCktMTtzPGg7cj1zKyspZT1pW3NdLG49aVtyXSxlLnk+dC55IT1uLnk+dC55JiZ0Lng8KG4ueC1lLngpKih0LnktZS55KS8obi55LWUueSkrZS54JiYodT0hdSk7cmV0dXJuIHV8fE9lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsdCwhMCl9fSk7dmFyIE5lPUNlLmV4dGVuZCh7aW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe2ModGhpcyxpKSx0aGlzLl9sYXllcnM9e30sdCYmdGhpcy5hZGREYXRhKHQpfSxhZGREYXRhOmZ1bmN0aW9uKHQpe3ZhciBpLGUsbixvPWcodCk/dDp0LmZlYXR1cmVzO2lmKG8pe2ZvcihpPTAsZT1vLmxlbmd0aDtpPGU7aSsrKSgobj1vW2ldKS5nZW9tZXRyaWVzfHxuLmdlb21ldHJ5fHxuLmZlYXR1cmVzfHxuLmNvb3JkaW5hdGVzKSYmdGhpcy5hZGREYXRhKG4pO3JldHVybiB0aGlzfXZhciBzPXRoaXMub3B0aW9ucztpZihzLmZpbHRlciYmIXMuZmlsdGVyKHQpKXJldHVybiB0aGlzO3ZhciByPURlKHQscyk7cmV0dXJuIHI/KHIuZmVhdHVyZT1xZSh0KSxyLmRlZmF1bHRPcHRpb25zPXIub3B0aW9ucyx0aGlzLnJlc2V0U3R5bGUocikscy5vbkVhY2hGZWF0dXJlJiZzLm9uRWFjaEZlYXR1cmUodCxyKSx0aGlzLmFkZExheWVyKHIpKTp0aGlzfSxyZXNldFN0eWxlOmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10P3RoaXMuZWFjaExheWVyKHRoaXMucmVzZXRTdHlsZSx0aGlzKToodC5vcHRpb25zPWgoe30sdC5kZWZhdWx0T3B0aW9ucyksdGhpcy5fc2V0TGF5ZXJTdHlsZSh0LHRoaXMub3B0aW9ucy5zdHlsZSksdGhpcyl9LHNldFN0eWxlOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLmVhY2hMYXllcihmdW5jdGlvbih0KXt0aGlzLl9zZXRMYXllclN0eWxlKHQsaSl9LHRoaXMpfSxfc2V0TGF5ZXJTdHlsZTpmdW5jdGlvbih0LGkpe3Quc2V0U3R5bGUmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBpJiYoaT1pKHQuZmVhdHVyZSkpLHQuc2V0U3R5bGUoaSkpfX0pO2Z1bmN0aW9uIERlKHQsaSl7dmFyIGUsbixvLHMscj1cIkZlYXR1cmVcIj09PXQudHlwZT90Lmdlb21ldHJ5OnQsYT1yP3IuY29vcmRpbmF0ZXM6bnVsbCxoPVtdLHU9aSYmaS5wb2ludFRvTGF5ZXIsbD1pJiZpLmNvb3Jkc1RvTGF0TG5nfHxXZTtpZighYSYmIXIpcmV0dXJuIG51bGw7c3dpdGNoKHIudHlwZSl7Y2FzZVwiUG9pbnRcIjpyZXR1cm4gamUodSx0LGU9bChhKSxpKTtjYXNlXCJNdWx0aVBvaW50XCI6Zm9yKG89MCxzPWEubGVuZ3RoO288cztvKyspZT1sKGFbb10pLGgucHVzaChqZSh1LHQsZSxpKSk7cmV0dXJuIG5ldyBDZShoKTtjYXNlXCJMaW5lU3RyaW5nXCI6Y2FzZVwiTXVsdGlMaW5lU3RyaW5nXCI6cmV0dXJuIG49SGUoYSxcIkxpbmVTdHJpbmdcIj09PXIudHlwZT8wOjEsbCksbmV3IE9lKG4saSk7Y2FzZVwiUG9seWdvblwiOmNhc2VcIk11bHRpUG9seWdvblwiOnJldHVybiBuPUhlKGEsXCJQb2x5Z29uXCI9PT1yLnR5cGU/MToyLGwpLG5ldyBSZShuLGkpO2Nhc2VcIkdlb21ldHJ5Q29sbGVjdGlvblwiOmZvcihvPTAscz1yLmdlb21ldHJpZXMubGVuZ3RoO288cztvKyspe3ZhciBjPURlKHtnZW9tZXRyeTpyLmdlb21ldHJpZXNbb10sdHlwZTpcIkZlYXR1cmVcIixwcm9wZXJ0aWVzOnQucHJvcGVydGllc30saSk7YyYmaC5wdXNoKGMpfXJldHVybiBuZXcgQ2UoaCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdlb0pTT04gb2JqZWN0LlwiKX19ZnVuY3Rpb24gamUodCxpLGUsbil7cmV0dXJuIHQ/dChpLGUpOm5ldyBrZShlLG4mJm4ubWFya2Vyc0luaGVyaXRPcHRpb25zJiZuKX1mdW5jdGlvbiBXZSh0KXtyZXR1cm4gbmV3IEQodFsxXSx0WzBdLHRbMl0pfWZ1bmN0aW9uIEhlKHQsaSxlKXtmb3IodmFyIG4sbz1bXSxzPTAscj10Lmxlbmd0aDtzPHI7cysrKW49aT9IZSh0W3NdLGktMSxlKTooZXx8V2UpKHRbc10pLG8ucHVzaChuKTtyZXR1cm4gb31mdW5jdGlvbiBGZSh0LGkpe3JldHVybiBpPVwibnVtYmVyXCI9PXR5cGVvZiBpP2k6Nix2b2lkIDAhPT10LmFsdD9bcih0LmxuZyxpKSxyKHQubGF0LGkpLHIodC5hbHQsaSldOltyKHQubG5nLGkpLHIodC5sYXQsaSldfWZ1bmN0aW9uIFVlKHQsaSxlLG4pe2Zvcih2YXIgbz1bXSxzPTAscj10Lmxlbmd0aDtzPHI7cysrKW8ucHVzaChpP1VlKHRbc10saS0xLGUsbik6RmUodFtzXSxuKSk7cmV0dXJuIWkmJmUmJm8ucHVzaChvWzBdKSxvfWZ1bmN0aW9uIFZlKHQsaSl7cmV0dXJuIHQuZmVhdHVyZT9oKHt9LHQuZmVhdHVyZSx7Z2VvbWV0cnk6aX0pOnFlKGkpfWZ1bmN0aW9uIHFlKHQpe3JldHVyblwiRmVhdHVyZVwiPT09dC50eXBlfHxcIkZlYXR1cmVDb2xsZWN0aW9uXCI9PT10LnR5cGU/dDp7dHlwZTpcIkZlYXR1cmVcIixwcm9wZXJ0aWVzOnt9LGdlb21ldHJ5OnR9fXZhciBHZT17dG9HZW9KU09OOmZ1bmN0aW9uKHQpe3JldHVybiBWZSh0aGlzLHt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczpGZSh0aGlzLmdldExhdExuZygpLHQpfSl9fTtmdW5jdGlvbiBLZSh0LGkpe3JldHVybiBuZXcgTmUodCxpKX1rZS5pbmNsdWRlKEdlKSxJZS5pbmNsdWRlKEdlKSxBZS5pbmNsdWRlKEdlKSxPZS5pbmNsdWRlKHt0b0dlb0pTT046ZnVuY3Rpb24odCl7dmFyIGk9IXBlKHRoaXMuX2xhdGxuZ3MpO3JldHVybiBWZSh0aGlzLHt0eXBlOihpP1wiTXVsdGlcIjpcIlwiKStcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczpVZSh0aGlzLl9sYXRsbmdzLGk/MTowLCExLHQpfSl9fSksUmUuaW5jbHVkZSh7dG9HZW9KU09OOmZ1bmN0aW9uKHQpe3ZhciBpPSFwZSh0aGlzLl9sYXRsbmdzKSxlPWkmJiFwZSh0aGlzLl9sYXRsbmdzWzBdKSxuPVVlKHRoaXMuX2xhdGxuZ3MsZT8yOmk/MTowLCEwLHQpO3JldHVybiBpfHwobj1bbl0pLFZlKHRoaXMse3R5cGU6KGU/XCJNdWx0aVwiOlwiXCIpK1wiUG9seWdvblwiLGNvb3JkaW5hdGVzOm59KX19KSx6ZS5pbmNsdWRlKHt0b011bHRpUG9pbnQ6ZnVuY3Rpb24oaSl7dmFyIGU9W107cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uKHQpe2UucHVzaCh0LnRvR2VvSlNPTihpKS5nZW9tZXRyeS5jb29yZGluYXRlcyl9KSxWZSh0aGlzLHt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOmV9KX0sdG9HZW9KU09OOmZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMuZmVhdHVyZSYmdGhpcy5mZWF0dXJlLmdlb21ldHJ5JiZ0aGlzLmZlYXR1cmUuZ2VvbWV0cnkudHlwZTtpZihcIk11bHRpUG9pbnRcIj09PXQpcmV0dXJuIHRoaXMudG9NdWx0aVBvaW50KG4pO3ZhciBvPVwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LHM9W107cmV0dXJuIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uKHQpe3ZhciBpLGU7dC50b0dlb0pTT04mJihpPXQudG9HZW9KU09OKG4pLG8/cy5wdXNoKGkuZ2VvbWV0cnkpOlwiRmVhdHVyZUNvbGxlY3Rpb25cIj09PShlPXFlKGkpKS50eXBlP3MucHVzaC5hcHBseShzLGUuZmVhdHVyZXMpOnMucHVzaChlKSl9KSxvP1ZlKHRoaXMse2dlb21ldHJpZXM6cyx0eXBlOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCJ9KTp7dHlwZTpcIkZlYXR1cmVDb2xsZWN0aW9uXCIsZmVhdHVyZXM6c319fSk7dmFyIFllPUtlLFhlPU1lLmV4dGVuZCh7b3B0aW9uczp7b3BhY2l0eToxLGFsdDpcIlwiLGludGVyYWN0aXZlOiExLGNyb3NzT3JpZ2luOiExLGVycm9yT3ZlcmxheVVybDpcIlwiLHpJbmRleDoxLGNsYXNzTmFtZTpcIlwifSxpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSxlKXt0aGlzLl91cmw9dCx0aGlzLl9ib3VuZHM9TihpKSxjKHRoaXMsZSl9LG9uQWRkOmZ1bmN0aW9uKCl7dGhpcy5faW1hZ2V8fCh0aGlzLl9pbml0SW1hZ2UoKSx0aGlzLm9wdGlvbnMub3BhY2l0eTwxJiZ0aGlzLl91cGRhdGVPcGFjaXR5KCkpLHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSYmKGNpKHRoaXMuX2ltYWdlLFwibGVhZmxldC1pbnRlcmFjdGl2ZVwiKSx0aGlzLmFkZEludGVyYWN0aXZlVGFyZ2V0KHRoaXMuX2ltYWdlKSksdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpLHRoaXMuX3Jlc2V0KCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7cmkodGhpcy5faW1hZ2UpLHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSYmdGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl9pbWFnZSl9LHNldE9wYWNpdHk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5vcGFjaXR5PXQsdGhpcy5faW1hZ2UmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSx0aGlzfSxzZXRTdHlsZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5vcGFjaXR5JiZ0aGlzLnNldE9wYWNpdHkodC5vcGFjaXR5KSx0aGlzfSxicmluZ1RvRnJvbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiZoaSh0aGlzLl9pbWFnZSksdGhpc30sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiZ1aSh0aGlzLl9pbWFnZSksdGhpc30sc2V0VXJsOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl91cmw9dCx0aGlzLl9pbWFnZSYmKHRoaXMuX2ltYWdlLnNyYz10KSx0aGlzfSxzZXRCb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JvdW5kcz1OKHQpLHRoaXMuX21hcCYmdGhpcy5fcmVzZXQoKSx0aGlzfSxnZXRFdmVudHM6ZnVuY3Rpb24oKXt2YXIgdD17em9vbTp0aGlzLl9yZXNldCx2aWV3cmVzZXQ6dGhpcy5fcmVzZXR9O3JldHVybiB0aGlzLl96b29tQW5pbWF0ZWQmJih0Lnpvb21hbmltPXRoaXMuX2FuaW1hdGVab29tKSx0fSxzZXRaSW5kZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy56SW5kZXg9dCx0aGlzLl91cGRhdGVaSW5kZXgoKSx0aGlzfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm91bmRzfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ltYWdlfSxfaW5pdEltYWdlOmZ1bmN0aW9uKCl7dmFyIHQ9XCJJTUdcIj09PXRoaXMuX3VybC50YWdOYW1lLGk9dGhpcy5faW1hZ2U9dD90aGlzLl91cmw6c2koXCJpbWdcIik7Y2koaSxcImxlYWZsZXQtaW1hZ2UtbGF5ZXJcIiksdGhpcy5fem9vbUFuaW1hdGVkJiZjaShpLFwibGVhZmxldC16b29tLWFuaW1hdGVkXCIpLHRoaXMub3B0aW9ucy5jbGFzc05hbWUmJmNpKGksdGhpcy5vcHRpb25zLmNsYXNzTmFtZSksaS5vbnNlbGVjdHN0YXJ0PWEsaS5vbm1vdXNlbW92ZT1hLGkub25sb2FkPXAodGhpcy5maXJlLHRoaXMsXCJsb2FkXCIpLGkub25lcnJvcj1wKHRoaXMuX292ZXJsYXlPbkVycm9yLHRoaXMsXCJlcnJvclwiKSwhdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luJiZcIlwiIT09dGhpcy5vcHRpb25zLmNyb3NzT3JpZ2lufHwoaS5jcm9zc09yaWdpbj0hMD09PXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbj9cIlwiOnRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksdGhpcy5vcHRpb25zLnpJbmRleCYmdGhpcy5fdXBkYXRlWkluZGV4KCksdD90aGlzLl91cmw9aS5zcmM6KGkuc3JjPXRoaXMuX3VybCxpLmFsdD10aGlzLm9wdGlvbnMuYWx0KX0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcC5nZXRab29tU2NhbGUodC56b29tKSxlPXRoaXMuX21hcC5fbGF0TG5nQm91bmRzVG9OZXdMYXllckJvdW5kcyh0aGlzLl9ib3VuZHMsdC56b29tLHQuY2VudGVyKS5taW47Z2kodGhpcy5faW1hZ2UsZSxpKX0sX3Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5faW1hZ2UsaT1uZXcgSSh0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXROb3J0aFdlc3QoKSksdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCkpKSxlPWkuZ2V0U2l6ZSgpO3ZpKHQsaS5taW4pLHQuc3R5bGUud2lkdGg9ZS54K1wicHhcIix0LnN0eWxlLmhlaWdodD1lLnkrXCJweFwifSxfdXBkYXRlT3BhY2l0eTpmdW5jdGlvbigpe21pKHRoaXMuX2ltYWdlLHRoaXMub3B0aW9ucy5vcGFjaXR5KX0sX3VwZGF0ZVpJbmRleDpmdW5jdGlvbigpe3RoaXMuX2ltYWdlJiZ2b2lkIDAhPT10aGlzLm9wdGlvbnMuekluZGV4JiZudWxsIT09dGhpcy5vcHRpb25zLnpJbmRleCYmKHRoaXMuX2ltYWdlLnN0eWxlLnpJbmRleD10aGlzLm9wdGlvbnMuekluZGV4KX0sX292ZXJsYXlPbkVycm9yOmZ1bmN0aW9uKCl7dGhpcy5maXJlKFwiZXJyb3JcIik7dmFyIHQ9dGhpcy5vcHRpb25zLmVycm9yT3ZlcmxheVVybDt0JiZ0aGlzLl91cmwhPT10JiYodGhpcy5fdXJsPXQsdGhpcy5faW1hZ2Uuc3JjPXQpfX0pLEplPVhlLmV4dGVuZCh7b3B0aW9uczp7YXV0b3BsYXk6ITAsbG9vcDohMCxrZWVwQXNwZWN0UmF0aW86ITAsbXV0ZWQ6ITF9LF9pbml0SW1hZ2U6ZnVuY3Rpb24oKXt2YXIgdD1cIlZJREVPXCI9PT10aGlzLl91cmwudGFnTmFtZSxpPXRoaXMuX2ltYWdlPXQ/dGhpcy5fdXJsOnNpKFwidmlkZW9cIik7aWYoY2koaSxcImxlYWZsZXQtaW1hZ2UtbGF5ZXJcIiksdGhpcy5fem9vbUFuaW1hdGVkJiZjaShpLFwibGVhZmxldC16b29tLWFuaW1hdGVkXCIpLHRoaXMub3B0aW9ucy5jbGFzc05hbWUmJmNpKGksdGhpcy5vcHRpb25zLmNsYXNzTmFtZSksaS5vbnNlbGVjdHN0YXJ0PWEsaS5vbm1vdXNlbW92ZT1hLGkub25sb2FkZWRkYXRhPXAodGhpcy5maXJlLHRoaXMsXCJsb2FkXCIpLHQpe2Zvcih2YXIgZT1pLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic291cmNlXCIpLG49W10sbz0wO288ZS5sZW5ndGg7bysrKW4ucHVzaChlW29dLnNyYyk7dGhpcy5fdXJsPTA8ZS5sZW5ndGg/bjpbaS5zcmNdfWVsc2V7Zyh0aGlzLl91cmwpfHwodGhpcy5fdXJsPVt0aGlzLl91cmxdKSwhdGhpcy5vcHRpb25zLmtlZXBBc3BlY3RSYXRpbyYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGkuc3R5bGUsXCJvYmplY3RGaXRcIikmJihpLnN0eWxlLm9iamVjdEZpdD1cImZpbGxcIiksaS5hdXRvcGxheT0hIXRoaXMub3B0aW9ucy5hdXRvcGxheSxpLmxvb3A9ISF0aGlzLm9wdGlvbnMubG9vcCxpLm11dGVkPSEhdGhpcy5vcHRpb25zLm11dGVkO2Zvcih2YXIgcz0wO3M8dGhpcy5fdXJsLmxlbmd0aDtzKyspe3ZhciByPXNpKFwic291cmNlXCIpO3Iuc3JjPXRoaXMuX3VybFtzXSxpLmFwcGVuZENoaWxkKHIpfX19fSk7dmFyICRlPVhlLmV4dGVuZCh7X2luaXRJbWFnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2ltYWdlPXRoaXMuX3VybDtjaSh0LFwibGVhZmxldC1pbWFnZS1sYXllclwiKSx0aGlzLl96b29tQW5pbWF0ZWQmJmNpKHQsXCJsZWFmbGV0LXpvb20tYW5pbWF0ZWRcIiksdGhpcy5vcHRpb25zLmNsYXNzTmFtZSYmY2kodCx0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSx0Lm9uc2VsZWN0c3RhcnQ9YSx0Lm9ubW91c2Vtb3ZlPWF9fSk7dmFyIFFlPU1lLmV4dGVuZCh7b3B0aW9uczp7b2Zmc2V0OlswLDddLGNsYXNzTmFtZTpcIlwiLHBhbmU6XCJwb3B1cFBhbmVcIn0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe2ModGhpcyx0KSx0aGlzLl9zb3VyY2U9aX0sb25BZGQ6ZnVuY3Rpb24odCl7dGhpcy5fem9vbUFuaW1hdGVkPXQuX3pvb21BbmltYXRlZCx0aGlzLl9jb250YWluZXJ8fHRoaXMuX2luaXRMYXlvdXQoKSx0Ll9mYWRlQW5pbWF0ZWQmJm1pKHRoaXMuX2NvbnRhaW5lciwwKSxjbGVhclRpbWVvdXQodGhpcy5fcmVtb3ZlVGltZW91dCksdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKSx0aGlzLnVwZGF0ZSgpLHQuX2ZhZGVBbmltYXRlZCYmbWkodGhpcy5fY29udGFpbmVyLDEpLHRoaXMuYnJpbmdUb0Zyb250KCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3QuX2ZhZGVBbmltYXRlZD8obWkodGhpcy5fY29udGFpbmVyLDApLHRoaXMuX3JlbW92ZVRpbWVvdXQ9c2V0VGltZW91dChwKHJpLHZvaWQgMCx0aGlzLl9jb250YWluZXIpLDIwMCkpOnJpKHRoaXMuX2NvbnRhaW5lcil9LGdldExhdExuZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sYXRsbmd9LHNldExhdExuZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbGF0bG5nPWoodCksdGhpcy5fbWFwJiYodGhpcy5fdXBkYXRlUG9zaXRpb24oKSx0aGlzLl9hZGp1c3RQYW4oKSksdGhpc30sZ2V0Q29udGVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250ZW50fSxzZXRDb250ZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9jb250ZW50PXQsdGhpcy51cGRhdGUoKSx0aGlzfSxnZXRFbGVtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5lcn0sdXBkYXRlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwJiYodGhpcy5fY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHk9XCJoaWRkZW5cIix0aGlzLl91cGRhdGVDb250ZW50KCksdGhpcy5fdXBkYXRlTGF5b3V0KCksdGhpcy5fdXBkYXRlUG9zaXRpb24oKSx0aGlzLl9jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eT1cIlwiLHRoaXMuX2FkanVzdFBhbigpKX0sZ2V0RXZlbnRzOmZ1bmN0aW9uKCl7dmFyIHQ9e3pvb206dGhpcy5fdXBkYXRlUG9zaXRpb24sdmlld3Jlc2V0OnRoaXMuX3VwZGF0ZVBvc2l0aW9ufTtyZXR1cm4gdGhpcy5fem9vbUFuaW1hdGVkJiYodC56b29tYW5pbT10aGlzLl9hbmltYXRlWm9vbSksdH0saXNPcGVuOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl9tYXAmJnRoaXMuX21hcC5oYXNMYXllcih0aGlzKX0sYnJpbmdUb0Zyb250OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hcCYmaGkodGhpcy5fY29udGFpbmVyKSx0aGlzfSxicmluZ1RvQmFjazpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJnVpKHRoaXMuX2NvbnRhaW5lciksdGhpc30sX3ByZXBhcmVPcGVuOmZ1bmN0aW9uKHQsaSxlKXtpZihpIGluc3RhbmNlb2YgTWV8fChlPWksaT10KSxpIGluc3RhbmNlb2YgQ2UpZm9yKHZhciBuIGluIHQuX2xheWVycyl7aT10Ll9sYXllcnNbbl07YnJlYWt9aWYoIWUpaWYoaS5nZXRDZW50ZXIpZT1pLmdldENlbnRlcigpO2Vsc2V7aWYoIWkuZ2V0TGF0TG5nKXRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgc291cmNlIGxheWVyIExhdExuZy5cIik7ZT1pLmdldExhdExuZygpfXJldHVybiB0aGlzLl9zb3VyY2U9aSx0aGlzLnVwZGF0ZSgpLGV9LF91cGRhdGVDb250ZW50OmZ1bmN0aW9uKCl7aWYodGhpcy5fY29udGVudCl7dmFyIHQ9dGhpcy5fY29udGVudE5vZGUsaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9jb250ZW50P3RoaXMuX2NvbnRlbnQodGhpcy5fc291cmNlfHx0aGlzKTp0aGlzLl9jb250ZW50O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpKXQuaW5uZXJIVE1MPWk7ZWxzZXtmb3IoO3QuaGFzQ2hpbGROb2RlcygpOyl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCk7dC5hcHBlbmRDaGlsZChpKX10aGlzLmZpcmUoXCJjb250ZW50dXBkYXRlXCIpfX0sX3VwZGF0ZVBvc2l0aW9uOmZ1bmN0aW9uKCl7dmFyIHQsaSxlLG4sbzt0aGlzLl9tYXAmJih0PXRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxpPUEodGhpcy5vcHRpb25zLm9mZnNldCksZT10aGlzLl9nZXRBbmNob3IoKSx0aGlzLl96b29tQW5pbWF0ZWQ/dmkodGhpcy5fY29udGFpbmVyLHQuYWRkKGUpKTppPWkuYWRkKHQpLmFkZChlKSxuPXRoaXMuX2NvbnRhaW5lckJvdHRvbT0taS55LG89dGhpcy5fY29udGFpbmVyTGVmdD0tTWF0aC5yb3VuZCh0aGlzLl9jb250YWluZXJXaWR0aC8yKStpLngsdGhpcy5fY29udGFpbmVyLnN0eWxlLmJvdHRvbT1uK1wicHhcIix0aGlzLl9jb250YWluZXIuc3R5bGUubGVmdD1vK1wicHhcIil9LF9nZXRBbmNob3I6ZnVuY3Rpb24oKXtyZXR1cm5bMCwwXX19KSx0bj1RZS5leHRlbmQoe29wdGlvbnM6e21heFdpZHRoOjMwMCxtaW5XaWR0aDo1MCxtYXhIZWlnaHQ6bnVsbCxhdXRvUGFuOiEwLGF1dG9QYW5QYWRkaW5nVG9wTGVmdDpudWxsLGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6bnVsbCxhdXRvUGFuUGFkZGluZzpbNSw1XSxrZWVwSW5WaWV3OiExLGNsb3NlQnV0dG9uOiEwLGF1dG9DbG9zZTohMCxjbG9zZU9uRXNjYXBlS2V5OiEwLGNsYXNzTmFtZTpcIlwifSxvcGVuT246ZnVuY3Rpb24odCl7cmV0dXJuIHQub3BlblBvcHVwKHRoaXMpLHRoaXN9LG9uQWRkOmZ1bmN0aW9uKHQpe1FlLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsdCksdC5maXJlKFwicG9wdXBvcGVuXCIse3BvcHVwOnRoaXN9KSx0aGlzLl9zb3VyY2UmJih0aGlzLl9zb3VyY2UuZmlyZShcInBvcHVwb3BlblwiLHtwb3B1cDp0aGlzfSwhMCksdGhpcy5fc291cmNlIGluc3RhbmNlb2YgQmV8fHRoaXMuX3NvdXJjZS5vbihcInByZWNsaWNrXCIsQWkpKX0sb25SZW1vdmU6ZnVuY3Rpb24odCl7UWUucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcyx0KSx0LmZpcmUoXCJwb3B1cGNsb3NlXCIse3BvcHVwOnRoaXN9KSx0aGlzLl9zb3VyY2UmJih0aGlzLl9zb3VyY2UuZmlyZShcInBvcHVwY2xvc2VcIix7cG9wdXA6dGhpc30sITApLHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEJlfHx0aGlzLl9zb3VyY2Uub2ZmKFwicHJlY2xpY2tcIixBaSkpfSxnZXRFdmVudHM6ZnVuY3Rpb24oKXt2YXIgdD1RZS5wcm90b3R5cGUuZ2V0RXZlbnRzLmNhbGwodGhpcyk7cmV0dXJuKHZvaWQgMCE9PXRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2s/dGhpcy5vcHRpb25zLmNsb3NlT25DbGljazp0aGlzLl9tYXAub3B0aW9ucy5jbG9zZVBvcHVwT25DbGljaykmJih0LnByZWNsaWNrPXRoaXMuX2Nsb3NlKSx0aGlzLm9wdGlvbnMua2VlcEluVmlldyYmKHQubW92ZWVuZD10aGlzLl9hZGp1c3RQYW4pLHR9LF9jbG9zZTpmdW5jdGlvbigpe3RoaXMuX21hcCYmdGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyl9LF9pbml0TGF5b3V0OmZ1bmN0aW9uKCl7dmFyIHQsaT1cImxlYWZsZXQtcG9wdXBcIixlPXRoaXMuX2NvbnRhaW5lcj1zaShcImRpdlwiLGkrXCIgXCIrKHRoaXMub3B0aW9ucy5jbGFzc05hbWV8fFwiXCIpK1wiIGxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSxuPXRoaXMuX3dyYXBwZXI9c2koXCJkaXZcIixpK1wiLWNvbnRlbnQtd3JhcHBlclwiLGUpO3RoaXMuX2NvbnRlbnROb2RlPXNpKFwiZGl2XCIsaStcIi1jb250ZW50XCIsbiksT2koZSksSWkodGhpcy5fY29udGVudE5vZGUpLHppKGUsXCJjb250ZXh0bWVudVwiLEFpKSx0aGlzLl90aXBDb250YWluZXI9c2koXCJkaXZcIixpK1wiLXRpcC1jb250YWluZXJcIixlKSx0aGlzLl90aXA9c2koXCJkaXZcIixpK1wiLXRpcFwiLHRoaXMuX3RpcENvbnRhaW5lciksdGhpcy5vcHRpb25zLmNsb3NlQnV0dG9uJiYoKHQ9dGhpcy5fY2xvc2VCdXR0b249c2koXCJhXCIsaStcIi1jbG9zZS1idXR0b25cIixlKSkuaHJlZj1cIiNjbG9zZVwiLHQuaW5uZXJIVE1MPVwiJiMyMTU7XCIsemkodCxcImNsaWNrXCIsdGhpcy5fb25DbG9zZUJ1dHRvbkNsaWNrLHRoaXMpKX0sX3VwZGF0ZUxheW91dDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NvbnRlbnROb2RlLGk9dC5zdHlsZTtpLndpZHRoPVwiXCIsaS53aGl0ZVNwYWNlPVwibm93cmFwXCI7dmFyIGU9dC5vZmZzZXRXaWR0aCxlPU1hdGgubWluKGUsdGhpcy5vcHRpb25zLm1heFdpZHRoKTtlPU1hdGgubWF4KGUsdGhpcy5vcHRpb25zLm1pbldpZHRoKSxpLndpZHRoPWUrMStcInB4XCIsaS53aGl0ZVNwYWNlPVwiXCIsaS5oZWlnaHQ9XCJcIjt2YXIgbj10Lm9mZnNldEhlaWdodCxvPXRoaXMub3B0aW9ucy5tYXhIZWlnaHQscz1cImxlYWZsZXQtcG9wdXAtc2Nyb2xsZWRcIjtvJiZvPG4/KGkuaGVpZ2h0PW8rXCJweFwiLGNpKHQscykpOl9pKHQscyksdGhpcy5fY29udGFpbmVyV2lkdGg9dGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRofSxfYW5pbWF0ZVpvb206ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQodGhpcy5fbGF0bG5nLHQuem9vbSx0LmNlbnRlciksZT10aGlzLl9nZXRBbmNob3IoKTt2aSh0aGlzLl9jb250YWluZXIsaS5hZGQoZSkpfSxfYWRqdXN0UGFuOmZ1bmN0aW9uKCl7dmFyIHQsaSxlLG4sbyxzLHIsYSxoLHUsbCxjO3RoaXMub3B0aW9ucy5hdXRvUGFuJiYodGhpcy5fbWFwLl9wYW5BbmltJiZ0aGlzLl9tYXAuX3BhbkFuaW0uc3RvcCgpLHQ9dGhpcy5fbWFwLGk9cGFyc2VJbnQob2kodGhpcy5fY29udGFpbmVyLFwibWFyZ2luQm90dG9tXCIpLDEwKXx8MCxlPXRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQraSxuPXRoaXMuX2NvbnRhaW5lcldpZHRoLChvPW5ldyBrKHRoaXMuX2NvbnRhaW5lckxlZnQsLWUtdGhpcy5fY29udGFpbmVyQm90dG9tKSkuX2FkZCh5aSh0aGlzLl9jb250YWluZXIpKSxzPXQubGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQobykscj1BKHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZyksYT1BKHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnR8fHIpLGg9QSh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodHx8ciksdT10LmdldFNpemUoKSxjPWw9MCxzLngrbitoLng+dS54JiYobD1zLngrbi11LngraC54KSxzLngtbC1hLng8MCYmKGw9cy54LWEueCkscy55K2UraC55PnUueSYmKGM9cy55K2UtdS55K2gueSkscy55LWMtYS55PDAmJihjPXMueS1hLnkpLChsfHxjKSYmdC5maXJlKFwiYXV0b3BhbnN0YXJ0XCIpLnBhbkJ5KFtsLGNdKSl9LF9vbkNsb3NlQnV0dG9uQ2xpY2s6ZnVuY3Rpb24odCl7dGhpcy5fY2xvc2UoKSxOaSh0KX0sX2dldEFuY2hvcjpmdW5jdGlvbigpe3JldHVybiBBKHRoaXMuX3NvdXJjZSYmdGhpcy5fc291cmNlLl9nZXRQb3B1cEFuY2hvcj90aGlzLl9zb3VyY2UuX2dldFBvcHVwQW5jaG9yKCk6WzAsMF0pfX0pO0tpLm1lcmdlT3B0aW9ucyh7Y2xvc2VQb3B1cE9uQ2xpY2s6ITB9KSxLaS5pbmNsdWRlKHtvcGVuUG9wdXA6ZnVuY3Rpb24odCxpLGUpe3JldHVybiB0IGluc3RhbmNlb2YgdG58fCh0PW5ldyB0bihlKS5zZXRDb250ZW50KHQpKSxpJiZ0LnNldExhdExuZyhpKSx0aGlzLmhhc0xheWVyKHQpP3RoaXM6KHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5vcHRpb25zLmF1dG9DbG9zZSYmdGhpcy5jbG9zZVBvcHVwKCksdGhpcy5fcG9wdXA9dCx0aGlzLmFkZExheWVyKHQpKX0sY2xvc2VQb3B1cDpmdW5jdGlvbih0KXtyZXR1cm4gdCYmdCE9PXRoaXMuX3BvcHVwfHwodD10aGlzLl9wb3B1cCx0aGlzLl9wb3B1cD1udWxsKSx0JiZ0aGlzLnJlbW92ZUxheWVyKHQpLHRoaXN9fSksTWUuaW5jbHVkZSh7YmluZFBvcHVwOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0bj8oYyh0LGkpLCh0aGlzLl9wb3B1cD10KS5fc291cmNlPXRoaXMpOih0aGlzLl9wb3B1cCYmIWl8fCh0aGlzLl9wb3B1cD1uZXcgdG4oaSx0aGlzKSksdGhpcy5fcG9wdXAuc2V0Q29udGVudCh0KSksdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkfHwodGhpcy5vbih7Y2xpY2s6dGhpcy5fb3BlblBvcHVwLGtleXByZXNzOnRoaXMuX29uS2V5UHJlc3MscmVtb3ZlOnRoaXMuY2xvc2VQb3B1cCxtb3ZlOnRoaXMuX21vdmVQb3B1cH0pLHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZD0hMCksdGhpc30sdW5iaW5kUG9wdXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcG9wdXAmJih0aGlzLm9mZih7Y2xpY2s6dGhpcy5fb3BlblBvcHVwLGtleXByZXNzOnRoaXMuX29uS2V5UHJlc3MscmVtb3ZlOnRoaXMuY2xvc2VQb3B1cCxtb3ZlOnRoaXMuX21vdmVQb3B1cH0pLHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZD0hMSx0aGlzLl9wb3B1cD1udWxsKSx0aGlzfSxvcGVuUG9wdXA6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdGhpcy5fcG9wdXAmJnRoaXMuX21hcCYmKGk9dGhpcy5fcG9wdXAuX3ByZXBhcmVPcGVuKHRoaXMsdCxpKSx0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwLGkpKSx0aGlzfSxjbG9zZVBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5fY2xvc2UoKSx0aGlzfSx0b2dnbGVQb3B1cDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcG9wdXAmJih0aGlzLl9wb3B1cC5fbWFwP3RoaXMuY2xvc2VQb3B1cCgpOnRoaXMub3BlblBvcHVwKHQpKSx0aGlzfSxpc1BvcHVwT3BlbjpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5fcG9wdXAmJnRoaXMuX3BvcHVwLmlzT3BlbigpfSxzZXRQb3B1cENvbnRlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BvcHVwJiZ0aGlzLl9wb3B1cC5zZXRDb250ZW50KHQpLHRoaXN9LGdldFBvcHVwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BvcHVwfSxfb3BlblBvcHVwOmZ1bmN0aW9uKHQpe3ZhciBpPXQubGF5ZXJ8fHQudGFyZ2V0O3RoaXMuX3BvcHVwJiZ0aGlzLl9tYXAmJihOaSh0KSxpIGluc3RhbmNlb2YgQmU/dGhpcy5vcGVuUG9wdXAodC5sYXllcnx8dC50YXJnZXQsdC5sYXRsbmcpOnRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkmJnRoaXMuX3BvcHVwLl9zb3VyY2U9PT1pP3RoaXMuY2xvc2VQb3B1cCgpOnRoaXMub3BlblBvcHVwKGksdC5sYXRsbmcpKX0sX21vdmVQb3B1cDpmdW5jdGlvbih0KXt0aGlzLl9wb3B1cC5zZXRMYXRMbmcodC5sYXRsbmcpfSxfb25LZXlQcmVzczpmdW5jdGlvbih0KXsxMz09PXQub3JpZ2luYWxFdmVudC5rZXlDb2RlJiZ0aGlzLl9vcGVuUG9wdXAodCl9fSk7dmFyIGVuPVFlLmV4dGVuZCh7b3B0aW9uczp7cGFuZTpcInRvb2x0aXBQYW5lXCIsb2Zmc2V0OlswLDBdLGRpcmVjdGlvbjpcImF1dG9cIixwZXJtYW5lbnQ6ITEsc3RpY2t5OiExLGludGVyYWN0aXZlOiExLG9wYWNpdHk6Ljl9LG9uQWRkOmZ1bmN0aW9uKHQpe1FlLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsdCksdGhpcy5zZXRPcGFjaXR5KHRoaXMub3B0aW9ucy5vcGFjaXR5KSx0LmZpcmUoXCJ0b29sdGlwb3BlblwiLHt0b29sdGlwOnRoaXN9KSx0aGlzLl9zb3VyY2UmJnRoaXMuX3NvdXJjZS5maXJlKFwidG9vbHRpcG9wZW5cIix7dG9vbHRpcDp0aGlzfSwhMCl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe1FlLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsdCksdC5maXJlKFwidG9vbHRpcGNsb3NlXCIse3Rvb2x0aXA6dGhpc30pLHRoaXMuX3NvdXJjZSYmdGhpcy5fc291cmNlLmZpcmUoXCJ0b29sdGlwY2xvc2VcIix7dG9vbHRpcDp0aGlzfSwhMCl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PVFlLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gYnQmJiF0aGlzLm9wdGlvbnMucGVybWFuZW50JiYodC5wcmVjbGljaz10aGlzLl9jbG9zZSksdH0sX2Nsb3NlOmZ1bmN0aW9uKCl7dGhpcy5fbWFwJiZ0aGlzLl9tYXAuY2xvc2VUb29sdGlwKHRoaXMpfSxfaW5pdExheW91dDpmdW5jdGlvbigpe3ZhciB0PVwibGVhZmxldC10b29sdGlwIFwiKyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lfHxcIlwiKStcIiBsZWFmbGV0LXpvb20tXCIrKHRoaXMuX3pvb21BbmltYXRlZD9cImFuaW1hdGVkXCI6XCJoaWRlXCIpO3RoaXMuX2NvbnRlbnROb2RlPXRoaXMuX2NvbnRhaW5lcj1zaShcImRpdlwiLHQpfSxfdXBkYXRlTGF5b3V0OmZ1bmN0aW9uKCl7fSxfYWRqdXN0UGFuOmZ1bmN0aW9uKCl7fSxfc2V0UG9zaXRpb246ZnVuY3Rpb24odCl7dmFyIGksZT10aGlzLl9tYXAsbj10aGlzLl9jb250YWluZXIsbz1lLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQoZS5nZXRDZW50ZXIoKSkscz1lLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHQpLHI9dGhpcy5vcHRpb25zLmRpcmVjdGlvbixhPW4ub2Zmc2V0V2lkdGgsaD1uLm9mZnNldEhlaWdodCx1PUEodGhpcy5vcHRpb25zLm9mZnNldCksbD10aGlzLl9nZXRBbmNob3IoKSxjPVwidG9wXCI9PT1yPyhpPWEvMixoKTpcImJvdHRvbVwiPT09cj8oaT1hLzIsMCk6KGk9XCJjZW50ZXJcIj09PXI/YS8yOlwicmlnaHRcIj09PXI/MDpcImxlZnRcIj09PXI/YTpzLng8by54PyhyPVwicmlnaHRcIiwwKToocj1cImxlZnRcIixhKzIqKHUueCtsLngpKSxoLzIpO3Q9dC5zdWJ0cmFjdChBKGksYywhMCkpLmFkZCh1KS5hZGQobCksX2kobixcImxlYWZsZXQtdG9vbHRpcC1yaWdodFwiKSxfaShuLFwibGVhZmxldC10b29sdGlwLWxlZnRcIiksX2kobixcImxlYWZsZXQtdG9vbHRpcC10b3BcIiksX2kobixcImxlYWZsZXQtdG9vbHRpcC1ib3R0b21cIiksY2kobixcImxlYWZsZXQtdG9vbHRpcC1cIityKSx2aShuLHQpfSxfdXBkYXRlUG9zaXRpb246ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyk7dGhpcy5fc2V0UG9zaXRpb24odCl9LHNldE9wYWNpdHk6ZnVuY3Rpb24odCl7dGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl9jb250YWluZXImJm1pKHRoaXMuX2NvbnRhaW5lcix0KX0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZyx0Lnpvb20sdC5jZW50ZXIpO3RoaXMuX3NldFBvc2l0aW9uKGkpfSxfZ2V0QW5jaG9yOmZ1bmN0aW9uKCl7cmV0dXJuIEEodGhpcy5fc291cmNlJiZ0aGlzLl9zb3VyY2UuX2dldFRvb2x0aXBBbmNob3ImJiF0aGlzLm9wdGlvbnMuc3RpY2t5P3RoaXMuX3NvdXJjZS5fZ2V0VG9vbHRpcEFuY2hvcigpOlswLDBdKX19KTtLaS5pbmNsdWRlKHtvcGVuVG9vbHRpcDpmdW5jdGlvbih0LGksZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBlbnx8KHQ9bmV3IGVuKGUpLnNldENvbnRlbnQodCkpLGkmJnQuc2V0TGF0TG5nKGkpLHRoaXMuaGFzTGF5ZXIodCk/dGhpczp0aGlzLmFkZExheWVyKHQpfSxjbG9zZVRvb2x0aXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMucmVtb3ZlTGF5ZXIodCksdGhpc319KSxNZS5pbmNsdWRlKHtiaW5kVG9vbHRpcDpmdW5jdGlvbih0LGkpe3JldHVybiB0IGluc3RhbmNlb2YgZW4/KGModCxpKSwodGhpcy5fdG9vbHRpcD10KS5fc291cmNlPXRoaXMpOih0aGlzLl90b29sdGlwJiYhaXx8KHRoaXMuX3Rvb2x0aXA9bmV3IGVuKGksdGhpcykpLHRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudCh0KSksdGhpcy5faW5pdFRvb2x0aXBJbnRlcmFjdGlvbnMoKSx0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50JiZ0aGlzLl9tYXAmJnRoaXMuX21hcC5oYXNMYXllcih0aGlzKSYmdGhpcy5vcGVuVG9vbHRpcCgpLHRoaXN9LHVuYmluZFRvb2x0aXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmKHRoaXMuX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zKCEwKSx0aGlzLmNsb3NlVG9vbHRpcCgpLHRoaXMuX3Rvb2x0aXA9bnVsbCksdGhpc30sX2luaXRUb29sdGlwSW50ZXJhY3Rpb25zOmZ1bmN0aW9uKHQpe3ZhciBpLGU7IXQmJnRoaXMuX3Rvb2x0aXBIYW5kbGVyc0FkZGVkfHwoaT10P1wib2ZmXCI6XCJvblwiLGU9e3JlbW92ZTp0aGlzLmNsb3NlVG9vbHRpcCxtb3ZlOnRoaXMuX21vdmVUb29sdGlwfSx0aGlzLl90b29sdGlwLm9wdGlvbnMucGVybWFuZW50P2UuYWRkPXRoaXMuX29wZW5Ub29sdGlwOihlLm1vdXNlb3Zlcj10aGlzLl9vcGVuVG9vbHRpcCxlLm1vdXNlb3V0PXRoaXMuY2xvc2VUb29sdGlwLHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5zdGlja3kmJihlLm1vdXNlbW92ZT10aGlzLl9tb3ZlVG9vbHRpcCksYnQmJihlLmNsaWNrPXRoaXMuX29wZW5Ub29sdGlwKSksdGhpc1tpXShlKSx0aGlzLl90b29sdGlwSGFuZGxlcnNBZGRlZD0hdCl9LG9wZW5Ub29sdGlwOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJnRoaXMuX21hcCYmKGk9dGhpcy5fdG9vbHRpcC5fcHJlcGFyZU9wZW4odGhpcyx0LGkpLHRoaXMuX21hcC5vcGVuVG9vbHRpcCh0aGlzLl90b29sdGlwLGkpLHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSYmdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyJiYoY2kodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLFwibGVhZmxldC1jbGlja2FibGVcIiksdGhpcy5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpKSksdGhpc30sY2xvc2VUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJih0aGlzLl90b29sdGlwLl9jbG9zZSgpLHRoaXMuX3Rvb2x0aXAub3B0aW9ucy5pbnRlcmFjdGl2ZSYmdGhpcy5fdG9vbHRpcC5fY29udGFpbmVyJiYoX2kodGhpcy5fdG9vbHRpcC5fY29udGFpbmVyLFwibGVhZmxldC1jbGlja2FibGVcIiksdGhpcy5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0aGlzLl90b29sdGlwLl9jb250YWluZXIpKSksdGhpc30sdG9nZ2xlVG9vbHRpcDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fdG9vbHRpcCYmKHRoaXMuX3Rvb2x0aXAuX21hcD90aGlzLmNsb3NlVG9vbHRpcCgpOnRoaXMub3BlblRvb2x0aXAodCkpLHRoaXN9LGlzVG9vbHRpcE9wZW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdG9vbHRpcC5pc09wZW4oKX0sc2V0VG9vbHRpcENvbnRlbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXAmJnRoaXMuX3Rvb2x0aXAuc2V0Q29udGVudCh0KSx0aGlzfSxnZXRUb29sdGlwOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Rvb2x0aXB9LF9vcGVuVG9vbHRpcDpmdW5jdGlvbih0KXt2YXIgaT10LmxheWVyfHx0LnRhcmdldDt0aGlzLl90b29sdGlwJiZ0aGlzLl9tYXAmJnRoaXMub3BlblRvb2x0aXAoaSx0aGlzLl90b29sdGlwLm9wdGlvbnMuc3RpY2t5P3QubGF0bG5nOnZvaWQgMCl9LF9tb3ZlVG9vbHRpcDpmdW5jdGlvbih0KXt2YXIgaSxlLG49dC5sYXRsbmc7dGhpcy5fdG9vbHRpcC5vcHRpb25zLnN0aWNreSYmdC5vcmlnaW5hbEV2ZW50JiYoaT10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodC5vcmlnaW5hbEV2ZW50KSxlPXRoaXMuX21hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChpKSxuPXRoaXMuX21hcC5sYXllclBvaW50VG9MYXRMbmcoZSkpLHRoaXMuX3Rvb2x0aXAuc2V0TGF0TG5nKG4pfX0pO3ZhciBubj1TZS5leHRlbmQoe29wdGlvbnM6e2ljb25TaXplOlsxMiwxMl0saHRtbDohMSxiZ1BvczpudWxsLGNsYXNzTmFtZTpcImxlYWZsZXQtZGl2LWljb25cIn0sY3JlYXRlSWNvbjpmdW5jdGlvbih0KXt2YXIgaSxlPXQmJlwiRElWXCI9PT10LnRhZ05hbWU/dDpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG49dGhpcy5vcHRpb25zO3JldHVybiBuLmh0bWwgaW5zdGFuY2VvZiBFbGVtZW50PyhhaShlKSxlLmFwcGVuZENoaWxkKG4uaHRtbCkpOmUuaW5uZXJIVE1MPSExIT09bi5odG1sP24uaHRtbDpcIlwiLG4uYmdQb3MmJihpPUEobi5iZ1BvcyksZS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb249LWkueCtcInB4IFwiKy1pLnkrXCJweFwiKSx0aGlzLl9zZXRJY29uU3R5bGVzKGUsXCJpY29uXCIpLGV9LGNyZWF0ZVNoYWRvdzpmdW5jdGlvbigpe3JldHVybiBudWxsfX0pO1NlLkRlZmF1bHQ9WmU7dmFyIG9uPU1lLmV4dGVuZCh7b3B0aW9uczp7dGlsZVNpemU6MjU2LG9wYWNpdHk6MSx1cGRhdGVXaGVuSWRsZTp5dCx1cGRhdGVXaGVuWm9vbWluZzohMCx1cGRhdGVJbnRlcnZhbDoyMDAsekluZGV4OjEsYm91bmRzOm51bGwsbWluWm9vbTowLG1heFpvb206dm9pZCAwLG1heE5hdGl2ZVpvb206dm9pZCAwLG1pbk5hdGl2ZVpvb206dm9pZCAwLG5vV3JhcDohMSxwYW5lOlwidGlsZVBhbmVcIixjbGFzc05hbWU6XCJcIixrZWVwQnVmZmVyOjJ9LGluaXRpYWxpemU6ZnVuY3Rpb24odCl7Yyh0aGlzLHQpfSxvbkFkZDpmdW5jdGlvbigpe3RoaXMuX2luaXRDb250YWluZXIoKSx0aGlzLl9sZXZlbHM9e30sdGhpcy5fdGlsZXM9e30sdGhpcy5fcmVzZXRWaWV3KCksdGhpcy5fdXBkYXRlKCl9LGJlZm9yZUFkZDpmdW5jdGlvbih0KXt0Ll9hZGRab29tTGltaXQodGhpcyl9LG9uUmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuX3JlbW92ZUFsbFRpbGVzKCkscmkodGhpcy5fY29udGFpbmVyKSx0Ll9yZW1vdmVab29tTGltaXQodGhpcyksdGhpcy5fY29udGFpbmVyPW51bGwsdGhpcy5fdGlsZVpvb209dm9pZCAwfSxicmluZ1RvRnJvbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiYoaGkodGhpcy5fY29udGFpbmVyKSx0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWF4KSksdGhpc30sYnJpbmdUb0JhY2s6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWFwJiYodWkodGhpcy5fY29udGFpbmVyKSx0aGlzLl9zZXRBdXRvWkluZGV4KE1hdGgubWluKSksdGhpc30sZ2V0Q29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5lcn0sc2V0T3BhY2l0eTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vcHRpb25zLm9wYWNpdHk9dCx0aGlzLl91cGRhdGVPcGFjaXR5KCksdGhpc30sc2V0WkluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnMuekluZGV4PXQsdGhpcy5fdXBkYXRlWkluZGV4KCksdGhpc30saXNMb2FkaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xvYWRpbmd9LHJlZHJhdzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXAmJih0aGlzLl9yZW1vdmVBbGxUaWxlcygpLHRoaXMuX3VwZGF0ZSgpKSx0aGlzfSxnZXRFdmVudHM6ZnVuY3Rpb24oKXt2YXIgdD17dmlld3ByZXJlc2V0OnRoaXMuX2ludmFsaWRhdGVBbGwsdmlld3Jlc2V0OnRoaXMuX3Jlc2V0Vmlldyx6b29tOnRoaXMuX3Jlc2V0Vmlldyxtb3ZlZW5kOnRoaXMuX29uTW92ZUVuZH07cmV0dXJuIHRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZXx8KHRoaXMuX29uTW92ZXx8KHRoaXMuX29uTW92ZT1uKHRoaXMuX29uTW92ZUVuZCx0aGlzLm9wdGlvbnMudXBkYXRlSW50ZXJ2YWwsdGhpcykpLHQubW92ZT10aGlzLl9vbk1vdmUpLHRoaXMuX3pvb21BbmltYXRlZCYmKHQuem9vbWFuaW09dGhpcy5fYW5pbWF0ZVpvb20pLHR9LGNyZWF0ZVRpbGU6ZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKX0sZ2V0VGlsZVNpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMudGlsZVNpemU7cmV0dXJuIHQgaW5zdGFuY2VvZiBrP3Q6bmV3IGsodCx0KX0sX3VwZGF0ZVpJbmRleDpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lciYmdm9pZCAwIT09dGhpcy5vcHRpb25zLnpJbmRleCYmbnVsbCE9PXRoaXMub3B0aW9ucy56SW5kZXgmJih0aGlzLl9jb250YWluZXIuc3R5bGUuekluZGV4PXRoaXMub3B0aW9ucy56SW5kZXgpfSxfc2V0QXV0b1pJbmRleDpmdW5jdGlvbih0KXtmb3IodmFyIGksZT10aGlzLmdldFBhbmUoKS5jaGlsZHJlbixuPS10KC0xLzAsMS8wKSxvPTAscz1lLmxlbmd0aDtvPHM7bysrKWk9ZVtvXS5zdHlsZS56SW5kZXgsZVtvXSE9PXRoaXMuX2NvbnRhaW5lciYmaSYmKG49dChuLCtpKSk7aXNGaW5pdGUobikmJih0aGlzLm9wdGlvbnMuekluZGV4PW4rdCgtMSwxKSx0aGlzLl91cGRhdGVaSW5kZXgoKSl9LF91cGRhdGVPcGFjaXR5OmZ1bmN0aW9uKCl7aWYodGhpcy5fbWFwJiYhaXQpe21pKHRoaXMuX2NvbnRhaW5lcix0aGlzLm9wdGlvbnMub3BhY2l0eSk7dmFyIHQ9K25ldyBEYXRlLGk9ITEsZT0hMTtmb3IodmFyIG4gaW4gdGhpcy5fdGlsZXMpe3ZhciBvLHM9dGhpcy5fdGlsZXNbbl07cy5jdXJyZW50JiZzLmxvYWRlZCYmKG89TWF0aC5taW4oMSwodC1zLmxvYWRlZCkvMjAwKSxtaShzLmVsLG8pLG88MT9pPSEwOihzLmFjdGl2ZT9lPSEwOnRoaXMuX29uT3BhcXVlVGlsZShzKSxzLmFjdGl2ZT0hMCkpfWUmJiF0aGlzLl9ub1BydW5lJiZ0aGlzLl9wcnVuZVRpbGVzKCksaSYmKHoodGhpcy5fZmFkZUZyYW1lKSx0aGlzLl9mYWRlRnJhbWU9TSh0aGlzLl91cGRhdGVPcGFjaXR5LHRoaXMpKX19LF9vbk9wYXF1ZVRpbGU6YSxfaW5pdENvbnRhaW5lcjpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lcnx8KHRoaXMuX2NvbnRhaW5lcj1zaShcImRpdlwiLFwibGVhZmxldC1sYXllciBcIisodGhpcy5vcHRpb25zLmNsYXNzTmFtZXx8XCJcIikpLHRoaXMuX3VwZGF0ZVpJbmRleCgpLHRoaXMub3B0aW9ucy5vcGFjaXR5PDEmJnRoaXMuX3VwZGF0ZU9wYWNpdHkoKSx0aGlzLmdldFBhbmUoKS5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpKX0sX3VwZGF0ZUxldmVsczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX3RpbGVab29tLGk9dGhpcy5vcHRpb25zLm1heFpvb207aWYodm9pZCAwIT09dCl7Zm9yKHZhciBlIGluIHRoaXMuX2xldmVscyllPU51bWJlcihlKSx0aGlzLl9sZXZlbHNbZV0uZWwuY2hpbGRyZW4ubGVuZ3RofHxlPT09dD8odGhpcy5fbGV2ZWxzW2VdLmVsLnN0eWxlLnpJbmRleD1pLU1hdGguYWJzKHQtZSksdGhpcy5fb25VcGRhdGVMZXZlbChlKSk6KHJpKHRoaXMuX2xldmVsc1tlXS5lbCksdGhpcy5fcmVtb3ZlVGlsZXNBdFpvb20oZSksdGhpcy5fb25SZW1vdmVMZXZlbChlKSxkZWxldGUgdGhpcy5fbGV2ZWxzW2VdKTt2YXIgbj10aGlzLl9sZXZlbHNbdF0sbz10aGlzLl9tYXA7cmV0dXJuIG58fCgobj10aGlzLl9sZXZlbHNbdF09e30pLmVsPXNpKFwiZGl2XCIsXCJsZWFmbGV0LXRpbGUtY29udGFpbmVyIGxlYWZsZXQtem9vbS1hbmltYXRlZFwiLHRoaXMuX2NvbnRhaW5lciksbi5lbC5zdHlsZS56SW5kZXg9aSxuLm9yaWdpbj1vLnByb2plY3Qoby51bnByb2plY3Qoby5nZXRQaXhlbE9yaWdpbigpKSx0KS5yb3VuZCgpLG4uem9vbT10LHRoaXMuX3NldFpvb21UcmFuc2Zvcm0obixvLmdldENlbnRlcigpLG8uZ2V0Wm9vbSgpKSxhKG4uZWwub2Zmc2V0V2lkdGgpLHRoaXMuX29uQ3JlYXRlTGV2ZWwobikpLHRoaXMuX2xldmVsPW59fSxfb25VcGRhdGVMZXZlbDphLF9vblJlbW92ZUxldmVsOmEsX29uQ3JlYXRlTGV2ZWw6YSxfcHJ1bmVUaWxlczpmdW5jdGlvbigpe2lmKHRoaXMuX21hcCl7dmFyIHQsaSxlLG49dGhpcy5fbWFwLmdldFpvb20oKTtpZihuPnRoaXMub3B0aW9ucy5tYXhab29tfHxuPHRoaXMub3B0aW9ucy5taW5ab29tKXRoaXMuX3JlbW92ZUFsbFRpbGVzKCk7ZWxzZXtmb3IodCBpbiB0aGlzLl90aWxlcykoZT10aGlzLl90aWxlc1t0XSkucmV0YWluPWUuY3VycmVudDtmb3IodCBpbiB0aGlzLl90aWxlcyl7KGU9dGhpcy5fdGlsZXNbdF0pLmN1cnJlbnQmJiFlLmFjdGl2ZSYmKGk9ZS5jb29yZHMsdGhpcy5fcmV0YWluUGFyZW50KGkueCxpLnksaS56LGkuei01KXx8dGhpcy5fcmV0YWluQ2hpbGRyZW4oaS54LGkueSxpLnosaS56KzIpKX1mb3IodCBpbiB0aGlzLl90aWxlcyl0aGlzLl90aWxlc1t0XS5yZXRhaW58fHRoaXMuX3JlbW92ZVRpbGUodCl9fX0sX3JlbW92ZVRpbGVzQXRab29tOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaSBpbiB0aGlzLl90aWxlcyl0aGlzLl90aWxlc1tpXS5jb29yZHMuej09PXQmJnRoaXMuX3JlbW92ZVRpbGUoaSl9LF9yZW1vdmVBbGxUaWxlczpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl90aWxlcyl0aGlzLl9yZW1vdmVUaWxlKHQpfSxfaW52YWxpZGF0ZUFsbDpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9sZXZlbHMpcmkodGhpcy5fbGV2ZWxzW3RdLmVsKSx0aGlzLl9vblJlbW92ZUxldmVsKE51bWJlcih0KSksZGVsZXRlIHRoaXMuX2xldmVsc1t0XTt0aGlzLl9yZW1vdmVBbGxUaWxlcygpLHRoaXMuX3RpbGVab29tPXZvaWQgMH0sX3JldGFpblBhcmVudDpmdW5jdGlvbih0LGksZSxuKXt2YXIgbz1NYXRoLmZsb29yKHQvMikscz1NYXRoLmZsb29yKGkvMikscj1lLTEsYT1uZXcgaygrbywrcyk7YS56PStyO3ZhciBoPXRoaXMuX3RpbGVDb29yZHNUb0tleShhKSx1PXRoaXMuX3RpbGVzW2hdO3JldHVybiB1JiZ1LmFjdGl2ZT91LnJldGFpbj0hMDoodSYmdS5sb2FkZWQmJih1LnJldGFpbj0hMCksbjxyJiZ0aGlzLl9yZXRhaW5QYXJlbnQobyxzLHIsbikpfSxfcmV0YWluQ2hpbGRyZW46ZnVuY3Rpb24odCxpLGUsbil7Zm9yKHZhciBvPTIqdDtvPDIqdCsyO28rKylmb3IodmFyIHM9MippO3M8MippKzI7cysrKXt2YXIgcj1uZXcgayhvLHMpO3Iuej1lKzE7dmFyIGE9dGhpcy5fdGlsZUNvb3Jkc1RvS2V5KHIpLGg9dGhpcy5fdGlsZXNbYV07aCYmaC5hY3RpdmU/aC5yZXRhaW49ITA6KGgmJmgubG9hZGVkJiYoaC5yZXRhaW49ITApLGUrMTxuJiZ0aGlzLl9yZXRhaW5DaGlsZHJlbihvLHMsZSsxLG4pKX19LF9yZXNldFZpZXc6ZnVuY3Rpb24odCl7dmFyIGk9dCYmKHQucGluY2h8fHQuZmx5VG8pO3RoaXMuX3NldFZpZXcodGhpcy5fbWFwLmdldENlbnRlcigpLHRoaXMuX21hcC5nZXRab29tKCksaSxpKX0sX2FuaW1hdGVab29tOmZ1bmN0aW9uKHQpe3RoaXMuX3NldFZpZXcodC5jZW50ZXIsdC56b29tLCEwLHQubm9VcGRhdGUpfSxfY2xhbXBab29tOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMub3B0aW9ucztyZXR1cm4gdm9pZCAwIT09aS5taW5OYXRpdmVab29tJiZ0PGkubWluTmF0aXZlWm9vbT9pLm1pbk5hdGl2ZVpvb206dm9pZCAwIT09aS5tYXhOYXRpdmVab29tJiZpLm1heE5hdGl2ZVpvb208dD9pLm1heE5hdGl2ZVpvb206dH0sX3NldFZpZXc6ZnVuY3Rpb24odCxpLGUsbil7dmFyIG89TWF0aC5yb3VuZChpKSxvPXZvaWQgMCE9PXRoaXMub3B0aW9ucy5tYXhab29tJiZvPnRoaXMub3B0aW9ucy5tYXhab29tfHx2b2lkIDAhPT10aGlzLm9wdGlvbnMubWluWm9vbSYmbzx0aGlzLm9wdGlvbnMubWluWm9vbT92b2lkIDA6dGhpcy5fY2xhbXBab29tKG8pLHM9dGhpcy5vcHRpb25zLnVwZGF0ZVdoZW5ab29taW5nJiZvIT09dGhpcy5fdGlsZVpvb207biYmIXN8fCh0aGlzLl90aWxlWm9vbT1vLHRoaXMuX2Fib3J0TG9hZGluZyYmdGhpcy5fYWJvcnRMb2FkaW5nKCksdGhpcy5fdXBkYXRlTGV2ZWxzKCksdGhpcy5fcmVzZXRHcmlkKCksdm9pZCAwIT09byYmdGhpcy5fdXBkYXRlKHQpLGV8fHRoaXMuX3BydW5lVGlsZXMoKSx0aGlzLl9ub1BydW5lPSEhZSksdGhpcy5fc2V0Wm9vbVRyYW5zZm9ybXModCxpKX0sX3NldFpvb21UcmFuc2Zvcm1zOmZ1bmN0aW9uKHQsaSl7Zm9yKHZhciBlIGluIHRoaXMuX2xldmVscyl0aGlzLl9zZXRab29tVHJhbnNmb3JtKHRoaXMuX2xldmVsc1tlXSx0LGkpfSxfc2V0Wm9vbVRyYW5zZm9ybTpmdW5jdGlvbih0LGksZSl7dmFyIG49dGhpcy5fbWFwLmdldFpvb21TY2FsZShlLHQuem9vbSksbz10Lm9yaWdpbi5tdWx0aXBseUJ5KG4pLnN1YnRyYWN0KHRoaXMuX21hcC5fZ2V0TmV3UGl4ZWxPcmlnaW4oaSxlKSkucm91bmQoKTt2dD9naSh0LmVsLG8sbik6dmkodC5lbCxvKX0sX3Jlc2V0R3JpZDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcCxpPXQub3B0aW9ucy5jcnMsZT10aGlzLl90aWxlU2l6ZT10aGlzLmdldFRpbGVTaXplKCksbj10aGlzLl90aWxlWm9vbSxvPXRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKHRoaXMuX3RpbGVab29tKTtvJiYodGhpcy5fZ2xvYmFsVGlsZVJhbmdlPXRoaXMuX3B4Qm91bmRzVG9UaWxlUmFuZ2UobykpLHRoaXMuX3dyYXBYPWkud3JhcExuZyYmIXRoaXMub3B0aW9ucy5ub1dyYXAmJltNYXRoLmZsb29yKHQucHJvamVjdChbMCxpLndyYXBMbmdbMF1dLG4pLngvZS54KSxNYXRoLmNlaWwodC5wcm9qZWN0KFswLGkud3JhcExuZ1sxXV0sbikueC9lLnkpXSx0aGlzLl93cmFwWT1pLndyYXBMYXQmJiF0aGlzLm9wdGlvbnMubm9XcmFwJiZbTWF0aC5mbG9vcih0LnByb2plY3QoW2kud3JhcExhdFswXSwwXSxuKS55L2UueCksTWF0aC5jZWlsKHQucHJvamVjdChbaS53cmFwTGF0WzFdLDBdLG4pLnkvZS55KV19LF9vbk1vdmVFbmQ6ZnVuY3Rpb24oKXt0aGlzLl9tYXAmJiF0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20mJnRoaXMuX3VwZGF0ZSgpfSxfZ2V0VGlsZWRQaXhlbEJvdW5kczpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAsZT1pLl9hbmltYXRpbmdab29tP01hdGgubWF4KGkuX2FuaW1hdGVUb1pvb20saS5nZXRab29tKCkpOmkuZ2V0Wm9vbSgpLG49aS5nZXRab29tU2NhbGUoZSx0aGlzLl90aWxlWm9vbSksbz1pLnByb2plY3QodCx0aGlzLl90aWxlWm9vbSkuZmxvb3IoKSxzPWkuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIqbik7cmV0dXJuIG5ldyBJKG8uc3VidHJhY3Qocyksby5hZGQocykpfSxfdXBkYXRlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX21hcDtpZihpKXt2YXIgZT10aGlzLl9jbGFtcFpvb20oaS5nZXRab29tKCkpO2lmKHZvaWQgMD09PXQmJih0PWkuZ2V0Q2VudGVyKCkpLHZvaWQgMCE9PXRoaXMuX3RpbGVab29tKXt2YXIgbj10aGlzLl9nZXRUaWxlZFBpeGVsQm91bmRzKHQpLG89dGhpcy5fcHhCb3VuZHNUb1RpbGVSYW5nZShuKSxzPW8uZ2V0Q2VudGVyKCkscj1bXSxhPXRoaXMub3B0aW9ucy5rZWVwQnVmZmVyLGg9bmV3IEkoby5nZXRCb3R0b21MZWZ0KCkuc3VidHJhY3QoW2EsLWFdKSxvLmdldFRvcFJpZ2h0KCkuYWRkKFthLC1hXSkpO2lmKCEoaXNGaW5pdGUoby5taW4ueCkmJmlzRmluaXRlKG8ubWluLnkpJiZpc0Zpbml0ZShvLm1heC54KSYmaXNGaW5pdGUoby5tYXgueSkpKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBsb2FkIGFuIGluZmluaXRlIG51bWJlciBvZiB0aWxlc1wiKTtmb3IodmFyIHUgaW4gdGhpcy5fdGlsZXMpe3ZhciBsPXRoaXMuX3RpbGVzW3VdLmNvb3JkcztsLno9PT10aGlzLl90aWxlWm9vbSYmaC5jb250YWlucyhuZXcgayhsLngsbC55KSl8fCh0aGlzLl90aWxlc1t1XS5jdXJyZW50PSExKX1pZigxPE1hdGguYWJzKGUtdGhpcy5fdGlsZVpvb20pKXRoaXMuX3NldFZpZXcodCxlKTtlbHNle2Zvcih2YXIgYz1vLm1pbi55O2M8PW8ubWF4Lnk7YysrKWZvcih2YXIgXz1vLm1pbi54O188PW8ubWF4Lng7XysrKXt2YXIgZCxwPW5ldyBrKF8sYyk7cC56PXRoaXMuX3RpbGVab29tLHRoaXMuX2lzVmFsaWRUaWxlKHApJiYoKGQ9dGhpcy5fdGlsZXNbdGhpcy5fdGlsZUNvb3Jkc1RvS2V5KHApXSk/ZC5jdXJyZW50PSEwOnIucHVzaChwKSl9aWYoci5zb3J0KGZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQuZGlzdGFuY2VUbyhzKS1pLmRpc3RhbmNlVG8ocyl9KSwwIT09ci5sZW5ndGgpe3RoaXMuX2xvYWRpbmd8fCh0aGlzLl9sb2FkaW5nPSEwLHRoaXMuZmlyZShcImxvYWRpbmdcIikpO2Zvcih2YXIgbT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXz0wO188ci5sZW5ndGg7XysrKXRoaXMuX2FkZFRpbGUocltfXSxtKTt0aGlzLl9sZXZlbC5lbC5hcHBlbmRDaGlsZChtKX19fX19LF9pc1ZhbGlkVGlsZTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAub3B0aW9ucy5jcnM7aWYoIWkuaW5maW5pdGUpe3ZhciBlPXRoaXMuX2dsb2JhbFRpbGVSYW5nZTtpZighaS53cmFwTG5nJiYodC54PGUubWluLnh8fHQueD5lLm1heC54KXx8IWkud3JhcExhdCYmKHQueTxlLm1pbi55fHx0Lnk+ZS5tYXgueSkpcmV0dXJuITF9aWYoIXRoaXMub3B0aW9ucy5ib3VuZHMpcmV0dXJuITA7dmFyIG49dGhpcy5fdGlsZUNvb3Jkc1RvQm91bmRzKHQpO3JldHVybiBOKHRoaXMub3B0aW9ucy5ib3VuZHMpLm92ZXJsYXBzKG4pfSxfa2V5VG9Cb3VuZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3RpbGVDb29yZHNUb0JvdW5kcyh0aGlzLl9rZXlUb1RpbGVDb29yZHModCkpfSxfdGlsZUNvb3Jkc1RvTndTZTpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9tYXAsZT10aGlzLmdldFRpbGVTaXplKCksbj10LnNjYWxlQnkoZSksbz1uLmFkZChlKTtyZXR1cm5baS51bnByb2plY3Qobix0LnopLGkudW5wcm9qZWN0KG8sdC56KV19LF90aWxlQ29vcmRzVG9Cb3VuZHM6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fdGlsZUNvb3Jkc1RvTndTZSh0KSxlPW5ldyBSKGlbMF0saVsxXSk7cmV0dXJuIHRoaXMub3B0aW9ucy5ub1dyYXB8fChlPXRoaXMuX21hcC53cmFwTGF0TG5nQm91bmRzKGUpKSxlfSxfdGlsZUNvb3Jkc1RvS2V5OmZ1bmN0aW9uKHQpe3JldHVybiB0LngrXCI6XCIrdC55K1wiOlwiK3Quen0sX2tleVRvVGlsZUNvb3JkczpmdW5jdGlvbih0KXt2YXIgaT10LnNwbGl0KFwiOlwiKSxlPW5ldyBrKCtpWzBdLCtpWzFdKTtyZXR1cm4gZS56PStpWzJdLGV9LF9yZW1vdmVUaWxlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuX3RpbGVzW3RdO2kmJihyaShpLmVsKSxkZWxldGUgdGhpcy5fdGlsZXNbdF0sdGhpcy5maXJlKFwidGlsZXVubG9hZFwiLHt0aWxlOmkuZWwsY29vcmRzOnRoaXMuX2tleVRvVGlsZUNvb3Jkcyh0KX0pKX0sX2luaXRUaWxlOmZ1bmN0aW9uKHQpe2NpKHQsXCJsZWFmbGV0LXRpbGVcIik7dmFyIGk9dGhpcy5nZXRUaWxlU2l6ZSgpO3Quc3R5bGUud2lkdGg9aS54K1wicHhcIix0LnN0eWxlLmhlaWdodD1pLnkrXCJweFwiLHQub25zZWxlY3RzdGFydD1hLHQub25tb3VzZW1vdmU9YSxpdCYmdGhpcy5vcHRpb25zLm9wYWNpdHk8MSYmbWkodCx0aGlzLm9wdGlvbnMub3BhY2l0eSksb3QmJiFzdCYmKHQuc3R5bGUuV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5PVwiaGlkZGVuXCIpfSxfYWRkVGlsZTpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuX2dldFRpbGVQb3ModCksbj10aGlzLl90aWxlQ29vcmRzVG9LZXkodCksbz10aGlzLmNyZWF0ZVRpbGUodGhpcy5fd3JhcENvb3Jkcyh0KSxwKHRoaXMuX3RpbGVSZWFkeSx0aGlzLHQpKTt0aGlzLl9pbml0VGlsZShvKSx0aGlzLmNyZWF0ZVRpbGUubGVuZ3RoPDImJk0ocCh0aGlzLl90aWxlUmVhZHksdGhpcyx0LG51bGwsbykpLHZpKG8sZSksdGhpcy5fdGlsZXNbbl09e2VsOm8sY29vcmRzOnQsY3VycmVudDohMH0saS5hcHBlbmRDaGlsZChvKSx0aGlzLmZpcmUoXCJ0aWxlbG9hZHN0YXJ0XCIse3RpbGU6byxjb29yZHM6dH0pfSxfdGlsZVJlYWR5OmZ1bmN0aW9uKHQsaSxlKXtpJiZ0aGlzLmZpcmUoXCJ0aWxlZXJyb3JcIix7ZXJyb3I6aSx0aWxlOmUsY29vcmRzOnR9KTt2YXIgbj10aGlzLl90aWxlQ29vcmRzVG9LZXkodCk7KGU9dGhpcy5fdGlsZXNbbl0pJiYoZS5sb2FkZWQ9K25ldyBEYXRlLHRoaXMuX21hcC5fZmFkZUFuaW1hdGVkPyhtaShlLmVsLDApLHoodGhpcy5fZmFkZUZyYW1lKSx0aGlzLl9mYWRlRnJhbWU9TSh0aGlzLl91cGRhdGVPcGFjaXR5LHRoaXMpKTooZS5hY3RpdmU9ITAsdGhpcy5fcHJ1bmVUaWxlcygpKSxpfHwoY2koZS5lbCxcImxlYWZsZXQtdGlsZS1sb2FkZWRcIiksdGhpcy5maXJlKFwidGlsZWxvYWRcIix7dGlsZTplLmVsLGNvb3Jkczp0fSkpLHRoaXMuX25vVGlsZXNUb0xvYWQoKSYmKHRoaXMuX2xvYWRpbmc9ITEsdGhpcy5maXJlKFwibG9hZFwiKSxpdHx8IXRoaXMuX21hcC5fZmFkZUFuaW1hdGVkP00odGhpcy5fcHJ1bmVUaWxlcyx0aGlzKTpzZXRUaW1lb3V0KHAodGhpcy5fcHJ1bmVUaWxlcyx0aGlzKSwyNTApKSl9LF9nZXRUaWxlUG9zOmZ1bmN0aW9uKHQpe3JldHVybiB0LnNjYWxlQnkodGhpcy5nZXRUaWxlU2l6ZSgpKS5zdWJ0cmFjdCh0aGlzLl9sZXZlbC5vcmlnaW4pfSxfd3JhcENvb3JkczpmdW5jdGlvbih0KXt2YXIgaT1uZXcgayh0aGlzLl93cmFwWD9vKHQueCx0aGlzLl93cmFwWCk6dC54LHRoaXMuX3dyYXBZP28odC55LHRoaXMuX3dyYXBZKTp0LnkpO3JldHVybiBpLno9dC56LGl9LF9weEJvdW5kc1RvVGlsZVJhbmdlOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXMuZ2V0VGlsZVNpemUoKTtyZXR1cm4gbmV3IEkodC5taW4udW5zY2FsZUJ5KGkpLmZsb29yKCksdC5tYXgudW5zY2FsZUJ5KGkpLmNlaWwoKS5zdWJ0cmFjdChbMSwxXSkpfSxfbm9UaWxlc1RvTG9hZDpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl90aWxlcylpZighdGhpcy5fdGlsZXNbdF0ubG9hZGVkKXJldHVybiExO3JldHVybiEwfX0pO3ZhciBzbj1vbi5leHRlbmQoe29wdGlvbnM6e21pblpvb206MCxtYXhab29tOjE4LHN1YmRvbWFpbnM6XCJhYmNcIixlcnJvclRpbGVVcmw6XCJcIix6b29tT2Zmc2V0OjAsdG1zOiExLHpvb21SZXZlcnNlOiExLGRldGVjdFJldGluYTohMSxjcm9zc09yaWdpbjohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe3RoaXMuX3VybD10LChpPWModGhpcyxpKSkuZGV0ZWN0UmV0aW5hJiZ6dCYmMDxpLm1heFpvb20mJihpLnRpbGVTaXplPU1hdGguZmxvb3IoaS50aWxlU2l6ZS8yKSxpLnpvb21SZXZlcnNlPyhpLnpvb21PZmZzZXQtLSxpLm1pblpvb20rKyk6KGkuem9vbU9mZnNldCsrLGkubWF4Wm9vbS0tKSxpLm1pblpvb209TWF0aC5tYXgoMCxpLm1pblpvb20pKSxcInN0cmluZ1wiPT10eXBlb2YgaS5zdWJkb21haW5zJiYoaS5zdWJkb21haW5zPWkuc3ViZG9tYWlucy5zcGxpdChcIlwiKSksb3R8fHRoaXMub24oXCJ0aWxldW5sb2FkXCIsdGhpcy5fb25UaWxlUmVtb3ZlKX0sc2V0VXJsOmZ1bmN0aW9uKHQsaSl7cmV0dXJuIHRoaXMuX3VybD09PXQmJnZvaWQgMD09PWkmJihpPSEwKSx0aGlzLl91cmw9dCxpfHx0aGlzLnJlZHJhdygpLHRoaXN9LGNyZWF0ZVRpbGU6ZnVuY3Rpb24odCxpKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO3JldHVybiB6aShlLFwibG9hZFwiLHAodGhpcy5fdGlsZU9uTG9hZCx0aGlzLGksZSkpLHppKGUsXCJlcnJvclwiLHAodGhpcy5fdGlsZU9uRXJyb3IsdGhpcyxpLGUpKSwhdGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luJiZcIlwiIT09dGhpcy5vcHRpb25zLmNyb3NzT3JpZ2lufHwoZS5jcm9zc09yaWdpbj0hMD09PXRoaXMub3B0aW9ucy5jcm9zc09yaWdpbj9cIlwiOnRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiksZS5hbHQ9XCJcIixlLnNldEF0dHJpYnV0ZShcInJvbGVcIixcInByZXNlbnRhdGlvblwiKSxlLnNyYz10aGlzLmdldFRpbGVVcmwodCksZX0sZ2V0VGlsZVVybDpmdW5jdGlvbih0KXt2YXIgaSxlPXtyOnp0P1wiQDJ4XCI6XCJcIixzOnRoaXMuX2dldFN1YmRvbWFpbih0KSx4OnQueCx5OnQueSx6OnRoaXMuX2dldFpvb21Gb3JVcmwoKX07cmV0dXJuIHRoaXMuX21hcCYmIXRoaXMuX21hcC5vcHRpb25zLmNycy5pbmZpbml0ZSYmKGk9dGhpcy5fZ2xvYmFsVGlsZVJhbmdlLm1heC55LXQueSx0aGlzLm9wdGlvbnMudG1zJiYoZS55PWkpLGVbXCIteVwiXT1pKSxmKHRoaXMuX3VybCxoKGUsdGhpcy5vcHRpb25zKSl9LF90aWxlT25Mb2FkOmZ1bmN0aW9uKHQsaSl7aXQ/c2V0VGltZW91dChwKHQsdGhpcyxudWxsLGkpLDApOnQobnVsbCxpKX0sX3RpbGVPbkVycm9yOmZ1bmN0aW9uKHQsaSxlKXt2YXIgbj10aGlzLm9wdGlvbnMuZXJyb3JUaWxlVXJsO24mJmkuZ2V0QXR0cmlidXRlKFwic3JjXCIpIT09biYmKGkuc3JjPW4pLHQoZSxpKX0sX29uVGlsZVJlbW92ZTpmdW5jdGlvbih0KXt0LnRpbGUub25sb2FkPW51bGx9LF9nZXRab29tRm9yVXJsOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fdGlsZVpvb20saT10aGlzLm9wdGlvbnMubWF4Wm9vbTtyZXR1cm4gdGhpcy5vcHRpb25zLnpvb21SZXZlcnNlJiYodD1pLXQpLHQrdGhpcy5vcHRpb25zLnpvb21PZmZzZXR9LF9nZXRTdWJkb21haW46ZnVuY3Rpb24odCl7dmFyIGk9TWF0aC5hYnModC54K3QueSkldGhpcy5vcHRpb25zLnN1YmRvbWFpbnMubGVuZ3RoO3JldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpXX0sX2Fib3J0TG9hZGluZzpmdW5jdGlvbigpe3ZhciB0LGk7Zm9yKHQgaW4gdGhpcy5fdGlsZXMpdGhpcy5fdGlsZXNbdF0uY29vcmRzLnohPT10aGlzLl90aWxlWm9vbSYmKChpPXRoaXMuX3RpbGVzW3RdLmVsKS5vbmxvYWQ9YSxpLm9uZXJyb3I9YSxpLmNvbXBsZXRlfHwoaS5zcmM9eSxyaShpKSxkZWxldGUgdGhpcy5fdGlsZXNbdF0pKX0sX3JlbW92ZVRpbGU6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fdGlsZXNbdF07aWYoaSlyZXR1cm4gYXR8fGkuZWwuc2V0QXR0cmlidXRlKFwic3JjXCIseSksb24ucHJvdG90eXBlLl9yZW1vdmVUaWxlLmNhbGwodGhpcyx0KX0sX3RpbGVSZWFkeTpmdW5jdGlvbih0LGksZSl7aWYodGhpcy5fbWFwJiYoIWV8fGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpIT09eSkpcmV0dXJuIG9uLnByb3RvdHlwZS5fdGlsZVJlYWR5LmNhbGwodGhpcyx0LGksZSl9fSk7ZnVuY3Rpb24gcm4odCxpKXtyZXR1cm4gbmV3IHNuKHQsaSl9dmFyIGFuPXNuLmV4dGVuZCh7ZGVmYXVsdFdtc1BhcmFtczp7c2VydmljZTpcIldNU1wiLHJlcXVlc3Q6XCJHZXRNYXBcIixsYXllcnM6XCJcIixzdHlsZXM6XCJcIixmb3JtYXQ6XCJpbWFnZS9qcGVnXCIsdHJhbnNwYXJlbnQ6ITEsdmVyc2lvbjpcIjEuMS4xXCJ9LG9wdGlvbnM6e2NyczpudWxsLHVwcGVyY2FzZTohMX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0LGkpe3RoaXMuX3VybD10O3ZhciBlPWgoe30sdGhpcy5kZWZhdWx0V21zUGFyYW1zKTtmb3IodmFyIG4gaW4gaSluIGluIHRoaXMub3B0aW9uc3x8KGVbbl09aVtuXSk7dmFyIG89KGk9Yyh0aGlzLGkpKS5kZXRlY3RSZXRpbmEmJnp0PzI6MSxzPXRoaXMuZ2V0VGlsZVNpemUoKTtlLndpZHRoPXMueCpvLGUuaGVpZ2h0PXMueSpvLHRoaXMud21zUGFyYW1zPWV9LG9uQWRkOmZ1bmN0aW9uKHQpe3RoaXMuX2Nycz10aGlzLm9wdGlvbnMuY3JzfHx0Lm9wdGlvbnMuY3JzLHRoaXMuX3dtc1ZlcnNpb249cGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTt2YXIgaT0xLjM8PXRoaXMuX3dtc1ZlcnNpb24/XCJjcnNcIjpcInNyc1wiO3RoaXMud21zUGFyYW1zW2ldPXRoaXMuX2Nycy5jb2RlLHNuLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsdCl9LGdldFRpbGVVcmw6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fdGlsZUNvb3Jkc1RvTndTZSh0KSxlPXRoaXMuX2NycyxuPU8oZS5wcm9qZWN0KGlbMF0pLGUucHJvamVjdChpWzFdKSksbz1uLm1pbixzPW4ubWF4LHI9KDEuMzw9dGhpcy5fd21zVmVyc2lvbiYmdGhpcy5fY3JzPT09YmU/W28ueSxvLngscy55LHMueF06W28ueCxvLnkscy54LHMueV0pLmpvaW4oXCIsXCIpLGE9c24ucHJvdG90eXBlLmdldFRpbGVVcmwuY2FsbCh0aGlzLHQpO3JldHVybiBhK18odGhpcy53bXNQYXJhbXMsYSx0aGlzLm9wdGlvbnMudXBwZXJjYXNlKSsodGhpcy5vcHRpb25zLnVwcGVyY2FzZT9cIiZCQk9YPVwiOlwiJmJib3g9XCIpK3J9LHNldFBhcmFtczpmdW5jdGlvbih0LGkpe3JldHVybiBoKHRoaXMud21zUGFyYW1zLHQpLGl8fHRoaXMucmVkcmF3KCksdGhpc319KTtzbi5XTVM9YW4scm4ud21zPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyBhbih0LGkpfTt2YXIgaG49TWUuZXh0ZW5kKHtvcHRpb25zOntwYWRkaW5nOi4xLHRvbGVyYW5jZTowfSxpbml0aWFsaXplOmZ1bmN0aW9uKHQpe2ModGhpcyx0KSxtKHRoaXMpLHRoaXMuX2xheWVycz10aGlzLl9sYXllcnN8fHt9fSxvbkFkZDpmdW5jdGlvbigpe3RoaXMuX2NvbnRhaW5lcnx8KHRoaXMuX2luaXRDb250YWluZXIoKSx0aGlzLl96b29tQW5pbWF0ZWQmJmNpKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtem9vbS1hbmltYXRlZFwiKSksdGhpcy5nZXRQYW5lKCkuYXBwZW5kQ2hpbGQodGhpcy5fY29udGFpbmVyKSx0aGlzLl91cGRhdGUoKSx0aGlzLm9uKFwidXBkYXRlXCIsdGhpcy5fdXBkYXRlUGF0aHMsdGhpcyl9LG9uUmVtb3ZlOmZ1bmN0aW9uKCl7dGhpcy5vZmYoXCJ1cGRhdGVcIix0aGlzLl91cGRhdGVQYXRocyx0aGlzKSx0aGlzLl9kZXN0cm95Q29udGFpbmVyKCl9LGdldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PXt2aWV3cmVzZXQ6dGhpcy5fcmVzZXQsem9vbTp0aGlzLl9vblpvb20sbW92ZWVuZDp0aGlzLl91cGRhdGUsem9vbWVuZDp0aGlzLl9vblpvb21FbmR9O3JldHVybiB0aGlzLl96b29tQW5pbWF0ZWQmJih0Lnpvb21hbmltPXRoaXMuX29uQW5pbVpvb20pLHR9LF9vbkFuaW1ab29tOmZ1bmN0aW9uKHQpe3RoaXMuX3VwZGF0ZVRyYW5zZm9ybSh0LmNlbnRlcix0Lnpvb20pfSxfb25ab29tOmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlVHJhbnNmb3JtKHRoaXMuX21hcC5nZXRDZW50ZXIoKSx0aGlzLl9tYXAuZ2V0Wm9vbSgpKX0sX3VwZGF0ZVRyYW5zZm9ybTpmdW5jdGlvbih0LGkpe3ZhciBlPXRoaXMuX21hcC5nZXRab29tU2NhbGUoaSx0aGlzLl96b29tKSxuPXlpKHRoaXMuX2NvbnRhaW5lciksbz10aGlzLl9tYXAuZ2V0U2l6ZSgpLm11bHRpcGx5QnkoLjUrdGhpcy5vcHRpb25zLnBhZGRpbmcpLHM9dGhpcy5fbWFwLnByb2plY3QodGhpcy5fY2VudGVyLGkpLHI9dGhpcy5fbWFwLnByb2plY3QodCxpKS5zdWJ0cmFjdChzKSxhPW8ubXVsdGlwbHlCeSgtZSkuYWRkKG4pLmFkZChvKS5zdWJ0cmFjdChyKTt2dD9naSh0aGlzLl9jb250YWluZXIsYSxlKTp2aSh0aGlzLl9jb250YWluZXIsYSl9LF9yZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl91cGRhdGUoKSx0aGlzLl91cGRhdGVUcmFuc2Zvcm0odGhpcy5fY2VudGVyLHRoaXMuX3pvb20pLHRoaXMuX2xheWVycyl0aGlzLl9sYXllcnNbdF0uX3Jlc2V0KCl9LF9vblpvb21FbmQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fbGF5ZXJzKXRoaXMuX2xheWVyc1t0XS5fcHJvamVjdCgpfSxfdXBkYXRlUGF0aHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5fbGF5ZXJzKXRoaXMuX2xheWVyc1t0XS5fdXBkYXRlKCl9LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMucGFkZGluZyxpPXRoaXMuX21hcC5nZXRTaXplKCksZT10aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoaS5tdWx0aXBseUJ5KC10KSkucm91bmQoKTt0aGlzLl9ib3VuZHM9bmV3IEkoZSxlLmFkZChpLm11bHRpcGx5QnkoMSsyKnQpKS5yb3VuZCgpKSx0aGlzLl9jZW50ZXI9dGhpcy5fbWFwLmdldENlbnRlcigpLHRoaXMuX3pvb209dGhpcy5fbWFwLmdldFpvb20oKX19KSx1bj1obi5leHRlbmQoe2dldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PWhuLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gdC52aWV3cHJlcmVzZXQ9dGhpcy5fb25WaWV3UHJlUmVzZXQsdH0sX29uVmlld1ByZVJlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocz0hMH0sb25BZGQ6ZnVuY3Rpb24oKXtobi5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzKSx0aGlzLl9kcmF3KCl9LF9pbml0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7emkodCxcIm1vdXNlbW92ZVwiLHRoaXMuX29uTW91c2VNb3ZlLHRoaXMpLHppKHQsXCJjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBjb250ZXh0bWVudVwiLHRoaXMuX29uQ2xpY2ssdGhpcyksemkodCxcIm1vdXNlb3V0XCIsdGhpcy5faGFuZGxlTW91c2VPdXQsdGhpcyksdGhpcy5fY3R4PXQuZ2V0Q29udGV4dChcIjJkXCIpfSxfZGVzdHJveUNvbnRhaW5lcjpmdW5jdGlvbigpe3oodGhpcy5fcmVkcmF3UmVxdWVzdCksZGVsZXRlIHRoaXMuX2N0eCxyaSh0aGlzLl9jb250YWluZXIpLFNpKHRoaXMuX2NvbnRhaW5lciksZGVsZXRlIHRoaXMuX2NvbnRhaW5lcn0sX3VwZGF0ZVBhdGhzOmZ1bmN0aW9uKCl7aWYoIXRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHMpe2Zvcih2YXIgdCBpbiB0aGlzLl9yZWRyYXdCb3VuZHM9bnVsbCx0aGlzLl9sYXllcnMpdGhpcy5fbGF5ZXJzW3RdLl91cGRhdGUoKTt0aGlzLl9yZWRyYXcoKX19LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdCxpLGUsbjt0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20mJnRoaXMuX2JvdW5kc3x8KGhuLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyksdD10aGlzLl9ib3VuZHMsaT10aGlzLl9jb250YWluZXIsZT10LmdldFNpemUoKSxuPXp0PzI6MSx2aShpLHQubWluKSxpLndpZHRoPW4qZS54LGkuaGVpZ2h0PW4qZS55LGkuc3R5bGUud2lkdGg9ZS54K1wicHhcIixpLnN0eWxlLmhlaWdodD1lLnkrXCJweFwiLHp0JiZ0aGlzLl9jdHguc2NhbGUoMiwyKSx0aGlzLl9jdHgudHJhbnNsYXRlKC10Lm1pbi54LC10Lm1pbi55KSx0aGlzLmZpcmUoXCJ1cGRhdGVcIikpfSxfcmVzZXQ6ZnVuY3Rpb24oKXtobi5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcyksdGhpcy5fcG9zdHBvbmVVcGRhdGVQYXRocyYmKHRoaXMuX3Bvc3Rwb25lVXBkYXRlUGF0aHM9ITEsdGhpcy5fdXBkYXRlUGF0aHMoKSl9LF9pbml0UGF0aDpmdW5jdGlvbih0KXt0aGlzLl91cGRhdGVEYXNoQXJyYXkodCk7dmFyIGk9KHRoaXMuX2xheWVyc1ttKHQpXT10KS5fb3JkZXI9e2xheWVyOnQscHJldjp0aGlzLl9kcmF3TGFzdCxuZXh0Om51bGx9O3RoaXMuX2RyYXdMYXN0JiYodGhpcy5fZHJhd0xhc3QubmV4dD1pKSx0aGlzLl9kcmF3TGFzdD1pLHRoaXMuX2RyYXdGaXJzdD10aGlzLl9kcmF3Rmlyc3R8fHRoaXMuX2RyYXdMYXN0fSxfYWRkUGF0aDpmdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0UmVkcmF3KHQpfSxfcmVtb3ZlUGF0aDpmdW5jdGlvbih0KXt2YXIgaT10Ll9vcmRlcixlPWkubmV4dCxuPWkucHJldjtlP2UucHJldj1uOnRoaXMuX2RyYXdMYXN0PW4sbj9uLm5leHQ9ZTp0aGlzLl9kcmF3Rmlyc3Q9ZSxkZWxldGUgdC5fb3JkZXIsZGVsZXRlIHRoaXMuX2xheWVyc1ttKHQpXSx0aGlzLl9yZXF1ZXN0UmVkcmF3KHQpfSxfdXBkYXRlUGF0aDpmdW5jdGlvbih0KXt0aGlzLl9leHRlbmRSZWRyYXdCb3VuZHModCksdC5fcHJvamVjdCgpLHQuX3VwZGF0ZSgpLHRoaXMuX3JlcXVlc3RSZWRyYXcodCl9LF91cGRhdGVTdHlsZTpmdW5jdGlvbih0KXt0aGlzLl91cGRhdGVEYXNoQXJyYXkodCksdGhpcy5fcmVxdWVzdFJlZHJhdyh0KX0sX3VwZGF0ZURhc2hBcnJheTpmdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdC5vcHRpb25zLmRhc2hBcnJheSl7Zm9yKHZhciBpLGU9dC5vcHRpb25zLmRhc2hBcnJheS5zcGxpdCgvWywgXSsvKSxuPVtdLG89MDtvPGUubGVuZ3RoO28rKyl7aWYoaT1OdW1iZXIoZVtvXSksaXNOYU4oaSkpcmV0dXJuO24ucHVzaChpKX10Lm9wdGlvbnMuX2Rhc2hBcnJheT1ufWVsc2UgdC5vcHRpb25zLl9kYXNoQXJyYXk9dC5vcHRpb25zLmRhc2hBcnJheX0sX3JlcXVlc3RSZWRyYXc6ZnVuY3Rpb24odCl7dGhpcy5fbWFwJiYodGhpcy5fZXh0ZW5kUmVkcmF3Qm91bmRzKHQpLHRoaXMuX3JlZHJhd1JlcXVlc3Q9dGhpcy5fcmVkcmF3UmVxdWVzdHx8TSh0aGlzLl9yZWRyYXcsdGhpcykpfSxfZXh0ZW5kUmVkcmF3Qm91bmRzOmZ1bmN0aW9uKHQpe3ZhciBpO3QuX3B4Qm91bmRzJiYoaT0odC5vcHRpb25zLndlaWdodHx8MCkrMSx0aGlzLl9yZWRyYXdCb3VuZHM9dGhpcy5fcmVkcmF3Qm91bmRzfHxuZXcgSSx0aGlzLl9yZWRyYXdCb3VuZHMuZXh0ZW5kKHQuX3B4Qm91bmRzLm1pbi5zdWJ0cmFjdChbaSxpXSkpLHRoaXMuX3JlZHJhd0JvdW5kcy5leHRlbmQodC5fcHhCb3VuZHMubWF4LmFkZChbaSxpXSkpKX0sX3JlZHJhdzpmdW5jdGlvbigpe3RoaXMuX3JlZHJhd1JlcXVlc3Q9bnVsbCx0aGlzLl9yZWRyYXdCb3VuZHMmJih0aGlzLl9yZWRyYXdCb3VuZHMubWluLl9mbG9vcigpLHRoaXMuX3JlZHJhd0JvdW5kcy5tYXguX2NlaWwoKSksdGhpcy5fY2xlYXIoKSx0aGlzLl9kcmF3KCksdGhpcy5fcmVkcmF3Qm91bmRzPW51bGx9LF9jbGVhcjpmdW5jdGlvbigpe3ZhciB0LGk9dGhpcy5fcmVkcmF3Qm91bmRzO2k/KHQ9aS5nZXRTaXplKCksdGhpcy5fY3R4LmNsZWFyUmVjdChpLm1pbi54LGkubWluLnksdC54LHQueSkpOih0aGlzLl9jdHguc2F2ZSgpLHRoaXMuX2N0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApLHRoaXMuX2N0eC5jbGVhclJlY3QoMCwwLHRoaXMuX2NvbnRhaW5lci53aWR0aCx0aGlzLl9jb250YWluZXIuaGVpZ2h0KSx0aGlzLl9jdHgucmVzdG9yZSgpKX0sX2RyYXc6ZnVuY3Rpb24oKXt2YXIgdCxpLGU9dGhpcy5fcmVkcmF3Qm91bmRzO3RoaXMuX2N0eC5zYXZlKCksZSYmKGk9ZS5nZXRTaXplKCksdGhpcy5fY3R4LmJlZ2luUGF0aCgpLHRoaXMuX2N0eC5yZWN0KGUubWluLngsZS5taW4ueSxpLngsaS55KSx0aGlzLl9jdHguY2xpcCgpKSx0aGlzLl9kcmF3aW5nPSEwO2Zvcih2YXIgbj10aGlzLl9kcmF3Rmlyc3Q7bjtuPW4ubmV4dCl0PW4ubGF5ZXIsKCFlfHx0Ll9weEJvdW5kcyYmdC5fcHhCb3VuZHMuaW50ZXJzZWN0cyhlKSkmJnQuX3VwZGF0ZVBhdGgoKTt0aGlzLl9kcmF3aW5nPSExLHRoaXMuX2N0eC5yZXN0b3JlKCl9LF91cGRhdGVQb2x5OmZ1bmN0aW9uKHQsaSl7aWYodGhpcy5fZHJhd2luZyl7dmFyIGUsbixvLHMscj10Ll9wYXJ0cyxhPXIubGVuZ3RoLGg9dGhpcy5fY3R4O2lmKGEpe2ZvcihoLmJlZ2luUGF0aCgpLGU9MDtlPGE7ZSsrKXtmb3Iobj0wLG89cltlXS5sZW5ndGg7bjxvO24rKylzPXJbZV1bbl0saFtuP1wibGluZVRvXCI6XCJtb3ZlVG9cIl0ocy54LHMueSk7aSYmaC5jbG9zZVBhdGgoKX10aGlzLl9maWxsU3Ryb2tlKGgsdCl9fX0sX3VwZGF0ZUNpcmNsZTpmdW5jdGlvbih0KXt2YXIgaSxlLG4sbzt0aGlzLl9kcmF3aW5nJiYhdC5fZW1wdHkoKSYmKGk9dC5fcG9pbnQsZT10aGlzLl9jdHgsbj1NYXRoLm1heChNYXRoLnJvdW5kKHQuX3JhZGl1cyksMSksMSE9KG89KE1hdGgubWF4KE1hdGgucm91bmQodC5fcmFkaXVzWSksMSl8fG4pL24pJiYoZS5zYXZlKCksZS5zY2FsZSgxLG8pKSxlLmJlZ2luUGF0aCgpLGUuYXJjKGkueCxpLnkvbyxuLDAsMipNYXRoLlBJLCExKSwxIT1vJiZlLnJlc3RvcmUoKSx0aGlzLl9maWxsU3Ryb2tlKGUsdCkpfSxfZmlsbFN0cm9rZTpmdW5jdGlvbih0LGkpe3ZhciBlPWkub3B0aW9ucztlLmZpbGwmJih0Lmdsb2JhbEFscGhhPWUuZmlsbE9wYWNpdHksdC5maWxsU3R5bGU9ZS5maWxsQ29sb3J8fGUuY29sb3IsdC5maWxsKGUuZmlsbFJ1bGV8fFwiZXZlbm9kZFwiKSksZS5zdHJva2UmJjAhPT1lLndlaWdodCYmKHQuc2V0TGluZURhc2gmJnQuc2V0TGluZURhc2goaS5vcHRpb25zJiZpLm9wdGlvbnMuX2Rhc2hBcnJheXx8W10pLHQuZ2xvYmFsQWxwaGE9ZS5vcGFjaXR5LHQubGluZVdpZHRoPWUud2VpZ2h0LHQuc3Ryb2tlU3R5bGU9ZS5jb2xvcix0LmxpbmVDYXA9ZS5saW5lQ2FwLHQubGluZUpvaW49ZS5saW5lSm9pbix0LnN0cm9rZSgpKX0sX29uQ2xpY2s6ZnVuY3Rpb24odCl7Zm9yKHZhciBpLGUsbj10aGlzLl9tYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludCh0KSxvPXRoaXMuX2RyYXdGaXJzdDtvO289by5uZXh0KShpPW8ubGF5ZXIpLm9wdGlvbnMuaW50ZXJhY3RpdmUmJmkuX2NvbnRhaW5zUG9pbnQobikmJigoXCJjbGlja1wiPT09dC50eXBlfHxcInByZWNsaWNrXCIhPT10LnR5cGUpJiZ0aGlzLl9tYXAuX2RyYWdnYWJsZU1vdmVkKGkpfHwoZT1pKSk7ZSYmKEZpKHQpLHRoaXMuX2ZpcmVFdmVudChbZV0sdCkpfSxfb25Nb3VzZU1vdmU6ZnVuY3Rpb24odCl7dmFyIGk7IXRoaXMuX21hcHx8dGhpcy5fbWFwLmRyYWdnaW5nLm1vdmluZygpfHx0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb218fChpPXRoaXMuX21hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KHQpLHRoaXMuX2hhbmRsZU1vdXNlSG92ZXIodCxpKSl9LF9oYW5kbGVNb3VzZU91dDpmdW5jdGlvbih0KXt2YXIgaT10aGlzLl9ob3ZlcmVkTGF5ZXI7aSYmKF9pKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtaW50ZXJhY3RpdmVcIiksdGhpcy5fZmlyZUV2ZW50KFtpXSx0LFwibW91c2VvdXRcIiksdGhpcy5faG92ZXJlZExheWVyPW51bGwsdGhpcy5fbW91c2VIb3ZlclRocm90dGxlZD0hMSl9LF9oYW5kbGVNb3VzZUhvdmVyOmZ1bmN0aW9uKHQsaSl7aWYoIXRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQpe2Zvcih2YXIgZSxuLG89dGhpcy5fZHJhd0ZpcnN0O287bz1vLm5leHQpKGU9by5sYXllcikub3B0aW9ucy5pbnRlcmFjdGl2ZSYmZS5fY29udGFpbnNQb2ludChpKSYmKG49ZSk7biE9PXRoaXMuX2hvdmVyZWRMYXllciYmKHRoaXMuX2hhbmRsZU1vdXNlT3V0KHQpLG4mJihjaSh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuX2ZpcmVFdmVudChbbl0sdCxcIm1vdXNlb3ZlclwiKSx0aGlzLl9ob3ZlcmVkTGF5ZXI9bikpLHRoaXMuX2hvdmVyZWRMYXllciYmdGhpcy5fZmlyZUV2ZW50KFt0aGlzLl9ob3ZlcmVkTGF5ZXJdLHQpLHRoaXMuX21vdXNlSG92ZXJUaHJvdHRsZWQ9ITAsc2V0VGltZW91dChwKGZ1bmN0aW9uKCl7dGhpcy5fbW91c2VIb3ZlclRocm90dGxlZD0hMX0sdGhpcyksMzIpfX0sX2ZpcmVFdmVudDpmdW5jdGlvbih0LGksZSl7dGhpcy5fbWFwLl9maXJlRE9NRXZlbnQoaSxlfHxpLnR5cGUsdCl9LF9icmluZ1RvRnJvbnQ6ZnVuY3Rpb24odCl7dmFyIGksZSxuPXQuX29yZGVyO24mJihpPW4ubmV4dCxlPW4ucHJldixpJiYoKGkucHJldj1lKT9lLm5leHQ9aTppJiYodGhpcy5fZHJhd0ZpcnN0PWkpLG4ucHJldj10aGlzLl9kcmF3TGFzdCwodGhpcy5fZHJhd0xhc3QubmV4dD1uKS5uZXh0PW51bGwsdGhpcy5fZHJhd0xhc3Q9bix0aGlzLl9yZXF1ZXN0UmVkcmF3KHQpKSl9LF9icmluZ1RvQmFjazpmdW5jdGlvbih0KXt2YXIgaSxlLG49dC5fb3JkZXI7biYmKGk9bi5uZXh0LChlPW4ucHJldikmJigoZS5uZXh0PWkpP2kucHJldj1lOmUmJih0aGlzLl9kcmF3TGFzdD1lKSxuLnByZXY9bnVsbCxuLm5leHQ9dGhpcy5fZHJhd0ZpcnN0LHRoaXMuX2RyYXdGaXJzdC5wcmV2PW4sdGhpcy5fZHJhd0ZpcnN0PW4sdGhpcy5fcmVxdWVzdFJlZHJhdyh0KSkpfX0pO2Z1bmN0aW9uIGxuKHQpe3JldHVybiBTdD9uZXcgdW4odCk6bnVsbH12YXIgY249ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKFwibHZtbFwiLFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIiksZnVuY3Rpb24odCl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCI8bHZtbDpcIit0KycgY2xhc3M9XCJsdm1sXCI+Jyl9fWNhdGNoKHQpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIjxcIit0KycgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpfX19KCksX249e19pbml0Q29udGFpbmVyOmZ1bmN0aW9uKCl7dGhpcy5fY29udGFpbmVyPXNpKFwiZGl2XCIsXCJsZWFmbGV0LXZtbC1jb250YWluZXJcIil9LF91cGRhdGU6ZnVuY3Rpb24oKXt0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb218fChobi5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpLHRoaXMuZmlyZShcInVwZGF0ZVwiKSl9LF9pbml0UGF0aDpmdW5jdGlvbih0KXt2YXIgaT10Ll9jb250YWluZXI9Y24oXCJzaGFwZVwiKTtjaShpLFwibGVhZmxldC12bWwtc2hhcGUgXCIrKHRoaXMub3B0aW9ucy5jbGFzc05hbWV8fFwiXCIpKSxpLmNvb3Jkc2l6ZT1cIjEgMVwiLHQuX3BhdGg9Y24oXCJwYXRoXCIpLGkuYXBwZW5kQ2hpbGQodC5fcGF0aCksdGhpcy5fdXBkYXRlU3R5bGUodCksdGhpcy5fbGF5ZXJzW20odCldPXR9LF9hZGRQYXRoOmZ1bmN0aW9uKHQpe3ZhciBpPXQuX2NvbnRhaW5lcjt0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoaSksdC5vcHRpb25zLmludGVyYWN0aXZlJiZ0LmFkZEludGVyYWN0aXZlVGFyZ2V0KGkpfSxfcmVtb3ZlUGF0aDpmdW5jdGlvbih0KXt2YXIgaT10Ll9jb250YWluZXI7cmkoaSksdC5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldChpKSxkZWxldGUgdGhpcy5fbGF5ZXJzW20odCldfSxfdXBkYXRlU3R5bGU6ZnVuY3Rpb24odCl7dmFyIGk9dC5fc3Ryb2tlLGU9dC5fZmlsbCxuPXQub3B0aW9ucyxvPXQuX2NvbnRhaW5lcjtvLnN0cm9rZWQ9ISFuLnN0cm9rZSxvLmZpbGxlZD0hIW4uZmlsbCxuLnN0cm9rZT8oaT1pfHwodC5fc3Ryb2tlPWNuKFwic3Ryb2tlXCIpKSxvLmFwcGVuZENoaWxkKGkpLGkud2VpZ2h0PW4ud2VpZ2h0K1wicHhcIixpLmNvbG9yPW4uY29sb3IsaS5vcGFjaXR5PW4ub3BhY2l0eSxuLmRhc2hBcnJheT9pLmRhc2hTdHlsZT1nKG4uZGFzaEFycmF5KT9uLmRhc2hBcnJheS5qb2luKFwiIFwiKTpuLmRhc2hBcnJheS5yZXBsYWNlKC8oICosICopL2csXCIgXCIpOmkuZGFzaFN0eWxlPVwiXCIsaS5lbmRjYXA9bi5saW5lQ2FwLnJlcGxhY2UoXCJidXR0XCIsXCJmbGF0XCIpLGkuam9pbnN0eWxlPW4ubGluZUpvaW4pOmkmJihvLnJlbW92ZUNoaWxkKGkpLHQuX3N0cm9rZT1udWxsKSxuLmZpbGw/KGU9ZXx8KHQuX2ZpbGw9Y24oXCJmaWxsXCIpKSxvLmFwcGVuZENoaWxkKGUpLGUuY29sb3I9bi5maWxsQ29sb3J8fG4uY29sb3IsZS5vcGFjaXR5PW4uZmlsbE9wYWNpdHkpOmUmJihvLnJlbW92ZUNoaWxkKGUpLHQuX2ZpbGw9bnVsbCl9LF91cGRhdGVDaXJjbGU6ZnVuY3Rpb24odCl7dmFyIGk9dC5fcG9pbnQucm91bmQoKSxlPU1hdGgucm91bmQodC5fcmFkaXVzKSxuPU1hdGgucm91bmQodC5fcmFkaXVzWXx8ZSk7dGhpcy5fc2V0UGF0aCh0LHQuX2VtcHR5KCk/XCJNMCAwXCI6XCJBTCBcIitpLngrXCIsXCIraS55K1wiIFwiK2UrXCIsXCIrbitcIiAwLDIzNTkyNjAwXCIpfSxfc2V0UGF0aDpmdW5jdGlvbih0LGkpe3QuX3BhdGgudj1pfSxfYnJpbmdUb0Zyb250OmZ1bmN0aW9uKHQpe2hpKHQuX2NvbnRhaW5lcil9LF9icmluZ1RvQmFjazpmdW5jdGlvbih0KXt1aSh0Ll9jb250YWluZXIpfX0sZG49RXQ/Y246Sixwbj1obi5leHRlbmQoe2dldEV2ZW50czpmdW5jdGlvbigpe3ZhciB0PWhuLnByb3RvdHlwZS5nZXRFdmVudHMuY2FsbCh0aGlzKTtyZXR1cm4gdC56b29tc3RhcnQ9dGhpcy5fb25ab29tU3RhcnQsdH0sX2luaXRDb250YWluZXI6ZnVuY3Rpb24oKXt0aGlzLl9jb250YWluZXI9ZG4oXCJzdmdcIiksdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpLHRoaXMuX3Jvb3RHcm91cD1kbihcImdcIiksdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3Jvb3RHcm91cCl9LF9kZXN0cm95Q29udGFpbmVyOmZ1bmN0aW9uKCl7cmkodGhpcy5fY29udGFpbmVyKSxTaSh0aGlzLl9jb250YWluZXIpLGRlbGV0ZSB0aGlzLl9jb250YWluZXIsZGVsZXRlIHRoaXMuX3Jvb3RHcm91cCxkZWxldGUgdGhpcy5fc3ZnU2l6ZX0sX29uWm9vbVN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlKCl9LF91cGRhdGU6ZnVuY3Rpb24oKXt2YXIgdCxpLGU7dGhpcy5fbWFwLl9hbmltYXRpbmdab29tJiZ0aGlzLl9ib3VuZHN8fChobi5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpLGk9KHQ9dGhpcy5fYm91bmRzKS5nZXRTaXplKCksZT10aGlzLl9jb250YWluZXIsdGhpcy5fc3ZnU2l6ZSYmdGhpcy5fc3ZnU2l6ZS5lcXVhbHMoaSl8fCh0aGlzLl9zdmdTaXplPWksZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLGkueCksZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIixpLnkpKSx2aShlLHQubWluKSxlLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIixbdC5taW4ueCx0Lm1pbi55LGkueCxpLnldLmpvaW4oXCIgXCIpKSx0aGlzLmZpcmUoXCJ1cGRhdGVcIikpfSxfaW5pdFBhdGg6ZnVuY3Rpb24odCl7dmFyIGk9dC5fcGF0aD1kbihcInBhdGhcIik7dC5vcHRpb25zLmNsYXNzTmFtZSYmY2koaSx0Lm9wdGlvbnMuY2xhc3NOYW1lKSx0Lm9wdGlvbnMuaW50ZXJhY3RpdmUmJmNpKGksXCJsZWFmbGV0LWludGVyYWN0aXZlXCIpLHRoaXMuX3VwZGF0ZVN0eWxlKHQpLHRoaXMuX2xheWVyc1ttKHQpXT10fSxfYWRkUGF0aDpmdW5jdGlvbih0KXt0aGlzLl9yb290R3JvdXB8fHRoaXMuX2luaXRDb250YWluZXIoKSx0aGlzLl9yb290R3JvdXAuYXBwZW5kQ2hpbGQodC5fcGF0aCksdC5hZGRJbnRlcmFjdGl2ZVRhcmdldCh0Ll9wYXRoKX0sX3JlbW92ZVBhdGg6ZnVuY3Rpb24odCl7cmkodC5fcGF0aCksdC5yZW1vdmVJbnRlcmFjdGl2ZVRhcmdldCh0Ll9wYXRoKSxkZWxldGUgdGhpcy5fbGF5ZXJzW20odCldfSxfdXBkYXRlUGF0aDpmdW5jdGlvbih0KXt0Ll9wcm9qZWN0KCksdC5fdXBkYXRlKCl9LF91cGRhdGVTdHlsZTpmdW5jdGlvbih0KXt2YXIgaT10Ll9wYXRoLGU9dC5vcHRpb25zO2kmJihlLnN0cm9rZT8oaS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIixlLmNvbG9yKSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS1vcGFjaXR5XCIsZS5vcGFjaXR5KSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLGUud2VpZ2h0KSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lY2FwXCIsZS5saW5lQ2FwKSxpLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLGUubGluZUpvaW4pLGUuZGFzaEFycmF5P2kuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGUuZGFzaEFycmF5KTppLnJlbW92ZUF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiksZS5kYXNoT2Zmc2V0P2kuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hvZmZzZXRcIixlLmRhc2hPZmZzZXQpOmkucmVtb3ZlQXR0cmlidXRlKFwic3Ryb2tlLWRhc2hvZmZzZXRcIikpOmkuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsXCJub25lXCIpLGUuZmlsbD8oaS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsZS5maWxsQ29sb3J8fGUuY29sb3IpLGkuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsZS5maWxsT3BhY2l0eSksaS5zZXRBdHRyaWJ1dGUoXCJmaWxsLXJ1bGVcIixlLmZpbGxSdWxlfHxcImV2ZW5vZGRcIikpOmkuc2V0QXR0cmlidXRlKFwiZmlsbFwiLFwibm9uZVwiKSl9LF91cGRhdGVQb2x5OmZ1bmN0aW9uKHQsaSl7dGhpcy5fc2V0UGF0aCh0LCQodC5fcGFydHMsaSkpfSxfdXBkYXRlQ2lyY2xlOmZ1bmN0aW9uKHQpe3ZhciBpPXQuX3BvaW50LGU9TWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXMpLDEpLG49XCJhXCIrZStcIixcIisoTWF0aC5tYXgoTWF0aC5yb3VuZCh0Ll9yYWRpdXNZKSwxKXx8ZSkrXCIgMCAxLDAgXCIsbz10Ll9lbXB0eSgpP1wiTTAgMFwiOlwiTVwiKyhpLngtZSkrXCIsXCIraS55K24rMiplK1wiLDAgXCIrbisyKi1lK1wiLDAgXCI7dGhpcy5fc2V0UGF0aCh0LG8pfSxfc2V0UGF0aDpmdW5jdGlvbih0LGkpe3QuX3BhdGguc2V0QXR0cmlidXRlKFwiZFwiLGkpfSxfYnJpbmdUb0Zyb250OmZ1bmN0aW9uKHQpe2hpKHQuX3BhdGgpfSxfYnJpbmdUb0JhY2s6ZnVuY3Rpb24odCl7dWkodC5fcGF0aCl9fSk7ZnVuY3Rpb24gbW4odCl7cmV0dXJuIFp0fHxFdD9uZXcgcG4odCk6bnVsbH1FdCYmcG4uaW5jbHVkZShfbiksS2kuaW5jbHVkZSh7Z2V0UmVuZGVyZXI6ZnVuY3Rpb24odCl7dmFyIGk9KGk9dC5vcHRpb25zLnJlbmRlcmVyfHx0aGlzLl9nZXRQYW5lUmVuZGVyZXIodC5vcHRpb25zLnBhbmUpfHx0aGlzLm9wdGlvbnMucmVuZGVyZXJ8fHRoaXMuX3JlbmRlcmVyKXx8KHRoaXMuX3JlbmRlcmVyPXRoaXMuX2NyZWF0ZVJlbmRlcmVyKCkpO3JldHVybiB0aGlzLmhhc0xheWVyKGkpfHx0aGlzLmFkZExheWVyKGkpLGl9LF9nZXRQYW5lUmVuZGVyZXI6ZnVuY3Rpb24odCl7aWYoXCJvdmVybGF5UGFuZVwiPT09dHx8dm9pZCAwPT09dClyZXR1cm4hMTt2YXIgaT10aGlzLl9wYW5lUmVuZGVyZXJzW3RdO3JldHVybiB2b2lkIDA9PT1pJiYoaT10aGlzLl9jcmVhdGVSZW5kZXJlcih7cGFuZTp0fSksdGhpcy5fcGFuZVJlbmRlcmVyc1t0XT1pKSxpfSxfY3JlYXRlUmVuZGVyZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3B0aW9ucy5wcmVmZXJDYW52YXMmJmxuKHQpfHxtbih0KX19KTt2YXIgZm49UmUuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQsaSl7UmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLHRoaXMuX2JvdW5kc1RvTGF0TG5ncyh0KSxpKX0sc2V0Qm91bmRzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKHQpKX0sX2JvdW5kc1RvTGF0TG5nczpmdW5jdGlvbih0KXtyZXR1cm5bKHQ9Tih0KSkuZ2V0U291dGhXZXN0KCksdC5nZXROb3J0aFdlc3QoKSx0LmdldE5vcnRoRWFzdCgpLHQuZ2V0U291dGhFYXN0KCldfX0pO3BuLmNyZWF0ZT1kbixwbi5wb2ludHNUb1BhdGg9JCxOZS5nZW9tZXRyeVRvTGF5ZXI9RGUsTmUuY29vcmRzVG9MYXRMbmc9V2UsTmUuY29vcmRzVG9MYXRMbmdzPUhlLE5lLmxhdExuZ1RvQ29vcmRzPUZlLE5lLmxhdExuZ3NUb0Nvb3Jkcz1VZSxOZS5nZXRGZWF0dXJlPVZlLE5lLmFzRmVhdHVyZT1xZSxLaS5tZXJnZU9wdGlvbnMoe2JveFpvb206ITB9KTt2YXIgZ249aWUuZXh0ZW5kKHtpbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX21hcD10LHRoaXMuX2NvbnRhaW5lcj10Ll9jb250YWluZXIsdGhpcy5fcGFuZT10Ll9wYW5lcy5vdmVybGF5UGFuZSx0aGlzLl9yZXNldFN0YXRlVGltZW91dD0wLHQub24oXCJ1bmxvYWRcIix0aGlzLl9kZXN0cm95LHRoaXMpfSxhZGRIb29rczpmdW5jdGlvbigpe3ppKHRoaXMuX2NvbnRhaW5lcixcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpfSxyZW1vdmVIb29rczpmdW5jdGlvbigpe1NpKHRoaXMuX2NvbnRhaW5lcixcIm1vdXNlZG93blwiLHRoaXMuX29uTW91c2VEb3duLHRoaXMpfSxtb3ZlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tb3ZlZH0sX2Rlc3Ryb3k6ZnVuY3Rpb24oKXtyaSh0aGlzLl9wYW5lKSxkZWxldGUgdGhpcy5fcGFuZX0sX3Jlc2V0U3RhdGU6ZnVuY3Rpb24oKXt0aGlzLl9yZXNldFN0YXRlVGltZW91dD0wLHRoaXMuX21vdmVkPSExfSxfY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGU6ZnVuY3Rpb24oKXswIT09dGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQpLHRoaXMuX3Jlc2V0U3RhdGVUaW1lb3V0PTApfSxfb25Nb3VzZURvd246ZnVuY3Rpb24odCl7aWYoIXQuc2hpZnRLZXl8fDEhPT10LndoaWNoJiYxIT09dC5idXR0b24pcmV0dXJuITE7dGhpcy5fY2xlYXJEZWZlcnJlZFJlc2V0U3RhdGUoKSx0aGlzLl9yZXNldFN0YXRlKCksWHQoKSx4aSgpLHRoaXMuX3N0YXJ0UG9pbnQ9dGhpcy5fbWFwLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KHQpLHppKGRvY3VtZW50LHtjb250ZXh0bWVudTpOaSxtb3VzZW1vdmU6dGhpcy5fb25Nb3VzZU1vdmUsbW91c2V1cDp0aGlzLl9vbk1vdXNlVXAsa2V5ZG93bjp0aGlzLl9vbktleURvd259LHRoaXMpfSxfb25Nb3VzZU1vdmU6ZnVuY3Rpb24odCl7dGhpcy5fbW92ZWR8fCh0aGlzLl9tb3ZlZD0hMCx0aGlzLl9ib3g9c2koXCJkaXZcIixcImxlYWZsZXQtem9vbS1ib3hcIix0aGlzLl9jb250YWluZXIpLGNpKHRoaXMuX2NvbnRhaW5lcixcImxlYWZsZXQtY3Jvc3NoYWlyXCIpLHRoaXMuX21hcC5maXJlKFwiYm94em9vbXN0YXJ0XCIpKSx0aGlzLl9wb2ludD10aGlzLl9tYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodCk7dmFyIGk9bmV3IEkodGhpcy5fcG9pbnQsdGhpcy5fc3RhcnRQb2ludCksZT1pLmdldFNpemUoKTt2aSh0aGlzLl9ib3gsaS5taW4pLHRoaXMuX2JveC5zdHlsZS53aWR0aD1lLngrXCJweFwiLHRoaXMuX2JveC5zdHlsZS5oZWlnaHQ9ZS55K1wicHhcIn0sX2ZpbmlzaDpmdW5jdGlvbigpe3RoaXMuX21vdmVkJiYocmkodGhpcy5fYm94KSxfaSh0aGlzLl9jb250YWluZXIsXCJsZWFmbGV0LWNyb3NzaGFpclwiKSksSnQoKSx3aSgpLFNpKGRvY3VtZW50LHtjb250ZXh0bWVudTpOaSxtb3VzZW1vdmU6dGhpcy5fb25Nb3VzZU1vdmUsbW91c2V1cDp0aGlzLl9vbk1vdXNlVXAsa2V5ZG93bjp0aGlzLl9vbktleURvd259LHRoaXMpfSxfb25Nb3VzZVVwOmZ1bmN0aW9uKHQpe3ZhciBpOzEhPT10LndoaWNoJiYxIT09dC5idXR0b258fCh0aGlzLl9maW5pc2goKSx0aGlzLl9tb3ZlZCYmKHRoaXMuX2NsZWFyRGVmZXJyZWRSZXNldFN0YXRlKCksdGhpcy5fcmVzZXRTdGF0ZVRpbWVvdXQ9c2V0VGltZW91dChwKHRoaXMuX3Jlc2V0U3RhdGUsdGhpcyksMCksaT1uZXcgUih0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9zdGFydFBvaW50KSx0aGlzLl9tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyh0aGlzLl9wb2ludCkpLHRoaXMuX21hcC5maXRCb3VuZHMoaSkuZmlyZShcImJveHpvb21lbmRcIix7Ym94Wm9vbUJvdW5kczppfSkpKX0sX29uS2V5RG93bjpmdW5jdGlvbih0KXsyNz09PXQua2V5Q29kZSYmdGhpcy5fZmluaXNoKCl9fSk7S2kuYWRkSW5pdEhvb2soXCJhZGRIYW5kbGVyXCIsXCJib3hab29tXCIsZ24pLEtpLm1lcmdlT3B0aW9ucyh7ZG91YmxlQ2xpY2tab29tOiEwfSk7dmFyIHZuPWllLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXt0aGlzLl9tYXAub24oXCJkYmxjbGlja1wiLHRoaXMuX29uRG91YmxlQ2xpY2ssdGhpcyl9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7dGhpcy5fbWFwLm9mZihcImRibGNsaWNrXCIsdGhpcy5fb25Eb3VibGVDbGljayx0aGlzKX0sX29uRG91YmxlQ2xpY2s6ZnVuY3Rpb24odCl7dmFyIGk9dGhpcy5fbWFwLGU9aS5nZXRab29tKCksbj1pLm9wdGlvbnMuem9vbURlbHRhLG89dC5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5P2UtbjplK247XCJjZW50ZXJcIj09PWkub3B0aW9ucy5kb3VibGVDbGlja1pvb20/aS5zZXRab29tKG8pOmkuc2V0Wm9vbUFyb3VuZCh0LmNvbnRhaW5lclBvaW50LG8pfX0pO0tpLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwiZG91YmxlQ2xpY2tab29tXCIsdm4pLEtpLm1lcmdlT3B0aW9ucyh7ZHJhZ2dpbmc6ITAsaW5lcnRpYTohc3QsaW5lcnRpYURlY2VsZXJhdGlvbjozNDAwLGluZXJ0aWFNYXhTcGVlZDoxLzAsZWFzZUxpbmVhcml0eTouMix3b3JsZENvcHlKdW1wOiExLG1heEJvdW5kc1Zpc2Nvc2l0eTowfSk7dmFyIHluPWllLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXt2YXIgdDt0aGlzLl9kcmFnZ2FibGV8fCh0PXRoaXMuX21hcCx0aGlzLl9kcmFnZ2FibGU9bmV3IGFlKHQuX21hcFBhbmUsdC5fY29udGFpbmVyKSx0aGlzLl9kcmFnZ2FibGUub24oe2RyYWdzdGFydDp0aGlzLl9vbkRyYWdTdGFydCxkcmFnOnRoaXMuX29uRHJhZyxkcmFnZW5kOnRoaXMuX29uRHJhZ0VuZH0sdGhpcyksdGhpcy5fZHJhZ2dhYmxlLm9uKFwicHJlZHJhZ1wiLHRoaXMuX29uUHJlRHJhZ0xpbWl0LHRoaXMpLHQub3B0aW9ucy53b3JsZENvcHlKdW1wJiYodGhpcy5fZHJhZ2dhYmxlLm9uKFwicHJlZHJhZ1wiLHRoaXMuX29uUHJlRHJhZ1dyYXAsdGhpcyksdC5vbihcInpvb21lbmRcIix0aGlzLl9vblpvb21FbmQsdGhpcyksdC53aGVuUmVhZHkodGhpcy5fb25ab29tRW5kLHRoaXMpKSksY2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LWdyYWIgbGVhZmxldC10b3VjaC1kcmFnXCIpLHRoaXMuX2RyYWdnYWJsZS5lbmFibGUoKSx0aGlzLl9wb3NpdGlvbnM9W10sdGhpcy5fdGltZXM9W119LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7X2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LWdyYWJcIiksX2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LXRvdWNoLWRyYWdcIiksdGhpcy5fZHJhZ2dhYmxlLmRpc2FibGUoKX0sbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlJiZ0aGlzLl9kcmFnZ2FibGUuX21vdmVkfSxtb3Zpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZHJhZ2dhYmxlJiZ0aGlzLl9kcmFnZ2FibGUuX21vdmluZ30sX29uRHJhZ1N0YXJ0OmZ1bmN0aW9uKCl7dmFyIHQsaT10aGlzLl9tYXA7aS5fc3RvcCgpLHRoaXMuX21hcC5vcHRpb25zLm1heEJvdW5kcyYmdGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzVmlzY29zaXR5Pyh0PU4odGhpcy5fbWFwLm9wdGlvbnMubWF4Qm91bmRzKSx0aGlzLl9vZmZzZXRMaW1pdD1PKHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHQuZ2V0Tm9ydGhXZXN0KCkpLm11bHRpcGx5QnkoLTEpLHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHQuZ2V0U291dGhFYXN0KCkpLm11bHRpcGx5QnkoLTEpLmFkZCh0aGlzLl9tYXAuZ2V0U2l6ZSgpKSksdGhpcy5fdmlzY29zaXR5PU1hdGgubWluKDEsTWF0aC5tYXgoMCx0aGlzLl9tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkpKSk6dGhpcy5fb2Zmc2V0TGltaXQ9bnVsbCxpLmZpcmUoXCJtb3Zlc3RhcnRcIikuZmlyZShcImRyYWdzdGFydFwiKSxpLm9wdGlvbnMuaW5lcnRpYSYmKHRoaXMuX3Bvc2l0aW9ucz1bXSx0aGlzLl90aW1lcz1bXSl9LF9vbkRyYWc6ZnVuY3Rpb24odCl7dmFyIGksZTt0aGlzLl9tYXAub3B0aW9ucy5pbmVydGlhJiYoaT10aGlzLl9sYXN0VGltZT0rbmV3IERhdGUsZT10aGlzLl9sYXN0UG9zPXRoaXMuX2RyYWdnYWJsZS5fYWJzUG9zfHx0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcyx0aGlzLl9wb3NpdGlvbnMucHVzaChlKSx0aGlzLl90aW1lcy5wdXNoKGkpLHRoaXMuX3BydW5lUG9zaXRpb25zKGkpKSx0aGlzLl9tYXAuZmlyZShcIm1vdmVcIix0KS5maXJlKFwiZHJhZ1wiLHQpfSxfcHJ1bmVQb3NpdGlvbnM6ZnVuY3Rpb24odCl7Zm9yKDsxPHRoaXMuX3Bvc2l0aW9ucy5sZW5ndGgmJjUwPHQtdGhpcy5fdGltZXNbMF07KXRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpLHRoaXMuX3RpbWVzLnNoaWZ0KCl9LF9vblpvb21FbmQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLGk9dGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChbMCwwXSk7dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0PWkuc3VidHJhY3QodCkueCx0aGlzLl93b3JsZFdpZHRoPXRoaXMuX21hcC5nZXRQaXhlbFdvcmxkQm91bmRzKCkuZ2V0U2l6ZSgpLnh9LF92aXNjb3VzTGltaXQ6ZnVuY3Rpb24odCxpKXtyZXR1cm4gdC0odC1pKSp0aGlzLl92aXNjb3NpdHl9LF9vblByZURyYWdMaW1pdDpmdW5jdGlvbigpe3ZhciB0LGk7dGhpcy5fdmlzY29zaXR5JiZ0aGlzLl9vZmZzZXRMaW1pdCYmKHQ9dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3Muc3VidHJhY3QodGhpcy5fZHJhZ2dhYmxlLl9zdGFydFBvcyksaT10aGlzLl9vZmZzZXRMaW1pdCx0Lng8aS5taW4ueCYmKHQueD10aGlzLl92aXNjb3VzTGltaXQodC54LGkubWluLngpKSx0Lnk8aS5taW4ueSYmKHQueT10aGlzLl92aXNjb3VzTGltaXQodC55LGkubWluLnkpKSx0Lng+aS5tYXgueCYmKHQueD10aGlzLl92aXNjb3VzTGltaXQodC54LGkubWF4LngpKSx0Lnk+aS5tYXgueSYmKHQueT10aGlzLl92aXNjb3VzTGltaXQodC55LGkubWF4LnkpKSx0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcz10aGlzLl9kcmFnZ2FibGUuX3N0YXJ0UG9zLmFkZCh0KSl9LF9vblByZURyYWdXcmFwOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fd29ybGRXaWR0aCxpPU1hdGgucm91bmQodC8yKSxlPXRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxuPXRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLngsbz0obi1pK2UpJXQraS1lLHM9KG4raStlKSV0LWktZSxyPU1hdGguYWJzKG8rZSk8TWF0aC5hYnMocytlKT9vOnM7dGhpcy5fZHJhZ2dhYmxlLl9hYnNQb3M9dGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MuY2xvbmUoKSx0aGlzLl9kcmFnZ2FibGUuX25ld1Bvcy54PXJ9LF9vbkRyYWdFbmQ6ZnVuY3Rpb24odCl7dmFyIGksZSxuLG8scyxyLGEsaCx1LGw9dGhpcy5fbWFwLGM9bC5vcHRpb25zLF89IWMuaW5lcnRpYXx8dGhpcy5fdGltZXMubGVuZ3RoPDI7bC5maXJlKFwiZHJhZ2VuZFwiLHQpLF8/bC5maXJlKFwibW92ZWVuZFwiKToodGhpcy5fcHJ1bmVQb3NpdGlvbnMoK25ldyBEYXRlKSxpPXRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxlPSh0aGlzLl9sYXN0VGltZS10aGlzLl90aW1lc1swXSkvMWUzLG49Yy5lYXNlTGluZWFyaXR5LHM9KG89aS5tdWx0aXBseUJ5KG4vZSkpLmRpc3RhbmNlVG8oWzAsMF0pLHI9TWF0aC5taW4oYy5pbmVydGlhTWF4U3BlZWQscyksYT1vLm11bHRpcGx5Qnkoci9zKSxoPXIvKGMuaW5lcnRpYURlY2VsZXJhdGlvbipuKSwodT1hLm11bHRpcGx5QnkoLWgvMikucm91bmQoKSkueHx8dS55Pyh1PWwuX2xpbWl0T2Zmc2V0KHUsbC5vcHRpb25zLm1heEJvdW5kcyksTShmdW5jdGlvbigpe2wucGFuQnkodSx7ZHVyYXRpb246aCxlYXNlTGluZWFyaXR5Om4sbm9Nb3ZlU3RhcnQ6ITAsYW5pbWF0ZTohMH0pfSkpOmwuZmlyZShcIm1vdmVlbmRcIikpfX0pO0tpLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwiZHJhZ2dpbmdcIix5biksS2kubWVyZ2VPcHRpb25zKHtrZXlib2FyZDohMCxrZXlib2FyZFBhbkRlbHRhOjgwfSk7dmFyIHhuPWllLmV4dGVuZCh7a2V5Q29kZXM6e2xlZnQ6WzM3XSxyaWdodDpbMzldLGRvd246WzQwXSx1cDpbMzhdLHpvb21JbjpbMTg3LDEwNyw2MSwxNzFdLHpvb21PdXQ6WzE4OSwxMDksNTQsMTczXX0saW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl9tYXA9dCx0aGlzLl9zZXRQYW5EZWx0YSh0Lm9wdGlvbnMua2V5Ym9hcmRQYW5EZWx0YSksdGhpcy5fc2V0Wm9vbURlbHRhKHQub3B0aW9ucy56b29tRGVsdGEpfSxhZGRIb29rczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX21hcC5fY29udGFpbmVyO3QudGFiSW5kZXg8PTAmJih0LnRhYkluZGV4PVwiMFwiKSx6aSh0LHtmb2N1czp0aGlzLl9vbkZvY3VzLGJsdXI6dGhpcy5fb25CbHVyLG1vdXNlZG93bjp0aGlzLl9vbk1vdXNlRG93bn0sdGhpcyksdGhpcy5fbWFwLm9uKHtmb2N1czp0aGlzLl9hZGRIb29rcyxibHVyOnRoaXMuX3JlbW92ZUhvb2tzfSx0aGlzKX0scmVtb3ZlSG9va3M6ZnVuY3Rpb24oKXt0aGlzLl9yZW1vdmVIb29rcygpLFNpKHRoaXMuX21hcC5fY29udGFpbmVyLHtmb2N1czp0aGlzLl9vbkZvY3VzLGJsdXI6dGhpcy5fb25CbHVyLG1vdXNlZG93bjp0aGlzLl9vbk1vdXNlRG93bn0sdGhpcyksdGhpcy5fbWFwLm9mZih7Zm9jdXM6dGhpcy5fYWRkSG9va3MsYmx1cjp0aGlzLl9yZW1vdmVIb29rc30sdGhpcyl9LF9vbk1vdXNlRG93bjpmdW5jdGlvbigpe3ZhciB0LGksZSxuO3RoaXMuX2ZvY3VzZWR8fCh0PWRvY3VtZW50LmJvZHksaT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsZT10LnNjcm9sbFRvcHx8aS5zY3JvbGxUb3Asbj10LnNjcm9sbExlZnR8fGkuc2Nyb2xsTGVmdCx0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpLHdpbmRvdy5zY3JvbGxUbyhuLGUpKX0sX29uRm9jdXM6ZnVuY3Rpb24oKXt0aGlzLl9mb2N1c2VkPSEwLHRoaXMuX21hcC5maXJlKFwiZm9jdXNcIil9LF9vbkJsdXI6ZnVuY3Rpb24oKXt0aGlzLl9mb2N1c2VkPSExLHRoaXMuX21hcC5maXJlKFwiYmx1clwiKX0sX3NldFBhbkRlbHRhOmZ1bmN0aW9uKHQpe2Zvcih2YXIgaT10aGlzLl9wYW5LZXlzPXt9LGU9dGhpcy5rZXlDb2RlcyxuPTAsbz1lLmxlZnQubGVuZ3RoO248bztuKyspaVtlLmxlZnRbbl1dPVstMSp0LDBdO2ZvcihuPTAsbz1lLnJpZ2h0Lmxlbmd0aDtuPG87bisrKWlbZS5yaWdodFtuXV09W3QsMF07Zm9yKG49MCxvPWUuZG93bi5sZW5ndGg7bjxvO24rKylpW2UuZG93bltuXV09WzAsdF07Zm9yKG49MCxvPWUudXAubGVuZ3RoO248bztuKyspaVtlLnVwW25dXT1bMCwtMSp0XX0sX3NldFpvb21EZWx0YTpmdW5jdGlvbih0KXtmb3IodmFyIGk9dGhpcy5fem9vbUtleXM9e30sZT10aGlzLmtleUNvZGVzLG49MCxvPWUuem9vbUluLmxlbmd0aDtuPG87bisrKWlbZS56b29tSW5bbl1dPXQ7Zm9yKG49MCxvPWUuem9vbU91dC5sZW5ndGg7bjxvO24rKylpW2Uuem9vbU91dFtuXV09LXR9LF9hZGRIb29rczpmdW5jdGlvbigpe3ppKGRvY3VtZW50LFwia2V5ZG93blwiLHRoaXMuX29uS2V5RG93bix0aGlzKX0sX3JlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7U2koZG9jdW1lbnQsXCJrZXlkb3duXCIsdGhpcy5fb25LZXlEb3duLHRoaXMpfSxfb25LZXlEb3duOmZ1bmN0aW9uKHQpe2lmKCEodC5hbHRLZXl8fHQuY3RybEtleXx8dC5tZXRhS2V5KSl7dmFyIGksZT10LmtleUNvZGUsbj10aGlzLl9tYXA7aWYoZSBpbiB0aGlzLl9wYW5LZXlzKW4uX3BhbkFuaW0mJm4uX3BhbkFuaW0uX2luUHJvZ3Jlc3N8fChpPXRoaXMuX3BhbktleXNbZV0sdC5zaGlmdEtleSYmKGk9QShpKS5tdWx0aXBseUJ5KDMpKSxuLnBhbkJ5KGkpLG4ub3B0aW9ucy5tYXhCb3VuZHMmJm4ucGFuSW5zaWRlQm91bmRzKG4ub3B0aW9ucy5tYXhCb3VuZHMpKTtlbHNlIGlmKGUgaW4gdGhpcy5fem9vbUtleXMpbi5zZXRab29tKG4uZ2V0Wm9vbSgpKyh0LnNoaWZ0S2V5PzM6MSkqdGhpcy5fem9vbUtleXNbZV0pO2Vsc2V7aWYoMjchPT1lfHwhbi5fcG9wdXB8fCFuLl9wb3B1cC5vcHRpb25zLmNsb3NlT25Fc2NhcGVLZXkpcmV0dXJuO24uY2xvc2VQb3B1cCgpfU5pKHQpfX19KTtLaS5hZGRJbml0SG9vayhcImFkZEhhbmRsZXJcIixcImtleWJvYXJkXCIseG4pLEtpLm1lcmdlT3B0aW9ucyh7c2Nyb2xsV2hlZWxab29tOiEwLHdoZWVsRGVib3VuY2VUaW1lOjQwLHdoZWVsUHhQZXJab29tTGV2ZWw6NjB9KTt2YXIgd249aWUuZXh0ZW5kKHthZGRIb29rczpmdW5jdGlvbigpe3ppKHRoaXMuX21hcC5fY29udGFpbmVyLFwid2hlZWxcIix0aGlzLl9vbldoZWVsU2Nyb2xsLHRoaXMpLHRoaXMuX2RlbHRhPTB9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7U2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJ3aGVlbFwiLHRoaXMuX29uV2hlZWxTY3JvbGwsdGhpcyl9LF9vbldoZWVsU2Nyb2xsOmZ1bmN0aW9uKHQpe3ZhciBpPVdpKHQpLGU9dGhpcy5fbWFwLm9wdGlvbnMud2hlZWxEZWJvdW5jZVRpbWU7dGhpcy5fZGVsdGErPWksdGhpcy5fbGFzdE1vdXNlUG9zPXRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0KSx0aGlzLl9zdGFydFRpbWV8fCh0aGlzLl9zdGFydFRpbWU9K25ldyBEYXRlKTt2YXIgbj1NYXRoLm1heChlLShuZXcgRGF0ZS10aGlzLl9zdGFydFRpbWUpLDApO2NsZWFyVGltZW91dCh0aGlzLl90aW1lciksdGhpcy5fdGltZXI9c2V0VGltZW91dChwKHRoaXMuX3BlcmZvcm1ab29tLHRoaXMpLG4pLE5pKHQpfSxfcGVyZm9ybVpvb206ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9tYXAsaT10LmdldFpvb20oKSxlPXRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwfHwwO3QuX3N0b3AoKTt2YXIgbj10aGlzLl9kZWx0YS8oNCp0aGlzLl9tYXAub3B0aW9ucy53aGVlbFB4UGVyWm9vbUxldmVsKSxvPTQqTWF0aC5sb2coMi8oMStNYXRoLmV4cCgtTWF0aC5hYnMobikpKSkvTWF0aC5MTjIscz1lP01hdGguY2VpbChvL2UpKmU6byxyPXQuX2xpbWl0Wm9vbShpKygwPHRoaXMuX2RlbHRhP3M6LXMpKS1pO3RoaXMuX2RlbHRhPTAsdGhpcy5fc3RhcnRUaW1lPW51bGwsciYmKFwiY2VudGVyXCI9PT10Lm9wdGlvbnMuc2Nyb2xsV2hlZWxab29tP3Quc2V0Wm9vbShpK3IpOnQuc2V0Wm9vbUFyb3VuZCh0aGlzLl9sYXN0TW91c2VQb3MsaStyKSl9fSk7S2kuYWRkSW5pdEhvb2soXCJhZGRIYW5kbGVyXCIsXCJzY3JvbGxXaGVlbFpvb21cIix3biksS2kubWVyZ2VPcHRpb25zKHt0YXA6ITAsdGFwVG9sZXJhbmNlOjE1fSk7dmFyIFBuPWllLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXt6aSh0aGlzLl9tYXAuX2NvbnRhaW5lcixcInRvdWNoc3RhcnRcIix0aGlzLl9vbkRvd24sdGhpcyl9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7U2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Eb3duLHRoaXMpfSxfb25Eb3duOmZ1bmN0aW9uKHQpe2lmKHQudG91Y2hlcyl7aWYoUmkodCksdGhpcy5fZmlyZUNsaWNrPSEwLDE8dC50b3VjaGVzLmxlbmd0aClyZXR1cm4gdGhpcy5fZmlyZUNsaWNrPSExLHZvaWQgY2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTt2YXIgaT10LnRvdWNoZXNbMF0sZT1pLnRhcmdldDt0aGlzLl9zdGFydFBvcz10aGlzLl9uZXdQb3M9bmV3IGsoaS5jbGllbnRYLGkuY2xpZW50WSksZS50YWdOYW1lJiZcImFcIj09PWUudGFnTmFtZS50b0xvd2VyQ2FzZSgpJiZjaShlLFwibGVhZmxldC1hY3RpdmVcIiksdGhpcy5faG9sZFRpbWVvdXQ9c2V0VGltZW91dChwKGZ1bmN0aW9uKCl7dGhpcy5faXNUYXBWYWxpZCgpJiYodGhpcy5fZmlyZUNsaWNrPSExLHRoaXMuX29uVXAoKSx0aGlzLl9zaW11bGF0ZUV2ZW50KFwiY29udGV4dG1lbnVcIixpKSl9LHRoaXMpLDFlMyksdGhpcy5fc2ltdWxhdGVFdmVudChcIm1vdXNlZG93blwiLGkpLHppKGRvY3VtZW50LHt0b3VjaG1vdmU6dGhpcy5fb25Nb3ZlLHRvdWNoZW5kOnRoaXMuX29uVXB9LHRoaXMpfX0sX29uVXA6ZnVuY3Rpb24odCl7dmFyIGksZTtjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpLFNpKGRvY3VtZW50LHt0b3VjaG1vdmU6dGhpcy5fb25Nb3ZlLHRvdWNoZW5kOnRoaXMuX29uVXB9LHRoaXMpLHRoaXMuX2ZpcmVDbGljayYmdCYmdC5jaGFuZ2VkVG91Y2hlcyYmKChlPShpPXQuY2hhbmdlZFRvdWNoZXNbMF0pLnRhcmdldCkmJmUudGFnTmFtZSYmXCJhXCI9PT1lLnRhZ05hbWUudG9Mb3dlckNhc2UoKSYmX2koZSxcImxlYWZsZXQtYWN0aXZlXCIpLHRoaXMuX3NpbXVsYXRlRXZlbnQoXCJtb3VzZXVwXCIsaSksdGhpcy5faXNUYXBWYWxpZCgpJiZ0aGlzLl9zaW11bGF0ZUV2ZW50KFwiY2xpY2tcIixpKSl9LF9pc1RhcFZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25ld1Bvcy5kaXN0YW5jZVRvKHRoaXMuX3N0YXJ0UG9zKTw9dGhpcy5fbWFwLm9wdGlvbnMudGFwVG9sZXJhbmNlfSxfb25Nb3ZlOmZ1bmN0aW9uKHQpe3ZhciBpPXQudG91Y2hlc1swXTt0aGlzLl9uZXdQb3M9bmV3IGsoaS5jbGllbnRYLGkuY2xpZW50WSksdGhpcy5fc2ltdWxhdGVFdmVudChcIm1vdXNlbW92ZVwiLGkpfSxfc2ltdWxhdGVFdmVudDpmdW5jdGlvbih0LGkpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7ZS5fc2ltdWxhdGVkPSEwLGkudGFyZ2V0Ll9zaW11bGF0ZWRDbGljaz0hMCxlLmluaXRNb3VzZUV2ZW50KHQsITAsITAsd2luZG93LDEsaS5zY3JlZW5YLGkuc2NyZWVuWSxpLmNsaWVudFgsaS5jbGllbnRZLCExLCExLCExLCExLDAsbnVsbCksaS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKX19KTshYnR8fEx0JiYhY3R8fEtpLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwidGFwXCIsUG4pLEtpLm1lcmdlT3B0aW9ucyh7dG91Y2hab29tOmJ0JiYhc3QsYm91bmNlQXRab29tTGltaXRzOiEwfSk7dmFyIExuPWllLmV4dGVuZCh7YWRkSG9va3M6ZnVuY3Rpb24oKXtjaSh0aGlzLl9tYXAuX2NvbnRhaW5lcixcImxlYWZsZXQtdG91Y2gtem9vbVwiKSx6aSh0aGlzLl9tYXAuX2NvbnRhaW5lcixcInRvdWNoc3RhcnRcIix0aGlzLl9vblRvdWNoU3RhcnQsdGhpcyl9LHJlbW92ZUhvb2tzOmZ1bmN0aW9uKCl7X2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJsZWFmbGV0LXRvdWNoLXpvb21cIiksU2kodGhpcy5fbWFwLl9jb250YWluZXIsXCJ0b3VjaHN0YXJ0XCIsdGhpcy5fb25Ub3VjaFN0YXJ0LHRoaXMpfSxfb25Ub3VjaFN0YXJ0OmZ1bmN0aW9uKHQpe3ZhciBpLGUsbj10aGlzLl9tYXA7IXQudG91Y2hlc3x8MiE9PXQudG91Y2hlcy5sZW5ndGh8fG4uX2FuaW1hdGluZ1pvb218fHRoaXMuX3pvb21pbmd8fChpPW4ubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodC50b3VjaGVzWzBdKSxlPW4ubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQodC50b3VjaGVzWzFdKSx0aGlzLl9jZW50ZXJQb2ludD1uLmdldFNpemUoKS5fZGl2aWRlQnkoMiksdGhpcy5fc3RhcnRMYXRMbmc9bi5jb250YWluZXJQb2ludFRvTGF0TG5nKHRoaXMuX2NlbnRlclBvaW50KSxcImNlbnRlclwiIT09bi5vcHRpb25zLnRvdWNoWm9vbSYmKHRoaXMuX3BpbmNoU3RhcnRMYXRMbmc9bi5jb250YWluZXJQb2ludFRvTGF0TG5nKGkuYWRkKGUpLl9kaXZpZGVCeSgyKSkpLHRoaXMuX3N0YXJ0RGlzdD1pLmRpc3RhbmNlVG8oZSksdGhpcy5fc3RhcnRab29tPW4uZ2V0Wm9vbSgpLHRoaXMuX21vdmVkPSExLHRoaXMuX3pvb21pbmc9ITAsbi5fc3RvcCgpLHppKGRvY3VtZW50LFwidG91Y2htb3ZlXCIsdGhpcy5fb25Ub3VjaE1vdmUsdGhpcyksemkoZG9jdW1lbnQsXCJ0b3VjaGVuZFwiLHRoaXMuX29uVG91Y2hFbmQsdGhpcyksUmkodCkpfSxfb25Ub3VjaE1vdmU6ZnVuY3Rpb24odCl7aWYodC50b3VjaGVzJiYyPT09dC50b3VjaGVzLmxlbmd0aCYmdGhpcy5fem9vbWluZyl7dmFyIGk9dGhpcy5fbWFwLGU9aS5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0LnRvdWNoZXNbMF0pLG49aS5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludCh0LnRvdWNoZXNbMV0pLG89ZS5kaXN0YW5jZVRvKG4pL3RoaXMuX3N0YXJ0RGlzdDtpZih0aGlzLl96b29tPWkuZ2V0U2NhbGVab29tKG8sdGhpcy5fc3RhcnRab29tKSwhaS5vcHRpb25zLmJvdW5jZUF0Wm9vbUxpbWl0cyYmKHRoaXMuX3pvb208aS5nZXRNaW5ab29tKCkmJm88MXx8dGhpcy5fem9vbT5pLmdldE1heFpvb20oKSYmMTxvKSYmKHRoaXMuX3pvb209aS5fbGltaXRab29tKHRoaXMuX3pvb20pKSxcImNlbnRlclwiPT09aS5vcHRpb25zLnRvdWNoWm9vbSl7aWYodGhpcy5fY2VudGVyPXRoaXMuX3N0YXJ0TGF0TG5nLDE9PW8pcmV0dXJufWVsc2V7dmFyIHM9ZS5fYWRkKG4pLl9kaXZpZGVCeSgyKS5fc3VidHJhY3QodGhpcy5fY2VudGVyUG9pbnQpO2lmKDE9PW8mJjA9PT1zLngmJjA9PT1zLnkpcmV0dXJuO3RoaXMuX2NlbnRlcj1pLnVucHJvamVjdChpLnByb2plY3QodGhpcy5fcGluY2hTdGFydExhdExuZyx0aGlzLl96b29tKS5zdWJ0cmFjdChzKSx0aGlzLl96b29tKX10aGlzLl9tb3ZlZHx8KGkuX21vdmVTdGFydCghMCwhMSksdGhpcy5fbW92ZWQ9ITApLHoodGhpcy5fYW5pbVJlcXVlc3QpO3ZhciByPXAoaS5fbW92ZSxpLHRoaXMuX2NlbnRlcix0aGlzLl96b29tLHtwaW5jaDohMCxyb3VuZDohMX0pO3RoaXMuX2FuaW1SZXF1ZXN0PU0ocix0aGlzLCEwKSxSaSh0KX19LF9vblRvdWNoRW5kOmZ1bmN0aW9uKCl7dGhpcy5fbW92ZWQmJnRoaXMuX3pvb21pbmc/KHRoaXMuX3pvb21pbmc9ITEseih0aGlzLl9hbmltUmVxdWVzdCksU2koZG9jdW1lbnQsXCJ0b3VjaG1vdmVcIix0aGlzLl9vblRvdWNoTW92ZSx0aGlzKSxTaShkb2N1bWVudCxcInRvdWNoZW5kXCIsdGhpcy5fb25Ub3VjaEVuZCx0aGlzKSx0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uP3RoaXMuX21hcC5fYW5pbWF0ZVpvb20odGhpcy5fY2VudGVyLHRoaXMuX21hcC5fbGltaXRab29tKHRoaXMuX3pvb20pLCEwLHRoaXMuX21hcC5vcHRpb25zLnpvb21TbmFwKTp0aGlzLl9tYXAuX3Jlc2V0Vmlldyh0aGlzLl9jZW50ZXIsdGhpcy5fbWFwLl9saW1pdFpvb20odGhpcy5fem9vbSkpKTp0aGlzLl96b29taW5nPSExfX0pO0tpLmFkZEluaXRIb29rKFwiYWRkSGFuZGxlclwiLFwidG91Y2hab29tXCIsTG4pLEtpLkJveFpvb209Z24sS2kuRG91YmxlQ2xpY2tab29tPXZuLEtpLkRyYWc9eW4sS2kuS2V5Ym9hcmQ9eG4sS2kuU2Nyb2xsV2hlZWxab29tPXduLEtpLlRhcD1QbixLaS5Ub3VjaFpvb209TG4sdC52ZXJzaW9uPVwiMS43LjFcIix0LkNvbnRyb2w9WGksdC5jb250cm9sPVlpLHQuQnJvd3Nlcj1CdCx0LkV2ZW50ZWQ9RSx0Lk1peGluPW5lLHQuVXRpbD1DLHQuQ2xhc3M9Uyx0LkhhbmRsZXI9aWUsdC5leHRlbmQ9aCx0LmJpbmQ9cCx0LnN0YW1wPW0sdC5zZXRPcHRpb25zPWMsdC5Eb21FdmVudD1xaSx0LkRvbVV0aWw9TWksdC5Qb3NBbmltYXRpb249R2ksdC5EcmFnZ2FibGU9YWUsdC5MaW5lVXRpbD1mZSx0LlBvbHlVdGlsPXllLHQuUG9pbnQ9ayx0LnBvaW50PUEsdC5Cb3VuZHM9SSx0LmJvdW5kcz1PLHQuVHJhbnNmb3JtYXRpb249cSx0LnRyYW5zZm9ybWF0aW9uPUcsdC5Qcm9qZWN0aW9uPVBlLHQuTGF0TG5nPUQsdC5sYXRMbmc9aix0LkxhdExuZ0JvdW5kcz1SLHQubGF0TG5nQm91bmRzPU4sdC5DUlM9SCx0Lkdlb0pTT049TmUsdC5nZW9KU09OPUtlLHQuZ2VvSnNvbj1ZZSx0LkxheWVyPU1lLHQuTGF5ZXJHcm91cD16ZSx0LmxheWVyR3JvdXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IHplKHQsaSl9LHQuRmVhdHVyZUdyb3VwPUNlLHQuZmVhdHVyZUdyb3VwPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyBDZSh0LGkpfSx0LkltYWdlT3ZlcmxheT1YZSx0LmltYWdlT3ZlcmxheT1mdW5jdGlvbih0LGksZSl7cmV0dXJuIG5ldyBYZSh0LGksZSl9LHQuVmlkZW9PdmVybGF5PUplLHQudmlkZW9PdmVybGF5PWZ1bmN0aW9uKHQsaSxlKXtyZXR1cm4gbmV3IEplKHQsaSxlKX0sdC5TVkdPdmVybGF5PSRlLHQuc3ZnT3ZlcmxheT1mdW5jdGlvbih0LGksZSl7cmV0dXJuIG5ldyAkZSh0LGksZSl9LHQuRGl2T3ZlcmxheT1RZSx0LlBvcHVwPXRuLHQucG9wdXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IHRuKHQsaSl9LHQuVG9vbHRpcD1lbix0LnRvb2x0aXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IGVuKHQsaSl9LHQuSWNvbj1TZSx0Lmljb249ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBTZSh0KX0sdC5EaXZJY29uPW5uLHQuZGl2SWNvbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG5uKHQpfSx0Lk1hcmtlcj1rZSx0Lm1hcmtlcj1mdW5jdGlvbih0LGkpe3JldHVybiBuZXcga2UodCxpKX0sdC5UaWxlTGF5ZXI9c24sdC50aWxlTGF5ZXI9cm4sdC5HcmlkTGF5ZXI9b24sdC5ncmlkTGF5ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvbih0KX0sdC5TVkc9cG4sdC5zdmc9bW4sdC5SZW5kZXJlcj1obix0LkNhbnZhcz11bix0LmNhbnZhcz1sbix0LlBhdGg9QmUsdC5DaXJjbGVNYXJrZXI9QWUsdC5jaXJjbGVNYXJrZXI9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IEFlKHQsaSl9LHQuQ2lyY2xlPUllLHQuY2lyY2xlPWZ1bmN0aW9uKHQsaSxlKXtyZXR1cm4gbmV3IEllKHQsaSxlKX0sdC5Qb2x5bGluZT1PZSx0LnBvbHlsaW5lPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyBPZSh0LGkpfSx0LlBvbHlnb249UmUsdC5wb2x5Z29uPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyBSZSh0LGkpfSx0LlJlY3RhbmdsZT1mbix0LnJlY3RhbmdsZT1mdW5jdGlvbih0LGkpe3JldHVybiBuZXcgZm4odCxpKX0sdC5NYXA9S2ksdC5tYXA9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IEtpKHQsaSl9O3ZhciBibj13aW5kb3cuTDt0Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93Lkw9Ym4sdGhpc30sd2luZG93Lkw9dH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC5qcy5tYXAiLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIH1cbn07XG5NbEJ5dGVzLnByb3RvdHlwZS50b1V0ZjE2ID0gZnVuY3Rpb24gKCl7XG4gIHZhciByID0gdGhpcy50b1N0cmluZygpO1xuICBpZih0aGlzLnQgPT0gOSkgcmV0dXJuIHJcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChyKTtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICBpZihnbG9iYWxUaGlzLlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksYixjLGQsZSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIHMuY2hhckNvZGVBdChpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzLmMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0Zjhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykge1xuICBpZihqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBzO1xuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgaWYgKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocylcbiAgZWxzZSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3V0Zjhfb2ZfdXRmMTYocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cblxuLy8gVGhlIHNlY3Rpb24gYmVsb3cgc2hvdWxkIGJlIHVzZWQgd2hlbiB1c2UtanMtc3RyaW5nPWZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfY29tcGFyZShzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19lcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgeyByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcocykge1xuICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2NvbnRlbnQocykge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHMuY1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiAhL1teXFx4MDAtXFx4ZmZdLy50ZXN0KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfaXNfbWxfYnl0ZXMocyk7XG59XG5cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGRlcHJlY2F0ZWRcblxuLy9Qcm92aWRlczogY2FtbF9qc190b19ieXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9qc190b19ieXRlX3N0cmluZyhzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX25ld19zdHJpbmcgKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZnJvbV9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF90b19qc19zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF90b19qc19zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc190b19zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3RvX3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocyk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAodGFnKSB7IHJldHVybiB0YWc7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX2FyZyAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBhcmcpIHsgdGhyb3cgWzAsIHRhZywgYXJnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJncyAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX2FyZ3MgKHRhZywgYXJncykgeyB0aHJvdyBbMCwgdGFnXS5jb25jYXQoYXJncyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlKVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZT1bMjQ4LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJGYWlsdXJlXCIpLC0zXTtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgZ2xvYmFsVGhpcy50b3BsZXZlbFJlbG9jKVxuICAgIG4gPSBnbG9iYWxUaGlzLnRvcGxldmVsUmVsb2MobmFtZV9vcHQpO1xuICBjYW1sX2dsb2JhbF9kYXRhW24gKyAxXSA9IHY7XG4gIGlmKG5hbWVfb3B0KSBjYW1sX2dsb2JhbF9kYXRhW25hbWVfb3B0XSA9IHY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2dsb2JhbF9kYXRhIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZ2V0X2dsb2JhbF9kYXRhICgpIHsgcmV0dXJuIGNhbWxfZ2xvYmFsX2RhdGE7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pc19wcmludGFibGUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pc19wcmludGFibGUoYykgeyByZXR1cm4gKyhjID4gMzEgJiYgYyA8IDEyNyk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gRm9ybWF0XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZm9ybWF0XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZm9ybWF0IChmbXQpIHtcbiAgZm10ID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpO1xuICB2YXIgbGVuID0gZm10Lmxlbmd0aDtcbiAgaWYgKGxlbiA+IDMxKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJmb3JtYXRfaW50OiBmb3JtYXQgdG9vIGxvbmdcIik7XG4gIHZhciBmID1cbiAgICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgICAgYmFzZTowLCBzaWduZWRjb252OmZhbHNlLCB3aWR0aDowLCB1cHBlcmNhc2U6ZmFsc2UsXG4gICAgICAgIHNpZ246MSwgcHJlYzotMSwgY29udjonZicgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjID0gZm10LmNoYXJBdChpKTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlICctJzpcbiAgICAgIGYuanVzdGlmeSA9ICctJzsgYnJlYWs7XG4gICAgY2FzZSAnKyc6IGNhc2UgJyAnOlxuICAgICAgZi5zaWduc3R5bGUgPSBjOyBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIGYuZmlsbGVyID0gJzAnOyBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGYuYWx0ZXJuYXRlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnMSc6IGNhc2UgJzInOiBjYXNlICczJzogY2FzZSAnNCc6IGNhc2UgJzUnOlxuICAgIGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgZi53aWR0aCA9IDA7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYud2lkdGggPSBmLndpZHRoICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy4nOlxuICAgICAgZi5wcmVjID0gMDtcbiAgICAgIGkrKztcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi5wcmVjID0gZi5wcmVjICogMTAgKyBjOyBpKytcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICBjYXNlICdkJzogY2FzZSAnaSc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3UnOlxuICAgICAgZi5iYXNlID0gMTA7IGJyZWFrO1xuICAgIGNhc2UgJ3gnOlxuICAgICAgZi5iYXNlID0gMTY7IGJyZWFrO1xuICAgIGNhc2UgJ1gnOlxuICAgICAgZi5iYXNlID0gMTY7IGYudXBwZXJjYXNlID0gdHJ1ZTsgYnJlYWs7XG4gICAgY2FzZSAnbyc6XG4gICAgICBmLmJhc2UgPSA4OyBicmVhaztcbiAgICBjYXNlICdlJzogY2FzZSAnZic6IGNhc2UgJ2cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi5jb252ID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnRSc6IGNhc2UgJ0YnOiBjYXNlICdHJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYudXBwZXJjYXNlID0gdHJ1ZTtcbiAgICAgIGYuY29udiA9IGMudG9Mb3dlckNhc2UgKCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYnVmZmVyKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBqc29vX2Zsb29yX2xvZzJcbnZhciBsb2cyX29rID0gTWF0aC5sb2cyICYmIE1hdGgubG9nMigxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNykgPT0gMTAyMFxuZnVuY3Rpb24ganNvb19mbG9vcl9sb2cyKHgpIHtcbiAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICB2YXIgaSA9IDA7XG4gIGlmICh4ID09IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICBlbHNlIHt3aGlsZSAoeCA8IDEpIHt4Kj0yOyBpLS19IH07XG4gIHJldHVybiBpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMiwgY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGlcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDEsIDAsIDB4N2ZmMCk7XG4gICAgaWYgKHggPiAwKVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4N2ZmMClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHhmZmYwKVxuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MHg4MDAwOih4Pj0wKT8wOjB4ODAwMDtcbiAgaWYgKHNpZ24pIHggPSAteDtcbiAgLy8gSW50NjQuYml0c19vZl9mbG9hdCAxLjEyMzU1ODIwOTI4ODk0NzRFKzMwNyA9IDB4N2ZiMDAwMDAwMDAwMDAwMExcbiAgLy8gdXNpbmcgTWF0aC5MT0cyRSpNYXRoLmxvZyh4KSBpbiBwbGFjZSBvZiBNYXRoLmxvZzIgcmVzdWx0IGluIHByZWNpc2lvbiBsb3N0XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxMDIzO1xuICBpZiAoZXhwIDw9IDApIHtcbiAgICBleHAgPSAwO1xuICAgIHggLz0gTWF0aC5wb3coMiwtMTAyNik7XG4gIH0gZWxzZSB7XG4gICAgeCAvPSBNYXRoLnBvdygyLGV4cC0xMDI3KTtcbiAgICBpZiAoeCA8IDE2KSB7XG4gICAgICB4ICo9IDI7IGV4cCAtPTE7IH1cbiAgICBpZiAoZXhwID09IDApIHtcbiAgICAgIHggLz0gMjsgfVxuICB9XG4gIHZhciBrID0gTWF0aC5wb3coMiwyNCk7XG4gIHZhciByMyA9IHh8MDtcbiAgeCA9ICh4IC0gcjMpICogaztcbiAgdmFyIHIyID0geHwwO1xuICB4ID0gKHggLSByMikgKiBrO1xuICB2YXIgcjEgPSB4fDA7XG4gIHIzID0gKHIzICYweGYpIHwgc2lnbiB8IGV4cCA8PCA0O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkocjEsIHIyLCByMyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGdsb2JhbFRoaXMuRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgZ2xvYmFsVGhpcy5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGdsb2JhbFRoaXMuSW50MzJBcnJheSgxKTtcbiAgaW50MzJhWzBdID0geDtcbiAgdmFyIGZsb2F0MzJhID0gbmV3IGdsb2JhbFRoaXMuRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBNYXRoLm1heCgtMTAyMywganNvb19mbG9vcl9sb2cyKHgpICsgMSk7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHJldHVybiBbMCwgeCwgZXhwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0X2NvbXBhcmUgKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHJldHVybiAwO1xuICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgaWYgKHggPiB5KSByZXR1cm4gMTtcbiAgaWYgKHggPT09IHgpIHJldHVybiAxO1xuICBpZiAoeSA9PT0geSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb3B5c2lnbl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3B5c2lnbl9mbG9hdCAoeCwgeSkge1xuICBpZiAoeSA9PSAwKSB5ID0gMSAvIHk7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgcmV0dXJuICh5IDwgMCk/KC14KTp4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NpZ25iaXRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09IDApIHggPSAxIC8geDtcbiAgcmV0dXJuICh4IDwgMCk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmV4cG0xKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2V4cDJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwMl9mbG9hdCh4KSB7IHJldHVybiBNYXRoLnBvdygyLCB4KTsgfVxuLy9Qcm92aWRlczogY2FtbF9sb2cxcF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxcF9mbG9hdCh4KSB7IHJldHVybiBNYXRoLmxvZzFwKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzJfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMl9mbG9hdCh4KSB7IHJldHVybiBNYXRoLmxvZzIoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQgKHgsIHkpIHsgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgubG9nMTAoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNvc2goeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYWNvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYWNvc2hfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYWNvc2goeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnNpbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYXNpbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXNpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYXNpbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfdGFuaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF90YW5oX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnRhbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfYXRhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYXRhbmhfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguYXRhbmgoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY2JydF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jYnJ0X2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLmNicnQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9lcmZfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXJmX2Zsb2F0KHgpIHtcbiAgdmFyIGExID0gMC4yNTQ4Mjk1OTI7XG4gIHZhciBhMiA9IC0wLjI4NDQ5NjczNjtcbiAgdmFyIGEzID0gMS40MjE0MTM3NDE7XG4gIHZhciBhNCA9IC0xLjQ1MzE1MjAyNztcbiAgdmFyIGE1ID0gMS4wNjE0MDU0Mjk7XG4gIHZhciBwID0gMC4zMjc1OTExO1xuXG4gIHZhciBzaWduID0gMTtcbiAgaWYgKHggPCAwKSB7XG4gICAgc2lnbiA9IC0xO1xuICB9XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgdmFyIHQgPSAxLjAgLyAoMS4wICsgcCAqIHgpO1xuICB2YXIgeSA9IDEuMCAtICgoKChhNSAqIHQgKyBhNCkgKiB0ICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICByZXR1cm4gc2lnbiAqIHk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXJmY19mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9lcmZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfZXJmY19mbG9hdCh4KSB7XG4gIHJldHVybiAxIC0gY2FtbF9lcmZfZmxvYXQoeCk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9mbWFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZm1hX2Zsb2F0KHgsIHksIHopIHtcbiAgdmFyIFNQTElUID0gTWF0aC5wb3coMiwgMjcpICsgMTtcbiAgdmFyIE1JTl9WQUxVRSA9IE1hdGgucG93KDIsIC0xMDIyKTtcbiAgdmFyIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xuICB2YXIgQyA9IDQxNjtcbiAgdmFyIEEgPSBNYXRoLnBvdygyLCArQyk7XG4gIHZhciBCID0gTWF0aC5wb3coMiwgLUMpO1xuXG4gIGZ1bmN0aW9uIG11bHRpcGx5IChhLCBiKSB7XG4gICAgdmFyIGF0ID0gU1BMSVQgKiBhO1xuICAgIHZhciBhaGkgPSBhdCAtIChhdCAtIGEpO1xuICAgIHZhciBhbG8gPSBhIC0gYWhpO1xuICAgIHZhciBidCA9IFNQTElUICogYjtcbiAgICB2YXIgYmhpID0gYnQgLSAoYnQgLSBiKTtcbiAgICB2YXIgYmxvID0gYiAtIGJoaTtcbiAgICB2YXIgcCA9IGEgKiBiO1xuICAgIHZhciBlID0gKChhaGkgKiBiaGkgLSBwKSArIGFoaSAqIGJsbyArIGFsbyAqIGJoaSkgKyBhbG8gKiBibG87XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IHAsXG4gICAgICBlOiBlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB2YXIgcyA9IGEgKyBiO1xuICAgIHZhciB2ID0gcyAtIGE7XG4gICAgdmFyIGUgPSAoYSAtIChzIC0gdikpICsgKGIgLSB2KTtcbiAgICByZXR1cm4ge1xuICAgICAgczogcyxcbiAgICAgIGU6IGVcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdCAoeCwgeSkge1xuICAgIHJldHVybiB4ICE9PSAwICYmIHkgIT09IDAgJiYgU1BMSVQgKiB4IC0gKFNQTElUICogeCAtIHgpID09PSB4ID8geCAqICgxICsgKHggPCAwID8gLTEgOiArMSkgKiAoeSA8IDAgPyAtMSA6ICsxKSAqIEVQU0lMT04pIDogeDtcbiAgfTtcblxuICBpZiAoeCA9PT0gMCB8fCB4ICE9PSB4IHx8IHggPT09ICsxIC8gMCB8fCB4ID09PSAtMSAvIDAgfHxcbiAgICAgIHkgPT09IDAgfHwgeSAhPT0geSB8fCB5ID09PSArMSAvIDAgfHwgeSA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHggKiB5ICsgejtcbiAgfVxuICBpZiAoeiA9PT0gMCkge1xuICAgIHJldHVybiB4ICogeTtcbiAgfVxuICBpZiAoeiAhPT0geiB8fCB6ID09PSArMSAvIDAgfHwgeiA9PT0gLTEgLyAwKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cblxuICB2YXIgc2NhbGUgPSAxO1xuICB3aGlsZSAoTWF0aC5hYnMoeCkgPiBBKSB7XG4gICAgc2NhbGUgKj0gQTtcbiAgICB4ICo9IEI7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpID4gQSkge1xuICAgIHNjYWxlICo9IEE7XG4gICAgeSAqPSBCO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMSAvIDApIHtcbiAgICByZXR1cm4geCAqIHkgKiBzY2FsZTtcbiAgfVxuICB3aGlsZSAoTWF0aC5hYnMoeCkgPCBCKSB7XG4gICAgc2NhbGUgKj0gQjtcbiAgICB4ICo9IEE7XG4gIH1cbiAgd2hpbGUgKE1hdGguYWJzKHkpIDwgQikge1xuICAgIHNjYWxlICo9IEI7XG4gICAgeSAqPSBBO1xuICB9XG4gIGlmIChzY2FsZSA9PT0gMCkge1xuICAgIHJldHVybiB6O1xuICB9XG5cbiAgdmFyIHhzID0geDtcbiAgdmFyIHlzID0geTtcbiAgdmFyIHpzID0geiAvIHNjYWxlO1xuXG4gIGlmIChNYXRoLmFicyh6cykgPiBNYXRoLmFicyh4cyAqIHlzKSAqIDQgLyBFUFNJTE9OKSB7XG4gICAgcmV0dXJuIHo7XG4gIH1cbiAgaWYgKE1hdGguYWJzKHpzKSA8IE1hdGguYWJzKHhzICogeXMpICogRVBTSUxPTiAvIDQgKiBFUFNJTE9OIC8gNCkge1xuICAgIHpzID0gKHogPCAwID8gLTEgOiArMSkgKiBNSU5fVkFMVUU7XG4gIH1cblxuICB2YXIgeHkgPSBtdWx0aXBseSh4cywgeXMpO1xuICB2YXIgcyA9IGFkZCh4eS5wLCB6cyk7XG4gIHZhciB1ID0gYWRkKHh5LmUsIHMuZSk7XG4gIHZhciBpID0gYWRkKHMucywgdS5zKTtcblxuICB2YXIgZiA9IGkucyArIGFkanVzdChpLmUsIHUuZSk7XG4gIGlmIChmID09PSAwKSB7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICB2YXIgZnMgPSBmICogc2NhbGU7XG4gIGlmIChNYXRoLmFicyhmcykgPiBNSU5fVkFMVUUpIHtcbiAgICByZXR1cm4gZnM7XG4gIH1cblxuICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZXJlIHdhcyBleHRyYSByb3VuZGluZyBmb3IgYSBkZW5vcm1hbGl6ZWQgdmFsdWUuXG4gIHJldHVybiBmcyArIGFkanVzdChmIC0gZnMgLyBzY2FsZSwgaS5lKSAqIHNjYWxlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2Zsb2F0IChmbXQsIHgpIHtcbiAgZnVuY3Rpb24gdG9GaXhlZCh4LGRwKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpIDwgMS4wKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKGRwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGUgPSBwYXJzZUludCh4LnRvU3RyaW5nKCkuc3BsaXQoJysnKVsxXSk7XG4gICAgICBpZiAoZSA+IDIwKSB7XG4gICAgICAgIGUgLT0gMjA7XG4gICAgICAgIHggLz0gTWF0aC5wb3coMTAsZSk7XG4gICAgICAgIHggKz0gKG5ldyBBcnJheShlKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIGlmKGRwID4gMCkge1xuICAgICAgICAgIHggPSB4ICsgJy4nICsgKG5ldyBBcnJheShkcCsxKSkuam9pbignMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4geC50b0ZpeGVkKGRwKVxuICAgIH1cbiAgfVxuICB2YXIgcywgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIHZhciBwcmVjID0gKGYucHJlYyA8IDApPzY6Zi5wcmVjO1xuICBpZiAoeCA8IDAgfHwgKHggPT0gMCAmJiAxL3ggPT0gLUluZmluaXR5KSkgeyBmLnNpZ24gPSAtMTsgeCA9IC14OyB9XG4gIGlmIChpc05hTih4KSkgeyBzID0gXCJuYW5cIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZSBpZiAoIWlzRmluaXRlKHgpKSB7IHMgPSBcImluZlwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlXG4gICAgc3dpdGNoIChmLmNvbnYpIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHZhciBzID0geC50b0V4cG9uZW50aWFsKHByZWMpO1xuICAgICAgLy8gZXhwb25lbnQgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBkaWdpdHNcbiAgICAgIHZhciBpID0gcy5sZW5ndGg7XG4gICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2YnOlxuICAgICAgcyA9IHRvRml4ZWQoeCwgcHJlYyk7IGJyZWFrO1xuICAgIGNhc2UgJ2cnOlxuICAgICAgcHJlYyA9IHByZWM/cHJlYzoxO1xuICAgICAgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjIC0gMSk7XG4gICAgICB2YXIgaiA9IHMuaW5kZXhPZignZScpO1xuICAgICAgdmFyIGV4cCA9ICtzLnNsaWNlKGogKyAxKTtcbiAgICAgIGlmIChleHAgPCAtNCB8fCB4ID49IDFlMjEgfHwgeC50b0ZpeGVkKDApLmxlbmd0aCA+IHByZWMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICB2YXIgaSA9IGogLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpICsgcy5zbGljZShqKTtcbiAgICAgICAgaSA9IHMubGVuZ3RoO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSAtIDMpID09ICdlJylcbiAgICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gcHJlYztcbiAgICAgICAgaWYgKGV4cCA8IDApIHsgcCAtPSBleHAgKyAxOyBzID0geC50b0ZpeGVkKHApOyB9XG4gICAgICAgIGVsc2Ugd2hpbGUgKHMgPSB4LnRvRml4ZWQocCksIHMubGVuZ3RoID4gcHJlYyArIDEpIHAtLTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgICAgdmFyIGkgPSBzLmxlbmd0aCAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgICAgcyA9IHMuc2xpY2UoMCwgaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpXG4gIHJlcyA9ICtzO1xuICBpZiAoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgcmV0dXJuIHJlcztcbiAgcyA9IHMucmVwbGFjZSgvXy9nLFwiXCIpO1xuICByZXMgPSArcztcbiAgaWYgKCgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSB8fCAvXlsrLV0/bmFuJC9pLnRlc3QocykpIHJldHVybiByZXM7XG4gIHZhciBtID0gL14gKihbKy1dPykweChbMC05YS1mXSspXFwuPyhbMC05YS1mXSopKHAoWystXT9bMC05XSspKT8vaS5leGVjKHMpO1xuICAvLyAgICAgICAgICAxICAgICAgICAyICAgICAgICAgICAgIDMgICAgICAgICAgIDVcbiAgaWYobSl7XG4gICAgdmFyIG0zID0gbVszXS5yZXBsYWNlKC8wKyQvLCcnKTtcbiAgICB2YXIgbWFudGlzc2EgPSBwYXJzZUludChtWzFdICsgbVsyXSArIG0zLCAxNik7XG4gICAgdmFyIGV4cG9uZW50ID0gKG1bNV18MCkgLSA0Km0zLmxlbmd0aDtcbiAgICByZXMgPSBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmKC9eXFwrP2luZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiBJbmZpbml0eTtcbiAgaWYoL14taW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIC1JbmZpbml0eTtcbiAgY2FtbF9mYWlsd2l0aChcImZsb2F0X29mX3N0cmluZ1wiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBnbG9iYWxUaGlzLnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKVxufVxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbi8vSWY6IGJyb3dzZXJcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV93aXRoX2FyZ3Ncbi8vUmVxdWlyZXM6IG1ha2VfdW5peF9lcnJfYXJncywgY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLm1rZGlyU3luYyh0aGlzLm5tKG5hbWUpLHttb2RlOm1vZGV9KTtcbiAgICByZXR1cm4gMFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucm1kaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICAgIHJldHVybiAwXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgICByZXR1cm4gYjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZiwgcmFpc2VfdW5peCkge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obywgbiwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB0cnkge1xuICAgIHZhciBqc19zdGF0cyA9IHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubHN0YXQgPSBmdW5jdGlvbihuYW1lLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdmFyIGpzX3N0YXRzID0gdGhpcy5mcy5sc3RhdFN5bmModGhpcy5ubShuYW1lKSk7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHNfZnJvbV9qcyhqc19zdGF0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMucmFpc2Vfbm9kZWpzX2Vycm9yKGVyciwgcmFpc2VfdW5peCk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uKHRvX2RpciwgdGFyZ2V0LCBwYXRoLCByYWlzZV91bml4KSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5zeW1saW5rU3luYyh0aGlzLm5tKHRhcmdldCksIHRoaXMubm0ocGF0aCksIHRvX2RpciA/ICdkaXInIDogJ2ZpbGUnKTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5yYWlzZV9ub2RlanNfZXJyb3IoZXJyLCByYWlzZV91bml4KTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkbGluayA9IGZ1bmN0aW9uKG5hbWUsIHJhaXNlX3VuaXgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgbGluayA9IHRoaXMuZnMucmVhZGxpbmtTeW5jKHRoaXMubm0obmFtZSksICd1dGY4Jyk7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGxpbmspO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLnJhaXNlX25vZGVqc19lcnJvcihlcnIsIHJhaXNlX3VuaXgpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJhaXNlX25vZGVqc19lcnJvciA9IGZ1bmN0aW9uKGVyciwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IGNhbWxfbmFtZWRfdmFsdWUoXCJVbml4LlVuaXhfZXJyb3JcIik7XG4gIGlmIChyYWlzZV91bml4ICYmIHVuaXhfZXJyb3IpIHtcbiAgICB2YXIgYXJncyA9IG1ha2VfdW5peF9lcnJfYXJncyhlcnIuY29kZSwgZXJyLnN5c2NhbGwsIGVyci5wYXRoLCBlcnIuZXJybm8pO1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5zdGF0c19mcm9tX2pzID0gZnVuY3Rpb24oanNfc3RhdHMpIHtcbiAgLyogPT09VW5peC5maWxlX2tpbmQ9PT1cbiAgICogdHlwZSBmaWxlX2tpbmQgPVxuICAgKiAgICAgU19SRUcgICAgICAgICAgICAgICAgICAgICAgICgqKiBSZWd1bGFyIGZpbGUgKilcbiAgICogICB8IFNfRElSICAgICAgICAgICAgICAgICAgICAgICAoKiogRGlyZWN0b3J5ICopXG4gICAqICAgfCBTX0NIUiAgICAgICAgICAgICAgICAgICAgICAgKCoqIENoYXJhY3RlciBkZXZpY2UgKilcbiAgICogICB8IFNfQkxLICAgICAgICAgICAgICAgICAgICAgICAoKiogQmxvY2sgZGV2aWNlICopXG4gICAqICAgfCBTX0xOSyAgICAgICAgICAgICAgICAgICAgICAgKCoqIFN5bWJvbGljIGxpbmsgKilcbiAgICogICB8IFNfRklGTyAgICAgICAgICAgICAgICAgICAgICAoKiogTmFtZWQgcGlwZSAqKVxuICAgKiAgIHwgU19TT0NLICAgICAgICAgICAgICAgICAgICAgICgqKiBTb2NrZXQgKilcbiAgICovXG4gIHZhciBmaWxlX2tpbmQ7XG4gIGlmIChqc19zdGF0cy5pc0ZpbGUoKSkge1xuICAgIGZpbGVfa2luZCA9IDA7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGZpbGVfa2luZCA9IDE7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNDaGFyYWN0ZXJEZXZpY2UoKSkge1xuICAgIGZpbGVfa2luZCA9IDI7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNCbG9ja0RldmljZSgpKSB7XG4gICAgZmlsZV9raW5kID0gMztcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgZmlsZV9raW5kID0gNDtcbiAgfSBlbHNlIGlmIChqc19zdGF0cy5pc0ZJRk8oKSkge1xuICAgIGZpbGVfa2luZCA9IDU7XG4gIH0gZWxzZSBpZiAoanNfc3RhdHMuaXNTb2NrZXQoKSkge1xuICAgIGZpbGVfa2luZCA9IDY7XG4gIH1cbiAgLyogPT09VW5peC5zdGF0cz09PVxuICAgKiB0eXBlIHN0YXRzID1cbiAgICogIHsgc3RfZGV2IDogaW50OyAgICAgICAgICAgICAgICgqKiBEZXZpY2UgbnVtYmVyICopXG4gICAqICAgIHN0X2lubyA6IGludDsgICAgICAgICAgICAgICAoKiogSW5vZGUgbnVtYmVyICopXG4gICAqICAgIHN0X2tpbmQgOiBmaWxlX2tpbmQ7ICAgICAgICAoKiogS2luZCBvZiB0aGUgZmlsZSAqKVxuICAgKiAgICBzdF9wZXJtIDogZmlsZV9wZXJtOyAgICAgICAgKCoqIEFjY2VzcyByaWdodHMgKilcbiAgICogICAgc3RfbmxpbmsgOiBpbnQ7ICAgICAgICAgICAgICgqKiBOdW1iZXIgb2YgbGlua3MgKilcbiAgICogICAgc3RfdWlkIDogaW50OyAgICAgICAgICAgICAgICgqKiBVc2VyIGlkIG9mIHRoZSBvd25lciAqKVxuICAgKiAgICBzdF9naWQgOiBpbnQ7ICAgICAgICAgICAgICAgKCoqIEdyb3VwIElEIG9mIHRoZSBmaWxlJ3MgZ3JvdXAgKilcbiAgICogICAgc3RfcmRldiA6IGludDsgICAgICAgICAgICAgICgqKiBEZXZpY2UgSUQgKGlmIHNwZWNpYWwgZmlsZSkgKilcbiAgICogICAgc3Rfc2l6ZSA6IGludDsgICAgICAgICAgICAgICgqKiBTaXplIGluIGJ5dGVzICopXG4gICAqICAgIHN0X2F0aW1lIDogZmxvYXQ7ICAgICAgICAgICAoKiogTGFzdCBhY2Nlc3MgdGltZSAqKVxuICAgKiAgICBzdF9tdGltZSA6IGZsb2F0OyAgICAgICAgICAgKCoqIExhc3QgbW9kaWZpY2F0aW9uIHRpbWUgKilcbiAgICogICAgc3RfY3RpbWUgOiBmbG9hdDsgICAgICAgICAgICgqKiBMYXN0IHN0YXR1cyBjaGFuZ2UgdGltZSAqKVxuICAgKiAgfVxuICAgKi9cbiAgcmV0dXJuIEJMT0NLKFxuICAgIDAsXG4gICAganNfc3RhdHMuZGV2LFxuICAgIGpzX3N0YXRzLmlubyxcbiAgICBmaWxlX2tpbmQsXG4gICAganNfc3RhdHMubW9kZSxcbiAgICBqc19zdGF0cy5ubGluayxcbiAgICBqc19zdGF0cy51aWQsXG4gICAganNfc3RhdHMuZ2lkLFxuICAgIGpzX3N0YXRzLnJkZXYsXG4gICAganNfc3RhdHMuc2l6ZSxcbiAgICBqc19zdGF0cy5hdGltZU1zLFxuICAgIGpzX3N0YXRzLm10aW1lTXMsXG4gICAganNfc3RhdHMuY3RpbWVNc1xuICApO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKCkge1xufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoZmQpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9ieXRlcyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGdsb2JhbFRoaXMuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCAwLCAxLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclswXTtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmlsZTtcblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9JZjogYnJvd3NlclxuZnVuY3Rpb24gTWxOb2RlRmlsZSgpe1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdHJhaWxpbmdfc2xhc2gobmFtZSl7XG4gIHJldHVybiAobmFtZS5zbGljZSgtMSkgIT09IFwiL1wiKSA/IChuYW1lICsgXCIvXCIpIDogbmFtZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuLy9SZXF1aXJlczogY2FtbF90cmFpbGluZ19zbGFzaCwgZnNfbm9kZV9zdXBwb3J0ZWRcbmlmKGZzX25vZGVfc3VwcG9ydGVkICgpICYmIGdsb2JhbFRoaXMucHJvY2VzcyAmJiBnbG9iYWxUaGlzLnByb2Nlc3MuY3dkKVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9IGdsb2JhbFRoaXMucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5jYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChjYW1sX2N1cnJlbnRfZGlyKTtcblxuLy9Qcm92aWRlczogY2FtbF9nZXRfcm9vdFxuLy9SZXF1aXJlczogcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9nZXRfcm9vdChwYXRoKXtcbiAgdmFyIHggPSBwYXRoX2lzX2Fic29sdXRlKHBhdGgpO1xuICBpZiAoIXgpIHJldHVybjtcbiAgcmV0dXJuIHhbMF0gKyBcIi9cIn1cblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2dldF9yb290LCBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX2ZhaWx3aXRoXG52YXIgY2FtbF9yb290ID0gY2FtbF9nZXRfcm9vdChjYW1sX2N1cnJlbnRfZGlyKSB8fCBjYW1sX2ZhaWx3aXRoKFwidW5hYmxlIHRvIGNvbXB1dGUgY2FtbF9yb290XCIpO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IHBhdGhfaXNfYWJzb2x1dGVcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBtYWtlX3BhdGhfaXNfYWJzb2x1dGUoKSB7XG4gIGZ1bmN0aW9uIHBvc2l4KHBhdGgpIHtcbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykgcmV0dXJuIFtcIlwiLCBwYXRoLnN1YnN0cmluZygxKV07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gd2luMzIocGF0aCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2IzZmNjMjQ1ZmIyNTUzOTkwOWVmMWQ1ZWFhMDFkYmY5MmUxNjg2MzMvbGliL3BhdGguanMjTDU2XG4gICAgdmFyIHNwbGl0RGV2aWNlUmUgPSAvXihbYS16QS1aXTp8W1xcXFwvXXsyfVteXFxcXC9dK1tcXFxcL10rW15cXFxcL10rKT8oW1xcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKTtcbiAgICB2YXIgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnO1xuICAgIHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIGlmIChCb29sZWFuKHJlc3VsdFsyXSB8fCBpc1VuYykpIHtcbiAgICAgIHZhciByb290ID0gKHJlc3VsdFsxXSB8fCAnJyk7XG4gICAgICB2YXIgc2VwID0gKHJlc3VsdFsyXSB8fCAnJyk7XG4gICAgICByZXR1cm4gW3Jvb3QsIHBhdGguc3Vic3RyaW5nKHJvb3QubGVuZ3RoICsgc2VwLmxlbmd0aCldXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZihmc19ub2RlX3N1cHBvcnRlZCAoKSAmJiBnbG9iYWxUaGlzLnByb2Nlc3MgJiYgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHdpbjMyIDogcG9zaXg7XG4gIH1cbiAgZWxzZSByZXR1cm4gcG9zaXhcbn1cbnZhciBwYXRoX2lzX2Fic29sdXRlID0gbWFrZV9wYXRoX2lzX2Fic29sdXRlKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZywgcGF0aF9pc19hYnNvbHV0ZVxuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYoICFwYXRoX2lzX2Fic29sdXRlKG5hbWUpIClcbiAgICBuYW1lID0gY2FtbF9jdXJyZW50X2RpciArIG5hbWU7XG4gIHZhciBjb21wMCA9IHBhdGhfaXNfYWJzb2x1dGUobmFtZSk7XG4gIHZhciBjb21wID0gY29tcDBbMV0uc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLnVuc2hpZnQoY29tcDBbMF0pO1xuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOlwiL3N0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoXCIvc3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nZXRfcm9vdCwgTWxOb2RlRGV2aWNlLCBjYW1sX3RyYWlsaW5nX3NsYXNoLCBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKTtcbiAgdmFyIG5hbWVfc2xhc2ggPSBjYW1sX3RyYWlsaW5nX3NsYXNoKG5hbWUpO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgaWYoICFyZXMgJiYgZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciByb290ID0gY2FtbF9nZXRfcm9vdChuYW1lKTtcbiAgICBpZiAocm9vdCAmJiByb290Lm1hdGNoKC9eW2EtekEtWl06XFwvJC8pKXtcbiAgICAgIHZhciBtID0ge3BhdGg6cm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShyb290KX07XG4gICAgICBqc29vX21vdW50X3BvaW50LnB1c2gobSk7XG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICAgIH1cbiAgfVxuICBpZiggcmVzICkgcmV0dXJuIHJlcztcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJubyBkZXZpY2UgZm91bmQgZm9yIFwiICsgbmFtZV9zbGFzaCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnQsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGgsIGNhbWxfdHJhaWxpbmdfc2xhc2hcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBjYW1sX3RyYWlsaW5nX3NsYXNoKHBhdGguam9pbihcIi9cIikpO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfdHJhaWxpbmdfc2xhc2gsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gY2FtbF90cmFpbGluZ19zbGFzaChyb290LnBhdGggKyByb290LnJlc3QpO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGRpcikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZmlsZV9leGlzdHNcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19maWxlX2V4aXN0cyAobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByZXR1cm4gcm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoYVtpXSk7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW1vdmVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfcmVtb3ZlKG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgb2sgPSByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0KTtcbiAgaWYob2sgPT0gMCkgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc19kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19pc19kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UuaXNfZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiBhPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVuYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVuYW1lKG8sbil7XG4gIHZhciBvX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShvKTtcbiAgdmFyIG5fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG4pO1xuICBpZihvX3Jvb3QuZGV2aWNlICE9IG5fcm9vdC5kZXZpY2UpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogY2Fubm90IG1vdmUgZmlsZSBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtXCIpO1xuICBpZighb19yb290LmRldmljZS5yZW5hbWUpXG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3lzX3JlbmFtZTogbm8gaW1wbGVtZW50ZWRcIik7XG4gIG9fcm9vdC5kZXZpY2UucmVuYW1lKG9fcm9vdC5yZXN0LCBuX3Jvb3QucmVzdCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3lzX21rZGlyKG5hbWUsIHBlcm0pe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QscGVybSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19ybWRpclxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vdF9hX2RpclxuZnVuY3Rpb24gY2FtbF9zeXNfcm1kaXIobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBqc29vX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUpXG4gICAgZ2xvYmFsVGhpcy5qc29vX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCk7XG4gIGVsc2Uge1xuICAgIGlmKCFnbG9iYWxUaGlzLmNhbWxfZnNfdG1wKSBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gICAgZ2xvYmFsVGhpcy5jYW1sX2ZzX3RtcC5wdXNoKHtuYW1lOm5hbWUsY29udGVudDpjb250ZW50fSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnNfaW5pdFxuLy9SZXF1aXJlczoganNvb19jcmVhdGVfZmlsZVxuZnVuY3Rpb24gY2FtbF9mc19pbml0ICgpe1xuICB2YXIgdG1wPWdsb2JhbFRoaXMuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGpzb29fY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBnbG9iYWxUaGlzLmpzb29fY3JlYXRlX2ZpbGUgPSBqc29vX2NyZWF0ZV9maWxlO1xuICBnbG9iYWxUaGlzLmNhbWxfZnNfdG1wID0gW107XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGpzb29fY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGpzb29fY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKTtcbiAgdmFyIGNvbnRlbnQgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNvbnRlbnQpO1xuICByZXR1cm4gY2FtbF9jcmVhdGVfZmlsZShuYW1lLCBjb250ZW50KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpKTtcbn1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICAgICAgIGQuZ2V0RGF5KCksIGRveSxcbiAgICAgICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogdW5peF9pc2F0dHlcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKT8xOjA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogbWFrZV91bml4X2Vycl9hcmdzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIHVuaXhfZXJyb3IgPSBbXG4gIC8qID09PVVuaXguZXJyb3I9PT1cbiAgICpcbiAgICogVGhpcyBhcnJheSBpcyBpbiBvcmRlciBvZiB0aGUgdmFyaWFudCBpbiBPQ2FtbFxuICAgKi9cbiAgXCJFMkJJR1wiLCBcIkVBQ0NFU1wiLCBcIkVBR0FJTlwiLCBcIkVCQURGXCIsIFwiRUJVU1lcIiwgXCJFQ0hJTERcIiwgXCJFREVBRExLXCIsIFwiRURPTVwiLFxuICBcIkVFWElTVFwiLCBcIkVGQVVMVFwiLCBcIkVGQklHXCIsIFwiRUlOVFJcIiwgXCJFSU5WQUxcIiwgXCJFSU9cIiwgXCJFSVNESVJcIiwgXCJFTUZJTEVcIixcbiAgXCJFTUxJTktcIiwgXCJFTkFNRVRPT0xPTkdcIiwgXCJFTkZJTEVcIiwgXCJFTk9ERVZcIiwgXCJFTk9FTlRcIiwgXCJFTk9FWEVDXCIsIFwiRU5PTENLXCIsXG4gIFwiRU5PTUVNXCIsIFwiRU5PU1BDXCIsIFwiRU5PU1lTXCIsIFwiRU5PVERJUlwiLCBcIkVOT1RFTVBUWVwiLCBcIkVOT1RUWVwiLCBcIkVOWElPXCIsXG4gIFwiRVBFUk1cIiwgXCJFUElQRVwiLCBcIkVSQU5HRVwiLCBcIkVST0ZTXCIsIFwiRVNQSVBFXCIsIFwiRVNSQ0hcIiwgXCJFWERFVlwiLCBcIkVXT1VMREJMT0NLXCIsXG4gIFwiRUlOUFJPR1JFU1NcIiwgXCJFQUxSRUFEWVwiLCBcIkVOT1RTT0NLXCIsIFwiRURFU1RBRERSUkVRXCIsIFwiRU1TR1NJWkVcIixcbiAgXCJFUFJPVE9UWVBFXCIsIFwiRU5PUFJPVE9PUFRcIiwgXCJFUFJPVE9OT1NVUFBPUlRcIiwgXCJFU09DS1ROT1NVUFBPUlRcIixcbiAgXCJFT1BOT1RTVVBQXCIsIFwiRVBGTk9TVVBQT1JUXCIsIFwiRUFGTk9TVVBQT1JUXCIsIFwiRUFERFJJTlVTRVwiLCBcIkVBRERSTk9UQVZBSUxcIixcbiAgXCJFTkVURE9XTlwiLCBcIkVORVRVTlJFQUNIXCIsIFwiRU5FVFJFU0VUXCIsIFwiRUNPTk5BQk9SVEVEXCIsIFwiRUNPTk5SRVNFVFwiLCBcIkVOT0JVRlNcIixcbiAgXCJFSVNDT05OXCIsIFwiRU5PVENPTk5cIiwgXCJFU0hVVERPV05cIiwgXCJFVE9PTUFOWVJFRlNcIiwgXCJFVElNRURPVVRcIiwgXCJFQ09OTlJFRlVTRURcIixcbiAgXCJFSE9TVERPV05cIiwgXCJFSE9TVFVOUkVBQ0hcIiwgXCJFTE9PUFwiLCBcIkVPVkVSRkxPV1wiXG5dO1xuZnVuY3Rpb24gbWFrZV91bml4X2Vycl9hcmdzKGNvZGUsIHN5c2NhbGwsIHBhdGgsIGVycm5vKSB7XG4gIHZhciB2YXJpYW50ID0gdW5peF9lcnJvci5pbmRleE9mKGNvZGUpO1xuICBpZiAodmFyaWFudCA8IDApIHtcbiAgICAvLyBEZWZhdWx0IGlmIHVuZGVmaW5lZFxuICAgIGlmIChlcnJubyA9PSBudWxsKSB7XG4gICAgICBlcnJubyA9IC05OTk5XG4gICAgfVxuICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIHZhcmlhbnRzLCBmYWxsYmFjayB0byBFVU5LTk9XTkVSUihpbnQpXG4gICAgdmFyaWFudCA9IEJMT0NLKDAsIGVycm5vKTtcbiAgfVxuICB2YXIgYXJncyA9IFtcbiAgICB2YXJpYW50LFxuICAgIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHN5c2NhbGwgfHwgXCJcIiksXG4gICAgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcocGF0aCB8fCBcIlwiKVxuICBdO1xuICByZXR1cm4gYXJncztcbn1cblxuLy9Qcm92aWRlczogdW5peF9zdGF0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9zdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5zdGF0KSB7XG4gICAgY2FtbF9mYWlsd2l0aChcInVuaXhfc3RhdDogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5zdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9zdGF0XzY0XG4vL1JlcXVpcmVzOiB1bml4X3N0YXRcbnZhciB1bml4X3N0YXRfNjQgPSB1bml4X3N0YXQ7XG5cbi8vUHJvdmlkZXM6IHVuaXhfbHN0YXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X2xzdGF0KG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5sc3RhdCkge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X2xzdGF0OiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmxzdGF0KHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9sc3RhdF82NFxuLy9SZXF1aXJlczogdW5peF9sc3RhdFxudmFyIHVuaXhfbHN0YXRfNjQgPSB1bml4X2xzdGF0O1xuXG4vL1Byb3ZpZGVzOiB1bml4X21rZGlyXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9ta2RpcihuYW1lLCBwZXJtKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UubWtkaXIpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9ta2Rpcjogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5ta2Rpcihyb290LnJlc3QsIHBlcm0sIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfcm1kaXJcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiB1bml4X3JtZGlyKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYgKCFyb290LmRldmljZS5ybWRpcikge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3JtZGlyOiBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgcmV0dXJuIHJvb3QuZGV2aWNlLnJtZGlyKHJvb3QucmVzdCwgLyogcmFpc2UgVW5peF9lcnJvciAqLyB0cnVlKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9zeW1saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9zeW1saW5rKHRvX2Rpciwgc3JjLCBkc3QpIHtcbiAgdmFyIHNyY19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uoc3JjKTtcbiAgdmFyIGRzdF9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2UoZHN0KTtcbiAgaWYoc3JjX3Jvb3QuZGV2aWNlICE9IGRzdF9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9zeW1saW5rOiBjYW5ub3Qgc3ltbGluayBiZXR3ZWVuIHR3byBmaWxlc3lzdGVtc1wiKTtcbiAgaWYgKCFzcmNfcm9vdC5kZXZpY2Uuc3ltbGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3N5bWxpbms6IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICByZXR1cm4gc3JjX3Jvb3QuZGV2aWNlLnN5bWxpbmsodG9fZGlyLCBzcmNfcm9vdC5yZXN0LCBkc3Rfcm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3JlYWRsaW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF9yZWFkbGluayhuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmICghcm9vdC5kZXZpY2UucmVhZGxpbmspIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwidW5peF9yZWFkbGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS5yZWFkbGluayhyb290LnJlc3QsIC8qIHJhaXNlIFVuaXhfZXJyb3IgKi8gdHJ1ZSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdW5saW5rXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gdW5peF91bmxpbmsobmFtZSkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZiAoIXJvb3QuZGV2aWNlLnVubGluaykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJ1bml4X3VubGluazogbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHJldHVybiByb290LmRldmljZS51bmxpbmsocm9vdC5yZXN0LCAvKiByYWlzZSBVbml4X2Vycm9yICovIHRydWUpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dldHVpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbmZ1bmN0aW9uIHVuaXhfZ2V0dWlkKHVuaXQpIHtcbiAgaWYoZ2xvYmFsVGhpcy5wcm9jZXNzICYmIGdsb2JhbFRoaXMucHJvY2Vzcy5nZXR1aWQpe1xuICAgIHJldHVybiBnbG9iYWxUaGlzLnByb2Nlc3MuZ2V0dWlkKCk7XG4gIH1cbiAgY2FtbF9yYWlzZV9ub3RfZm91bmQoKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nZXRwd3VpZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbmZ1bmN0aW9uIHVuaXhfZ2V0cHd1aWQodW5pdCkge1xuICBjYW1sX3JhaXNlX25vdF9mb3VuZCgpXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfaGFzX3N5bWxpbmtcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2hhc19zeW1saW5rKHVuaXQpIHtcbiAgcmV0dXJuIGZzX25vZGVfc3VwcG9ydGVkKCk/MTowXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIFN5c1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3N5c19lcnJvciAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5TeXNfZXJyb3IsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuKXtcbiAgc3dpdGNoKGV4blsyXSkge1xuICBjYXNlIC04OiAvLyBNYXRjaF9mYWlsdXJlXG4gIGNhc2UgLTExOiAvLyBBc3NlcnRfZmFpbHVyZVxuICBjYXNlIC0xMjogLy8gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGVcbiAgICByZXR1cm4gMTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihleG4pe1xuICB2YXIgciA9IFwiXCI7XG4gIGlmKGV4blswXSA9PSAwKSB7XG4gICAgciArPSBleG5bMV1bMV07XG4gICAgaWYoZXhuLmxlbmd0aCA9PSAzICYmIGV4blsyXVswXSA9PSAwICYmIGNhbWxfaXNfc3BlY2lhbF9leGNlcHRpb24oZXhuWzFdKSkge1xuXG4gICAgICB2YXIgYnVja2V0ID0gZXhuWzJdO1xuICAgICAgdmFyIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gMlxuICAgICAgdmFyIGJ1Y2tldCA9IGV4bjtcbiAgICB9XG4gICAgciArPSBcIihcIjtcbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8IGJ1Y2tldC5sZW5ndGg7IGkgKyspe1xuICAgICAgaWYoaSA+IHN0YXJ0KSByKz1cIiwgXCI7XG4gICAgICB2YXIgdiA9IGJ1Y2tldFtpXVxuICAgICAgaWYodHlwZW9mIHYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcis9IHYudG9TdHJpbmcoKTtcbiAgICAgIGVsc2UgaWYodiBpbnN0YW5jZW9mIE1sQnl0ZXMpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKHR5cGVvZiB2ID09IFwic3RyaW5nXCIpe1xuICAgICAgICByKz0gJ1wiJyArIHYudG9TdHJpbmcoKSArICdcIic7XG4gICAgICB9XG4gICAgICBlbHNlIHIgKz0gXCJfXCI7XG4gICAgfVxuICAgIHIgKz0gXCIpXCJcbiAgfSBlbHNlIGlmIChleG5bMF0gPT0gMjQ4KXtcbiAgICByICs9IGV4blsxXVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX2Zvcm1hdF9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGVycil7XG4gIGlmKGVyciBpbnN0YW5jZW9mIEFycmF5ICYmIChlcnJbMF0gPT0gMCB8fCBlcnJbMF0gPT0gMjQ4KSkge1xuICAgIHZhciBoYW5kbGVyID0gY2FtbF9uYW1lZF92YWx1ZShcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIik7XG4gICAgaWYoaGFuZGxlcikgaGFuZGxlcihlcnIsZmFsc2UpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIG1zZyA9IGNhbWxfZm9ybWF0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgdmFyIGF0X2V4aXQgPSBjYW1sX25hbWVkX3ZhbHVlKFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIpO1xuICAgICAgaWYoYXRfZXhpdCkgeyBhdF9leGl0KDApIH1cbiAgICAgIGdsb2JhbFRoaXMuY29uc29sZS5lcnJvcihcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gXCIgKyBtc2cgKyBcIlxcblwiKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9zdGF0aWNfZW52XG5mdW5jdGlvbiBjYW1sX3NldF9zdGF0aWNfZW52KGssdil7XG4gIGlmKCFnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudilcbiAgICBnbG9iYWxUaGlzLmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W2tdID0gdjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRlbnYgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgZ2xvYmFsVGhpcy5qc29vX3N0YXRpY19lbnZbbl0pXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGdsb2JhbFRoaXMuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgaWYoZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICBpZih0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIC8vIFdlYmJyb3dzZXJzXG4gICAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQzMkFycmF5KDEpO1xuICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH0gZWxzZSBpZihnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAvLyBOb2RlanNcbiAgICAgIHZhciBidWZmID0gZ2xvYmFsVGhpcy5jcnlwdG8ucmFuZG9tQnl0ZXMoNCk7XG4gICAgICB2YXIgYSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQzMkFycmF5KGJ1ZmYpO1xuICAgICAgcmV0dXJuIFswLGFbMF1dO1xuICAgIH1cbiAgfVxuICB2YXIgbm93ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgdmFyIHggPSBub3deMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4gWzAseF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfaW50X3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSBjb25zdFxuLy8gbWF4X2ludCAvIDQgc28gdGhhdCB0aGUgZm9sbG93aW5nIGRvZXMgbm90IG92ZXJmbG93XG4vL2xldCBtYXhfc3RyaW5nX2xlbmd0aCA9IHdvcmRfc2l6ZSAvIDggKiBtYXhfYXJyYXlfbGVuZ3RoIC0gMTs7XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplICgpIHsgcmV0dXJuICgweDdGRkZGRkZGLzQpIHwgMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IGNvbnN0XG4vL1JlcXVpcmVzOiBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCAoKSB7IHJldHVybiBvc190eXBlID09IFwiVW5peFwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuLy9SZXF1aXJlczogb3NfdHlwZVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIG9zX3R5cGUgPT0gXCJXaW4zMlwiID8gMSA6IDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3Rcbi8vUmVxdWlyZXM6IG9zX3R5cGVcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gb3NfdHlwZSA9PSBcIkN5Z3dpblwiID8gMSA6IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJqc19vZl9vY2FtbFwiKV07XG59XG5cbi8vUHJvdmlkZXM6IG9zX3R5cGVcbnZhciBvc190eXBlID0gKGdsb2JhbFRoaXMucHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5wcm9jZXNzLnBsYXRmb3JtICYmXG4gICAgICAgICAgICAgICBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPT0gXCJ3aW4zMlwiKSA/IFwiQ3lnd2luXCIgOiBcIlVuaXhcIjtcblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBvc190eXBlXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG9zX3R5cGUpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfdmFyaWFudFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3ZhcmlhbnQoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyKCl7cmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbnZhciBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MgKGJvb2wpIHtcbiAgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gYm9vbDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkXG4vL1JlcXVpcmVzOiBjYW1sX3J1bnRpbWVfd2FybmluZ3NcbmZ1bmN0aW9uIGNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9ydW50aW1lX3dhcm5pbmdzO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfZW5hYmxlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cblxuLy9BbHdheXNcbi8vUmVxdWlyZXM6IGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX3NldHVwX3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyKCkge1xuICB2YXIgZyA9IGdsb2JhbFRoaXM7XG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Mub24pIHtcbiAgICBnLnByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGVyciwgb3JpZ2luKSB7XG4gICAgICBjYW1sX2ZhdGFsX3VuY2F1Z2h0X2V4Y2VwdGlvbihlcnIpO1xuICAgICAgZy5wcm9jZXNzLmV4aXQgKDIpO1xuICAgIH0pXG4gIH1cbiAgZWxzZSBpZihnLmFkZEV2ZW50TGlzdGVuZXIpe1xuICAgIGcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbihldmVudCl7XG4gICAgICBpZihldmVudC5lcnJvcil7XG4gICAgICAgIGNhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uKGV2ZW50LmVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2FtbF9zZXR1cF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlcigpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfcmFpc2Vfd2l0aF9hcmdzLCBjYW1sX25hbWVkX3ZhbHVlc1xuLy9SZXF1aXJlczogbWFrZV91bml4X2Vycl9hcmdzXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jcmVhdGVfZGlyX2lmX25lZWRlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgcmVzICs9IGNvbXBbaV0gKyBcIi9cIjtcbiAgICBpZih0aGlzLmNvbnRlbnRbcmVzXSkgY29udGludWU7XG4gICAgdGhpcy5jb250ZW50W3Jlc10gPSBTeW1ib2woXCJkaXJlY3RvcnlcIik7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuc2xhc2ggPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIC9cXC8kLy50ZXN0KG5hbWUpP25hbWU6KG5hbWUgKyBcIi9cIik7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkge1xuICAgICAgdGhpcy5jcmVhdGVfZGlyX2lmX25lZWRlZChuYW1lKTtcbiAgICAgIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgICB9XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV9zbGFzaF0pIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbihuYW1lLG1vZGUsIHJhaXNlX3VuaXgpIHtcbiAgdmFyIHVuaXhfZXJyb3IgPSByYWlzZV91bml4ICYmIGNhbWxfbmFtZWRfdmFsdWUoJ1VuaXguVW5peF9lcnJvcicpO1xuICBpZih0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFRVhJU1RcIiwgXCJta2RpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBGaWxlIGV4aXN0c1wiKTtcbiAgICB9XG4gIH1cbiAgdmFyIHBhcmVudCA9IC9eKC4qKVxcL1teL10rLy5leGVjKG5hbWUpO1xuICBwYXJlbnQgPSAocGFyZW50ICYmIHBhcmVudFsxXSkgfHwgJyc7XG4gIGlmKCF0aGlzLmV4aXN0cyhwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PRU5UXCIsIFwibWtkaXJcIiwgdGhpcy5ubShwYXJlbnQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IocGFyZW50ICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihwYXJlbnQpKXtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcIm1rZGlyXCIsIHRoaXMubm0ocGFyZW50KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHBhcmVudCArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9XG4gIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQodGhpcy5zbGFzaChuYW1lKSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24obmFtZSwgcmFpc2VfdW5peCkge1xuICB2YXIgdW5peF9lcnJvciA9IHJhaXNlX3VuaXggJiYgY2FtbF9uYW1lZF92YWx1ZSgnVW5peC5Vbml4X2Vycm9yJyk7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoodGhpcy5zbGFzaChuYW1lKSk7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIGlmKCF0aGlzLmV4aXN0cyhuYW1lKSkge1xuICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICBjYW1sX3JhaXNlX3dpdGhfYXJncyh1bml4X2Vycm9yLCBtYWtlX3VuaXhfZXJyX2FyZ3MoXCJFTk9FTlRcIiwgXCJybWRpclwiLCB0aGlzLm5tKG5hbWUpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfVxuICBpZighdGhpcy5pc19kaXIobmFtZSkpIHtcbiAgICBpZiAodW5peF9lcnJvcikge1xuICAgICAgY2FtbF9yYWlzZV93aXRoX2FyZ3ModW5peF9lcnJvciwgbWFrZV91bml4X2Vycl9hcmdzKFwiRU5PVERJUlwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lICsgXCI6IE5vdCBhIGRpcmVjdG9yeVwiKTtcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmKG4ubWF0Y2gocikpIHtcbiAgICAgIGlmICh1bml4X2Vycm9yKSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmdzKHVuaXhfZXJyb3IsIG1ha2VfdW5peF9lcnJfYXJncyhcIkVOT1RFTVBUWVwiLCBcInJtZGlyXCIsIHRoaXMubm0obmFtZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIjogRGlyZWN0b3J5IG5vdCBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lX3NsYXNoXTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOih0aGlzLnNsYXNoKG5hbWUpKTtcbiAgaWYoIXRoaXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xuICB9XG4gIGlmKCF0aGlzLmlzX2RpcihuYW1lKSkge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xuICB9XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKylcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICBpZihuYW1lID09IFwiXCIpICByZXR1cm4gdHJ1ZTtcbiAgdmFyIG5hbWVfc2xhc2ggPSB0aGlzLnNsYXNoKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVfc2xhc2hdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICB2YXIgZmlsZTtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgaWYoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgZmlsZSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIGZpbGUgPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpKTtcbiAgICBmaWxlID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGlmKGZpbGUpe1xuICAgIHRoaXMuY3JlYXRlX2Rpcl9pZl9uZWVkZWQobmFtZSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gZmlsZTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfc3RyaW5nKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgZ2xvYmFsVGhpcy5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgdmFyIGluZm8gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhpbmZvKTtcbiAgZnVuY3Rpb24gZ2V0KG5hbWUpe1xuICAgIHZhciByZXMgPSBpbmZvLm1hdGNoKFwiKF58LCkgKlwiK25hbWUrXCIgKj0gKihbYS16QS1aMC05X10rKSAqKCx8JClcIik7XG4gICAgaWYocmVzKSByZXR1cm4gcmVzWzJdO1xuICB9XG4gIHZhciBzcGVjcyA9IFtdO1xuICBpZighKGluZm89PVwiXCIpKSBzcGVjcy5wdXNoKGluZm8pO1xuICB2YXIgdGFyZ2V0ID0gZ2V0KFwidGFyZ2V0XCIpO1xuICBpZighdGFyZ2V0KSB0YXJnZXQ9XCJcIjtcbiAgdmFyIHN0YXR1cyA9IGdldChcInN0YXR1c1wiKTtcbiAgaWYoIXN0YXR1cykgc3BlY3MucHVzaChcInN0YXR1cz0xXCIpXG5cbiAgdmFyIHcgPSBnZXQoXCJ3aWR0aFwiKTtcbiAgdyA9IHc/cGFyc2VJbnQodyk6MjAwO1xuICBzcGVjcy5wdXNoKFwid2lkdGg9XCIrdyk7XG5cbiAgdmFyIGggPSBnZXQoXCJoZWlnaHRcIik7XG4gIGggPSBoP3BhcnNlSW50KGgpOjIwMDtcbiAgc3BlY3MucHVzaChcImhlaWdodD1cIitoKTtcblxuICB2YXIgd2luID0gZy5vcGVuKFwiYWJvdXQ6YmxhbmtcIix0YXJnZXQsc3BlY3Muam9pbihcIixcIikpO1xuICBpZighd2luKSB7Y2FtbF9mYWlsd2l0aChcIkdyYXBoaWNzLm9wZW5fZ3JhcGg6IGNhbm5vdCBvcGVuIHRoZSB3aW5kb3dcIil9XG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHZhciBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLndpZHRoID0gdztcbiAgY2FudmFzLmhlaWdodCA9IGg7XG4gIHZhciBjdHggPSBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKTtcbiAgY3R4LnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgIGRvYy50aXRsZSA9IHRpdGxlO1xuICB9O1xuICBjYW1sX2dyX3N0YXRlX3NldChjdHgpO1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICBib2R5LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfY29sb3IsY2FtbF9ncl9tb3ZldG8sY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoLGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSxjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpe1xuICBjYW1sX2dyX21vdmV0byhjYW1sX2dyX3N0YXRlLngsY2FtbF9ncl9zdGF0ZS55KTtcbiAgY2FtbF9ncl9yZXNpemVfd2luZG93KGNhbWxfZ3Jfc3RhdGUud2lkdGgsY2FtbF9ncl9zdGF0ZS5oZWlnaHQpO1xuICBjYW1sX2dyX3NldF9saW5lX3dpZHRoKGNhbWxfZ3Jfc3RhdGUubGluZV93aWR0aCk7XG4gIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShjYW1sX2dyX3N0YXRlLnRleHRfc2l6ZSk7XG4gIGNhbWxfZ3Jfc2V0X2ZvbnQoY2FtbF9ncl9zdGF0ZS5mb250KTtcbiAgY2FtbF9ncl9zZXRfY29sb3IoY2FtbF9ncl9zdGF0ZS5jb2xvcik7XG4gIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShjYW1sX2dyX3N0YXRlLnRpdGxlKTtcbiAgLy9jYW1sX2dyX3Jlc2l6ZV93aW5kb3cgbWlnaHQgcmVzZXQgc29tZSBjYW52YXMnIHByb3BlcnRpZXNcbiAgY2FtbF9ncl9zdGF0ZS5jb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCl7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNhbnZhcyA6IGNhbnZhcyxcbiAgICB4IDogMCxcbiAgICB5IDogMCxcbiAgICB3aWR0aCA6IHcsXG4gICAgaGVpZ2h0IDogaCxcbiAgICBsaW5lX3dpZHRoIDogMSxcbiAgICBmb250IDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImZpeGVkXCIpLFxuICAgIHRleHRfc2l6ZSA6IDI2LFxuICAgIGNvbG9yIDogMHgwMDAwMDAsXG4gICAgdGl0bGUgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZG9jX29mX3N0YXRlXG5mdW5jdGlvbiBjYW1sX2dyX2RvY19vZl9zdGF0ZShzdGF0ZSkge1xuICBpZihzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudClcbiAgICByZXR1cm4gc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2VfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSAwO1xuICBzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShuYW1lKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRpdGxlID0gbmFtZTtcbiAgdmFyIGpzbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihzLnNldF90aXRsZSkgcy5zZXRfdGl0bGUoanNuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyh3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KClcbiAgcy53aWR0aCA9IHc7XG4gIHMuaGVpZ2h0ID0gaDtcbiAgcy5jYW52YXMud2lkdGggPSB3O1xuICBzLmNhbnZhcy5oZWlnaHQgPSBoO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbGVhcl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xlYXJfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gIHMuY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAvLyAgcy5jb250ZXh0LnN0cm9rZVJlY3QgKDAuLCAwLiwgcy53aWR0aCwgcy5oZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLndpZHRoO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmhlaWdodDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2NvbG9yKGNvbG9yKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBmdW5jdGlvbiBjb252ZXJ0KG51bWJlcikge1xuICAgIHZhciBzdHIgPSAnJyArIG51bWJlci50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSBzdHIgPSAnMCcgKyBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXJcbiAgciA9IChjb2xvciA+PiAxNikgJiAweGZmLFxuICBnID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsXG4gIGIgPSAoY29sb3IgPj4gMCkgICYgMHhmZjtcbiAgcy5jb2xvcj1jb2xvcjtcbiAgdmFyIGNfc3RyID0gJyMnICsgY29udmVydChyKSArIGNvbnZlcnQoZykgKyBjb252ZXJ0KGIpO1xuICBzLmNvbnRleHQuZmlsbFN0eWxlID0gICBjX3N0cjtcbiAgcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY19zdHI7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9wbG90XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wbG90KHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICB2YXIgY29sb3IgPSBzLmNvbG9yO1xuICBkWzBdID0gKGNvbG9yID4+IDE2KSAmIDB4ZmY7IC8vclxuICBkWzFdID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsIC8vZ1xuICBkWzJdID0gKGNvbG9yID4+IDApICAmIDB4ZmY7IC8vYlxuICBkWzNdID0gMHhGRjsgLy9hXG4gIHMueD14O1xuICBzLnk9eTtcbiAgcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbSx4LHMuaGVpZ2h0IC0geSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3BvaW50X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wb2ludF9jb2xvcih4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSB5LDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgcmV0dXJuIChkWzBdIDw8IDE2KSArIChkWzFdIDw8IDgpICsgZFsyXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbW92ZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tb3ZldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueFxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbGluZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9saW5ldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8ocy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy5jb250ZXh0LmxpbmVUbyh4LHMuaGVpZ2h0IC0geSk7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LnN0cm9rZVJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfYXJjX2F1eChjdHgsY3gsY3kscnkscngsYTEsYTIpe1xuICB3aGlsZShhMT5hMikgYTIrPTM2MDtcbiAgYTEgLz0gMTgwO1xuICBhMiAvPSAxODA7XG4gIHZhciByb3QgPSAwLHhQb3MseVBvcyx4UG9zX3ByZXYseVBvc19wcmV2O1xuICB2YXIgc3BhY2UgPSAyO1xuICB2YXIgbnVtID0gKCgoYTIgLSBhMSkgKiBNYXRoLlBJICogKChyeCtyeSkvMikpIC8gc3BhY2UpIHwgMDtcbiAgdmFyIGRlbHRhID0gKGEyIC0gYTEpICogTWF0aC5QSSAvIG51bTtcbiAgdmFyIGkgPSBhMSAqIE1hdGguUEk7XG4gIGZvciAodmFyIGo9MDtqPD1udW07aisrKXtcbiAgICB4UG9zID0gY3ggLSAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHhQb3MgPSB4UG9zLnRvRml4ZWQoMik7XG4gICAgeVBvcyA9IGN5ICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB5UG9zID0geVBvcy50b0ZpeGVkKDIpO1xuICAgIGlmIChqPT0wKSB7XG4gICAgICBjdHgubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgIH0gZWxzZSBpZiAoeFBvc19wcmV2IT14UG9zIHx8IHlQb3NfcHJldiE9eVBvcyl7XG4gICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgIH1cbiAgICB4UG9zX3ByZXY9eFBvcztcbiAgICB5UG9zX3ByZXY9eVBvcztcbiAgICBpLT0gZGVsdGE7Ly9jY3dcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgodyl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5saW5lX3dpZHRoID0gdztcbiAgcy5jb250ZXh0LmxpbmVXaWR0aCA9IHdcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmZpbGxSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9wb2x5XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3BvbHkoYXIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgZm9yKHZhciBpID0gMjsgaSA8IGFyLmxlbmd0aDsgaSsrKVxuICAgIHMuY29udGV4dC5saW5lVG8oYXJbaV1bMV0scy5oZWlnaHQgLSBhcltpXVsyXSk7XG4gIHMuY29udGV4dC5saW5lVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyKHN0cil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIG0gPSBzLmNvbnRleHQubWVhc3VyZVRleHQoc3RyKTtcbiAgdmFyIGR4ID0gbS53aWR0aDtcbiAgcy5jb250ZXh0LmZpbGxUZXh0KHN0cixzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLnggKz0gZHggfCAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19jaGFyKGMpe1xuICBjYW1sX2dyX2RyYXdfc3RyKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHJpbmcoc3RyKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzdHIpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfZm9udChmKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmZvbnQgPSBmO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfdGV4dF9zaXplKHNpemUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGV4dF9zaXplID0gc2l6ZTtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl90ZXh0X3NpemUodHh0KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgdyA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0eHQpKS53aWR0aDtcbiAgcmV0dXJuIFswLHcscy50ZXh0X3NpemVdO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbWFrZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbWFrZV9pbWFnZShhcnIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBoID0gYXJyLmxlbmd0aCAtIDEgO1xuICB2YXIgdyA9IGFyclsxXS5sZW5ndGggLSAxO1xuICB2YXIgaW0gPSBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHcsaCk7XG4gIGZvcih2YXIgaT0wO2k8aDtpKyspe1xuICAgIGZvcih2YXIgaj0wO2o8dztqKyspe1xuICAgICAgdmFyIGMgPSBhcnJbaSsxXVtqKzFdO1xuICAgICAgdmFyIG8gPSBpKih3KjQpICsgKGogKiA0KTtcbiAgICAgIGlmKGMgPT0gLTEpIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSBjID4+IDE2ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSBjID4+ICA4ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSBjID4+ICAwICYgMFhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAweGZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHVtcF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHVtcF9pbWFnZShpbSl7XG4gIHZhciBkYXRhID0gWzBdXG4gIGZvcih2YXIgaT0wOyBpPGltLmhlaWdodDtpKyspe1xuICAgIGRhdGFbaSsxXSA9IFswXVxuICAgIGZvcih2YXIgaj0wOyBqPGltLndpZHRoO2orKyl7XG4gICAgICB2YXIgbyA9IGkqKGltLndpZHRoKjQpICsgKGogKiA0KSxcbiAgICAgICAgICByID0gaW0uZGF0YVtvKzBdLFxuICAgICAgICAgIGcgPSBpbS5kYXRhW28rMV0sXG4gICAgICAgICAgYiA9IGltLmRhdGFbbysyXTtcbiAgICAgIGRhdGFbaSsxXVtqKzFdID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiXG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBpZighaW0uaW1hZ2UpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbSwwLDApO1xuICAgIHZhciBpbWFnZSA9IG5ldyBnbG9iYWxUaGlzLkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBnbG9iYWxUaGlzLldlYWtNYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPj0gNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPCA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSB0cnVlXG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBnbG9iYWxUaGlzLmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc3RkX291dHB1dChjaGFuaWQscyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgc3RyID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgdmFyIGlkeCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg/Y2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeDowO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoaWR4KzEsY2FtbF9zdGRfb3V0cHV0LGZpbGUsZik7XG59XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDAsY2FtbF9zdGRfb3V0cHV0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGluXG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDEsanNfcHJpbnRfc3Rkb3V0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZG91dFxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgyLGpzX3ByaW50X3N0ZGVyciwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRlcnJcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSgpIHtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsc1xudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXI6XCJcIlxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N5c19vcGVuLGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZCwgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcbiAgdmFyIHJlZmlsbCA9IG51bGw7XG4gIGlmKGZkID09IDAgJiYgZnNfbm9kZV9zdXBwb3J0ZWQoKSl7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICByZWZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoZnMucmVhZEZpbGVTeW5jKDAsICd1dGY4JykpfTtcbiAgfVxuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICByZWZpbGw6cmVmaWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuLy9Qcm92aWRlczogd2luX2ZpbGVkZXNjcl9vZl9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvclxudmFyIHdpbl9maWxlZGVzY3Jfb2ZfY2hhbm5lbCA9IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdO1xuICBkYXRhLmZsYWdzLnRleHQgPSAhbW9kZVxuICBkYXRhLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gIGNoYW4uZmlsZS5jbG9zZSgpO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCxmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pIHtcbiAgdmFyIHN0ciA9IGNoYW4ucmVmaWxsKCk7XG4gIHZhciBzdHJfbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGlmIChzdHJfbGVuID09IDApIGNoYW4ucmVmaWxsID0gbnVsbDtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4uZmlsZS5sZW5ndGgoKSwgc3RyLCAwLCBzdHJfbGVuKTtcbiAgcmV0dXJuIHN0cl9sZW47XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgPT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoY2hhbi5maWxlLmxlbmd0aCgpICE9IGNoYW4ub2Zmc2V0KSByZXR1cm47XG4gIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXQgKGNoYW5pZCwgcywgaSwgbCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGwyID0gY2hhbi5maWxlLmxlbmd0aCgpIC0gY2hhbi5vZmZzZXQ7XG4gIGlmIChsMiA9PSAwICYmIGNoYW4ucmVmaWxsICE9IG51bGwpIGwyID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gIGlmIChsMiA8IGwpIGwgPSBsMjtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsIHMsIGksIGwpO1xuICBjaGFuLm9mZnNldCArPSBsO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZSAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyg4KTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsOCk7XG5cbiAgLy8gSGVhZGVyIGlzIDIwIGJ5dGVzXG4gIHZhciBsZW4gPSBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChidWYsIDApICsgMjA7XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG5cbiAgdmFyIG9mZnNldCA9IFswXTtcbiAgdmFyIHJlcyA9IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhidWYsIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9mZnNldCA+PSBjaGFuLmZpbGUubGVuZ3RoKCkpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5maWxlLnJlYWRfb25lKGNoYW4ub2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZmlsZSA9IGNoYW4uZmlsZTtcbiAgd2hpbGUgKChjaGFuLm9mZnNldCArIDMpID49IGZpbGUubGVuZ3RoKCkpIHtcbiAgICB2YXIgbCA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICAgIGlmIChsID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfVxuICB2YXIgbyA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgciA9KGZpbGUucmVhZF9vbmUobyAgKSA8PCAyNClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMSkgPDwgMTYpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzIpIDw8IDgpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzMpKTtcbiAgY2hhbi5vZmZzZXQrPTQ7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge3JldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5vZmZzZXQ7XG4gIHZhciBsZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKHAgPj0gbGVuKSB7IHJldHVybiAwO31cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGlmKHAgPj0gbGVuKSByZXR1cm4gLSAocCAtIGNoYW4ub2Zmc2V0KTtcbiAgICBpZihjaGFuLmZpbGUucmVhZF9vbmUocCkgPT0gMTApIHJldHVybiBwIC0gY2hhbi5vZmZzZXQgKyAxO1xuICAgIHArKztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBmbHVzaCBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXIgPT0gXCJcIikgcmV0dXJuIDA7XG4gIGlmKGNoYW4uZmRcbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF1cbiAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dDtcbiAgICBzd2l0Y2gob3V0cHV0Lmxlbmd0aCl7XG4gICAgY2FzZSAyOiBvdXRwdXQoY2hhbmlkLGNoYW4uYnVmZmVyKTticmVhaztcbiAgICBkZWZhdWx0OiBvdXRwdXQoY2hhbi5idWZmZXIpXG4gICAgfTtcbiAgfVxuICBjaGFuLmJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiAwO1xufVxuXG4vL291dHB1dCB0byBvdXRfY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCxjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IG91dHB1dCB0byBhIGNsb3NlZCBjaGFubmVsXCIpO1xuICB2YXIgYnl0ZXM7XG4gIGlmKG9mZnNldCA9PSAwICYmIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ1ZmZlcikgPT0gbGVuKVxuICAgIGJ5dGVzID0gYnVmZmVyO1xuICBlbHNlIHtcbiAgICBieXRlcyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGJ1ZmZlcixvZmZzZXQsYnl0ZXMsMCxsZW4pO1xuICB9XG4gIHZhciBzdHJpbmcgPSBjYW1sX3N0cmluZ19vZl9ieXRlcyhieXRlcyk7XG4gIHZhciBqc3N0cmluZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RyaW5nKTtcbiAgdmFyIGlkID0ganNzdHJpbmcubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gIGlmKGlkIDwgMClcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmc7XG4gIGVsc2Uge1xuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZy5zdWJzdHIoMCxpZCsxKTtcbiAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgIGNoYW4uYnVmZmVyICs9IGpzc3RyaW5nLnN1YnN0cihpZCsxKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXQoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKXtcbiAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxjYW1sX2J5dGVzX29mX3N0cmluZyhidWZmZXIpLG9mZnNldCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfY2hhciAoY2hhbmlkLGMpIHtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsZmxhZ3MpIHtcbiAgdmFyIHMgPSBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcodiwgZmxhZ3MpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXRfNjQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0IChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2ludCAoY2hhbmlkLGkpIHtcbiAgdmFyIGFyciA9IFsoaT4+MjQpICYgMHhGRiwoaT4+MTYpICYgMHhGRiwoaT4+OCkgJiAweEZGLGkgJiAweEZGIF07XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCw0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pc19idWZmZXJlZFxuZnVuY3Rpb24gY2FtbF9tbF9pc19idWZmZXJlZChjKSB7IHJldHVybiAxIH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYnVmZmVyZWRcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2J1ZmZlcmVkKGMsdikgeyByZXR1cm4gMCB9XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19yZXN1bWVcbmZ1bmN0aW9uIGNhbWxfZXZlbnRsb2dfcmVzdW1lKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ldmVudGxvZ19wYXVzZVxuZnVuY3Rpb24gY2FtbF9ldmVudGxvZ19wYXVzZSh1bml0KSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFxuZnVuY3Rpb24gY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50KHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nY19tYWpvcl9zbGljZVxuZnVuY3Rpb24gY2FtbF9nY19tYWpvcl9zbGljZSh3b3JrKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3Jfd29yZHNcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3Jfd29yZHModW5pdCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9taW5vcl9mcmVlXG5mdW5jdGlvbiBjYW1sX2dldF9taW5vcl9mcmVlKHVuaXQpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfbWFqb3JfYnVja2V0XG5mdW5jdGlvbiBjYW1sX2dldF9tYWpvcl9idWNrZXQobikgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9tYWpvcl9jcmVkaXRcbmZ1bmN0aW9uIGNhbWxfZ2V0X21ham9yX2NyZWRpdChuKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDE6ICB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gZy5JbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgY2FzZSA0OiAgdmlldyA9IGcuSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBnLlVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgNzogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTA6IHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICB9XG4gIGlmICghdmlldykgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUgKiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPCA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycmF5XCJcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA+PSA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycjAyXCJcblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IGNhbWxfYmFfY3VzdG9tX25hbWU7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGlmKGJhLmNhbWxfY3VzdG9tID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGJhLmRpbXNbaV0gPCAweGZmZmYpXG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSlcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgd3JpdGVyLndyaXRlKDgsMCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoYmEuZ2V0KGkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGogPSBiYS5nZXQoaSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzFdKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMV0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzJdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDQ7XG4gIHN6WzFdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSl7XG4gIHZhciBudW1fZGltcyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHdyb25nIG51bWJlciBvZiBiaWdhcnJheSBkaW1lbnNpb25zXCIpO1xuICB2YXIgdGFnID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIGtpbmQgPSB0YWcgJiAweGZmXG4gIHZhciBsYXlvdXQgPSAodGFnID4+IDgpICYgMTtcbiAgdmFyIGRpbXMgPSBbXVxuICBpZihuYW1lID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZV9kaW0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgaWYoc2l6ZV9kaW0gPT0gMHhmZmZmKXtcbiAgICAgICAgdmFyIHNpemVfZGltX2hpID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgdmFyIHNpemVfZGltX2xvID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgaWYoc2l6ZV9kaW1faGkgIT0gMClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGJpZ2FycmF5IGRpbWVuc2lvbiBvdmVyZmxvdyBpbiAzMmJpdFwiKTtcbiAgICAgICAgc2l6ZV9kaW0gPSBzaXplX2RpbV9sbztcbiAgICAgIH1cbiAgICAgIGRpbXMucHVzaChzaXplX2RpbSk7XG4gICAgfVxuICBlbHNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYmEpe1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGcgPSBnbG9iYWxUaGlzO1xuICB2YXIga2luZDtcbiAgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDMyQXJyYXkpIGtpbmQgPSAwO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQ2NEFycmF5KSBraW5kID0gMTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDhBcnJheSkga2luZCA9IDI7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50OEFycmF5KSBraW5kID0gMztcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDE2QXJyYXkpIGtpbmQgPSA0O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDE2QXJyYXkpIGtpbmQgPSA1O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MzJBcnJheSkga2luZCA9IDY7XG4gIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICByZXR1cm4ga2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkodGEpe1xuICB2YXIga2luZCA9IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3B1cmVfZXhwciBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19wdXJlX2V4cHIgKGYpIHsgcmV0dXJuIGYoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19zZXQobyxmLHYpIHsgb1tmXT12O3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19nZXQobyxmKSB7IHJldHVybiBvW2ZdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2RlbGV0ZSAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2RlbGV0ZShvLGYpIHsgZGVsZXRlIG9bZl07IHJldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2luc3RhbmNlb2YgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfaW5zdGFuY2VvZihvLGMpIHsgcmV0dXJuIChvIGluc3RhbmNlb2YgYykgPyAxIDogMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZVxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lKHJlcykge1xuICB2YXIgYyA9IDE7XG4gIHdoaWxlKHJlcyAmJiByZXMuam9vX3RyYW1wKXtcbiAgICByZXMgPSByZXMuam9vX3RyYW1wLmFwcGx5KG51bGwsIHJlcy5qb29fYXJncyk7XG4gICAgYysrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lX3JldHVyblxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpIHtcbiAgcmV0dXJuIHtqb29fdHJhbXA6Zixqb29fYXJnczphcmdzfTtcbn1cblxuLy9Qcm92aWRlczoganNfcHJpbnRfc3Rkb3V0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3Rkb3V0KHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3RkZXJyLndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICYmIHYuZXJyb3IgJiYgdi5lcnJvcihzKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudFxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmKGUgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGU7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gIGlmKGdsb2JhbFRoaXMuUmFuZ2VFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGdsb2JhbFRoaXMuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1dyYXAgRXJyb3IgaW4gSnMuRXJyb3IgZXhjZXB0aW9uXG4gIGlmKGUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGdsb2JhbFRoaXMuRXJyb3IoXCJKcyBleGNlcHRpb24gY29udGFpbmluZyBiYWNrdHJhY2VcIik7XG4gIHJldHVybiBleG47XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vcHRpb25fb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29wdGlvbl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gWzAsIGV4bi5qc19lcnJvcl07IH1cbiAgcmV0dXJuIDA7XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vZ2xvYmFsVGhpcy5jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19tZXRoX2NhbGwobywgZiwgYXJncykge1xuICByZXR1cm4gb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhmKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPiAwKXtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFt1bmRlZmluZWRdKTtcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50c1xuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW2FyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihuID09IGFyaXR5ICYmIGYubGVuZ3RoID09IGFyaXR5KSByZXR1cm4gZi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5KTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixhcmdzKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsW3RoaXMsYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdChhcml0eSwgZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyaXR5ICsgMSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgfTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PSB5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V2YWxfc3RyaW5nIChzKSB7cmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXhwcihzKSB7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3B1cmVfanNfZXhwciAocyl7XG4gIGpzX3ByaW50X3N0ZGVycihcImNhbWxfcHVyZV9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX29iamVjdCAoYSkge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IGFbaV07XG4gICAgb1tjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhwWzFdKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19jb250ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhvYmopKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHZhciBjb250ZW50ID0gY2FtbF9tbF9ieXRlc19jb250ZW50KG9iaik7XG4gICAgICBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuXHRmb3IgKHZhciBiID0gY29udGVudCwgbCA9IGIubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgIH0gZWxzZSB7IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBjb250ZW50LCBsID0gYS5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgIHZhciBqc2J5dGVzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvYmopO1xuICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9yICh2YXIgYiA9IG9iaiwgbCA9IG9iai5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICB2YXIgY29udGVudCA9IGNhbWxfbWxfYnl0ZXNfY29udGVudCh2KTtcbiAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjb250ZW50KVxuICBlbHNlIC8qIEFSUkFZICovXG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIGNvbnRlbnQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSB2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBnbG9iYWxUaGlzLm5hdmlnYXRvcj9nbG9iYWxUaGlzLm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllc1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VudGl0aWVzKHMpIHtcbiAgdmFyIGVudGl0eSA9IC9eJiM/WzAtOWEtekEtWl0rOyQvXG4gIGlmKHMubWF0Y2goZW50aXR5KSlcbiAge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJJbnZhbGlkIGVudGl0eSBcIiArIHMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGdsb2JhbFRoaXMuY29uc29sZT9nbG9iYWxUaGlzLmNvbnNvbGU6e307XG4gIHZhciBtID0gW1wibG9nXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwiYXNzZXJ0XCIsIFwiZGlyXCIsIFwiZGlyeG1sXCIsXG4gICAgICAgICAgIFwidHJhY2VcIiwgXCJncm91cFwiLCBcImdyb3VwQ29sbGFwc2VkXCIsIFwiZ3JvdXBFbmRcIiwgXCJ0aW1lXCIsIFwidGltZUVuZFwiXTtcbiAgZnVuY3Rpb24gZiAoKSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIGlmICghY1ttW2ldXSkgY1ttW2ldXT1mO1xuICByZXR1cm4gYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vV2Vha2RlZlxuZnVuY3Rpb24gY2FtbF94bWxodHRwcmVxdWVzdF9jcmVhdGUodW5pdCl7XG4gIHZhciBnID0gZ2xvYmFsVGhpcztcbiAgaWYodHlwZW9mIGcuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uXG5mdW5jdGlvbiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvbihleG4pIHtcbiAgaWYoZXhuLmpzX2Vycm9yKSB7IHJldHVybiBleG4uanNfZXJyb3I7IH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7XG4gIGlmICgoeCBpbnN0YW5jZW9mIEFycmF5KSAmJiB4WzBdID09ICh4WzBdID4+PiAwKSlcbiAgICByZXR1cm4geFswXVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmICgoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIDI0N1xuICBlbHNlIGlmICh4ICYmIHguY2FtbF9jdXN0b20pXG4gICAgcmV0dXJuIDI1NVxuICBlbHNlXG4gICAgcmV0dXJuIDEwMDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnICh4LCB0YWcpIHsgeFswXSA9IHRhZzsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrICh0YWcsIHNpemUpIHtcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSsxKTtcbiAgb1swXT10YWc7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHNpemU7IGkrKykgb1tpXSA9IDA7XG4gIHJldHVybiBvO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial93aXRoX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfd2l0aF90YWcodGFnLHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSB0YWc7XG4gIGZvcih2YXIgaSA9IDE7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1xuZnVuY3Rpb24gY2FtbF9vYmpfcmVhY2hhYmxlX3dvcmRzKG8pIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfYWRkX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9vYmpfYWRkX29mZnNldCh2LG9mZnNldCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiT2JqLmFkZF9vZmZzZXQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyhoLCBicykge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCxicy5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5KGJzKSB7XG4gIHJldHVybiBicy5kYXRhXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyKGFiKSB7XG4gIHZhciB0YSA9IG5ldyBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IGdsb2JhbFRoaXMuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfYmxpdF9kYXRhKHNyYywgZHN0KXtcbiAgZHN0W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBzcmNbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSBkYXRhO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3Vuc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX21sX2J5dGVzX2NvbnRlbnRcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgdmFyIGNvbnRlbnQgPSBjYW1sX21sX2J5dGVzX2NvbnRlbnQocyk7XG4gICAgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpe1xuICAgICAgdmFyIGIgPSBjb250ZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgfSBlbHNlIHsgLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gY29udGVudDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iXX0=
